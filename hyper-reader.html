<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📖</text></svg>">
  <title>Text Reader</title>
  <style>
    @font-face {
      font-family: Reader1;
      src: local('LMRoman12-Regular'), url('https://mirror.kku.ac.th/CTAN/fonts/lm/fonts/opentype/public/lm/lmroman12-regular.otf') format('opentype');
    }
    @font-face {
      font-family: Reader;
      font-weight: 400;
      src: local('WorkSans-Regular');
    }
    @font-face {
      font-family: Reader;
      font-weight: 500;
      src: local('WorkSans-Medium');
    }

    /** reset **/
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      border: 0;
      outline: 0;
      transform-origin: 50% 50%;
    }
    p {
      margin: 1em 0;
    }
    hr {
      border: 0;
      height: 1px;
      background: rgba(0, 0, 0, .2);
    }
    a,
    a:any-link {
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-skip-ink: none;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    small {
      font-size: 0.875em;
    }

    /** rose pine **/
    :root {
      --rp-main-base: #191724;
      --rp-main-surface: #1f1d2e;
      --rp-main-overlay: #26233a;
      --rp-main-muted: #6e6a86;
      --rp-main-subtle: #908caa;
      --rp-main-text: #e0def4;
      --rp-main-love: #eb6f92;
      --rp-main-gold: #f6c177;
      --rp-main-rose: #ebbcba;
      --rp-main-pine: #31748f;
      --rp-main-foam: #9ccfd8;
      --rp-main-iris: #c4a7e7;
      --rp-main-highlight-low: #21202e;
      --rp-main-highlight-low-alpha: #6e6a861a;
      --rp-main-highlight-med: #403d52;
      --rp-main-highlight-med-alpha: #6e6a8633;
      --rp-main-highlight-high: #524f67;
      --rp-main-highlight-high-alpha: #6e6a8666;
      --rp-moon-base: #232136;
      --rp-moon-surface: #2a273f;
      --rp-moon-overlay: #393552;
      --rp-moon-muted: #6e6a86;
      --rp-moon-subtle: #908caa;
      --rp-moon-text: #e0def4;
      --rp-moon-love: #eb6f92;
      --rp-moon-gold: #f6c177;
      --rp-moon-rose: #ea9a97;
      --rp-moon-pine: #3e8fb0;
      --rp-moon-foam: #9ccfd8;
      --rp-moon-iris: #c4a7e7;
      --rp-moon-highlight-low: #2a283e;
      --rp-moon-highlight-low-alpha: #817c9c14;
      --rp-moon-highlight-med: #44415a;
      --rp-moon-highlight-med-alpha: #817c9c26;
      --rp-moon-highlight-high: #56526e;
      --rp-moon-highlight-high-alpha: #817c9c4d;
      --rp-dawn-base: #faf4ed;
      --rp-dawn-surface: #fffaf3;
      --rp-dawn-overlay: #f2e9e1;
      --rp-dawn-muted: #9893a5;
      --rp-dawn-subtle: #797593;
      --rp-dawn-text: #575279;
      --rp-dawn-love: #b4637a;
      --rp-dawn-gold: #ea9d34;
      --rp-dawn-rose: #d7827e;
      --rp-dawn-pine: #286983;
      --rp-dawn-foam: #56949f;
      --rp-dawn-iris: #907aa9;
      --rp-dawn-highlight-low: #f4ede8;
      --rp-dawn-highlight-low-alpha: #6e6a860d;
      --rp-dawn-highlight-med: #dfdad9;
      --rp-dawn-highlight-med-alpha: #6e6a8614;
      --rp-dawn-highlight-high: #cecacd;
      --rp-dawn-highlight-high-alpha: #6e6a8626;
    }

    /** variables **/
    :root {
      --nav-width: 300px;
      --aside-width: 60px;
      --gap: 1rem;
      --paper-padding: calc(var(--gap) * 3);
      cursor: default;
    }
    .settings .colors button.white {
      --body-font-color: rgb(27, 27, 27);
      --body-background-color: rgb(230, 230, 230);
      --paper-background-color: rgb(255, 255, 255);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(65, 110, 210);
      --horizontal-line-color: rgb(220, 220, 220);
    }
    :root[data-color\:light=white] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    :root[data-color\:dark=white] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    .settings .colors button.sepia {
      --body-font-color: rgb(79, 50, 28);
      --body-background-color: rgb(225, 216, 200);
      --paper-background-color: rgb(248, 241, 227);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(209, 150, 0);
      --horizontal-line-color: rgb(230, 218, 201);
    }
    :root[data-color\:light=sepia] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    :root[data-color\:dark=sepia] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    .settings .colors button.gray {
      --body-font-color: rgba(255, 255, 255, 0.78);
      --body-background-color: rgb(50, 50, 51);
      --paper-background-color: rgb(74, 74, 77);
      /*--paper-shadow-color: rgba(0, 0, 0, .24); */
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(111, 111, 111);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=gray] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=gray] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.night {
      --body-font-color: rgb(176, 176, 176);
      --body-background-color: rgb(0, 0, 0);
      --paper-background-color: rgb(18, 18, 18);
      --paper-outline-color: #272727;
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(62, 62, 62);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=night] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=night] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine {
      --body-font-color: var(--rp-main-subtle);
      --body-background-color: var(--rp-main-surface);
      --paper-background-color: var(--rp-main-base);
      --paper-outline-color: var(--rp-main-highlight-med-alpha);
      --link-color: var(--rp-main-pine);
      --horizontal-line-color: var(--rp-main-highlight-high-alpha);
      --selection-bg: var(--rp-main-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-moon {
      --body-font-color: var(--rp-moon-subtle);
      --body-background-color: var(--rp-moon-surface);
      --paper-background-color: var(--rp-moon-base);
      --paper-outline-color: var(--rp-moon-highlight-med-alpha);
      --link-color: var(--rp-moon-rose);
      --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
      --selection-bg: var(--rp-moon-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine-moon] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine-moon] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-dawn {
      --body-font-color: var(--rp-dawn-text);
      --body-background-color: var(--rp-dawn-base);
      --paper-background-color: var(--rp-dawn-overlay);
      --paper-outline-color: var(--rp-dawn-highlight-med);
      --link-color: var(--rp-dawn-love);
      --horizontal-line-color: var(--rp-dawn-highlight-high);
      --selection-bg: var(--rp-dawn-highlight-med);
    }
    :root[data-color\:light=rose-pine-dawn] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }
    :root[data-color\:dark=rose-pine-dawn] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }

    :root,
    :root[data-paper-size=sm] { --paper-width: 90ex; }
    :root[data-paper-size=md] { --paper-width: 120ex; }
    :root[data-paper-size=lg] { --paper-width: 160ex; }
    :root[data-paper-size=xl] { --paper-width: 100%; }

    *::selection {
      background-color: var(--selection-bg);
    }

    /** layout **/
    body {
      display: grid;
      grid-template-columns: minmax(var(--nav-width), 1fr) minmax(auto, calc(var(--paper-width) + 2*var(--paper-padding))) minmax(var(--aside-width), 1fr);
    }

    /** global **/
    html,
    body {
      font: 16pt/1.4 Reader;
      color: var(--body-font-color);
      background: var(--body-background-color);
      font-variant-numeric: oldstyle-nums tabular-nums slashed-zero;
      -webkit-font-smoothing: var(--body-font-smoothing, normal);
    }
    a {
      color: var(--link-color);
    }

    @property --scroll-progress {
      syntax: '<percentage>';
      initial-value: 100%;
      inherits: false;
    }
    @keyframes scrollProgress {
      0% {
        --scroll-progress: 0%;
      }
      100% {
        --scroll-progress: 100%;
      }
    }

    /** nav **/
    nav {
      height: 100vh;
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: sticky;
      top: 0;
      padding: calc(var(--gap) * 0.75);
      font-size: 0.875rem;
      line-height: 1.2;
      ol {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.5em;
        align-items: start;
        li {
          /**/
          max-width: 100%;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          /**/
          padding-top: 0.1ex;
          padding-bottom: 0.1ex;
          padding-left: calc(var(--gap) * 0.25);
          padding-right: calc(var(--gap) * 0.25);
          &.active {
            background: var(--body-font-color);
            outline: calc(var(--gap) * 0.15) solid var(--body-font-color);
            border-radius: 0.5ex;
            color: var(--body-background-color);
            a {
              pointer-events: none;
              color: inherit;
            }
          }
          a {
            color: var(--body-font-color);
            &:hover {
              color: var(--link-color);
            }
          }
          &:first-child a {
            font-weight: bold;
          }
        }
      }
    }

    /** aside **/
    aside {
      position: sticky;
      top: 0;
      height: 100vh;
    }
    aside a,
    aside button {
      appearance: none;
      background: var(--paper-background-color);
      color: var(--body-font-color);
      outline: 1px solid var(--horizontal-line-color);
      width: 100%;
      min-width: 25px;
      aspect-ratio: 1;
      display: grid;
      place-content: center;
      border-radius: 50%;
      cursor: pointer;
    }
    aside > div {
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      padding-left: var(--gap);
      padding-right: var(--gap);
      display: flex;
      flex-direction: column;
      row-gap: calc(var(--gap) * .5);
      width: var(--aside-width);
    }
    aside > div + div {
      position: relative;
    }
    aside > div + div::before {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate3d(-50%, 0, 0);
      content: '';
      display: block;
      width: calc(var(--gap) * 2);
      height: 1px;
      background: var(--horizontal-line-color);
      opacity: 0.5;
    }
    aside .colors button {
      &::before {
        content: var(--checkmark);
        font-size: .7em;
      }
      @media (prefers-color-scheme:light) {
        &.checked\:light {
          --checkmark: '✔';
        }
      }
      @media (prefers-color-scheme:dark) {
        &.checked\:dark {
          --checkmark: '✔';
        }
      }
    }
    aside a.close {
      position: relative;
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::before,
      &::after {
        content: '';
        display: block;
        width: 50%;
        height: 1px;
        transform: translate3d(-50%, -50%, 0) rotateZ(var(--rotate, 45deg));
        position: absolute;
        top: 50%;
        left: 50%;
        background: currentColor;
      }
      &::after {
        --rotate: -45deg;
      }

      outline: 0;
      background: radial-gradient(closest-side, var(--paper-background-color) 79%, transparent 80% 100%), conic-gradient(var(--link-color) var(--scroll-progress, 0%), var(--horizontal-line-color) 0);
      animation: scrollProgress auto linear;
      animation-timeline: scroll();
    }
    aside button.refresh {
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::after {
        content: '↻';
        font-size: 1rem;
        position: relative;
        top: -1px;
      }
    }
    aside .paper-size button {
      border-radius: 0.75ex;
      outline-width: 0;
      &.selected {
        font-weight: bold;
      }
    }
    aside button.zen {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: 'ℤ';
      }
    }
    aside button.names-editor {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: 'ℕ';
      }
    }

    /** main **/
    main {
      /**
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      /**/
      display: flex;
      background: var(--paper-background-color);
      padding: 1rem 3rem;
      outline: 1px solid var(--paper-outline-color, transparent);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color, transparent);
      article {
        flex: 1;
        text-indent: 3ch;
        max-width: var(--paper-width, 90ex);
        margin: 0 auto;
        p:first-child {
          line-height: 1.2;
          font-size: 1.5rem;
          font-weight: bold;
        }
        hr {
          background: var(--horizontal-line-color);
        }

        ::highlight(name) {
          color: var(--link-color);
        }
      }
    }

    /** table **/
    .table {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      row-gap: var(--gap);
      column-gap: calc(var(--gap) * 2);
      padding: 0 var(--gap) var(--gap);
      background: var(--paper-background-color);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color);
      outline: 1px solid var(--paper-outline-color);
      line-height: 1.2;
      align-self: stretch;
      align-content: start;
    }
    .table .name {
      font-weight: bold;
    }
    .table .th {
      white-space: nowrap;
      padding: calc(var(--gap)/2) 0;
      position: sticky;
      top: 0;
      background: var(--paper-background-color);
    }
    .table .th::before {
      content: '';
      display: block;
      border-bottom: 1px solid var(--horizontal-line-color);
      width: calc(100% + 1ex);
      height: calc(2ex + 2px);
      box-shadow: 0 calc(1ex - 5px) 1.4ex -1ex rgba(0, 0, 0, .5);
      position: absolute;
      bottom: -1px;
      left: calc(-1ex / 2);
    }
    .table .th span {
      display: inline-block;
      position: relative;
    }
    .table .th span::after {
      position: absolute;
      bottom: calc(1ex/4);
      right: -1.8ex;
      color: var(--body-font-color);
    }
    .table .th[data-sort=asc] span::after { content: '↑'; }
    .table .th[data-sort=desc] span::after { content: '↓'; }
    .table .desc { display: block; }
    .table .delete { color: inherit; }
    .table .delete:hover { color: var(--link-color); }

    /** disable scroll when mouse is not over **/
    /**
    nav,
    main {
      height: 100%;
      overflow-y: hidden;
    }
    nav:hover,
    main:hover {
      overflow-y: auto;
    }
    /**/

    /** zen mode **/
    [data-zen=true] nav {
      opacity: 0;
      transition: opacity .15s ease-in-out;
      &:hover {
        opacity: 1;
      }
    }

    /** command palette **/
    #command-palette[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      max-height: 70%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      padding: 0.7ex;

      form {
        display: contents;

        input {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
        }
      }

      ul {
        list-style: none;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overscroll-behavior-y: contain;
        position: relative;
        margin-top: 0.7ex;
        gap: 1px;

        li {
          a {
            display: block;
            padding: 0.5ex 1.3ex;
            border-radius: 0.8ex;
            color: var(--body-font-color);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }

          &:hover,
          &.selected {
            a {
              background: var(--paper-background-color);
            }
          }

          ::highlight(match) {
            background: yellow;
          }
        }
      }
    }

    /** names editor **/
    #names-editor[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      height: 80%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      gap: 0.7ex;
      padding: 0.7ex;

      form {
        display: contents;

        textarea {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
          flex: 1;
        }

        button {
          appearance: none;
          background: transparent;
          /**
          &:hover,
          &:focus,
          &:active {
            background: var(--paper-background-color);
          }
          /**/
          color: var(--body-font-color);
          width: 100%;
          min-width: 25px;
          display: grid;
          place-content: center;
          border-radius: 0.8ex;
          cursor: pointer;
          font-size: inherit;
          line-height: 1.8;
        }
      }
    }

    .text-left { text-align: left; }
    .text-right { text-align: right; }
    .text-center { text-align: center; }
    .indent-none { text-indent: 0; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, text, app } from 'https://cdn.jsdelivr.net/npm/hyperapp/+esm';
    import { openDB } from 'https://cdn.jsdelivr.net/npm/idb/+esm';
    import { generateColor as stc } from 'https://cdn.jsdelivr.net/npm/@marko19907/string-to-color/+esm'
    import _ from 'https://cdn.jsdelivr.net/npm/lodash-es/+esm'

    class HashRouter extends EventTarget {
      parse(hash) {
        return [...(new URLSearchParams(hash)).entries()].reduce((route, [k, v]) => (route[k] = v, route), {});
      }
      get(key) {
        return new URLSearchParams(location.hash.slice(1)).get(key);
      }
      current() {
        return this.parse(location.hash.slice(1));
      }
      route(route) {
        let hash = new URLSearchParams(Object.entries(route).filter(([k, v]) => v !== '' && v != null)).toString();
        if (hash) hash = '#' + hash;
        return hash;
      }
      push(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.pushState(null, null, url);
        }
      }
      replace(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.replaceState(null, null, url);
        }
      }
    }

    let InitDbDone = (state, { db }) => [
      { ...state, db },
      (dispatch) => {
        window.db = db;
        dispatch(LoadSettings);
        dispatch(LoadProgress);
        dispatch(LoadRecentBooks);
        dispatch(LoadRecentBook);
      }
    ];
    let InitDb = (state) => [
      state,
      async (dispatch) => {
        let db = await openDB('text-reader', 23, {
          upgrade(db, oldVersion, newVersion, transaction, events) {
            console.log('upgrade db', { oldVersion, newVersion, transaction, events });
            let schemas = {
              files: {},
              fileContents: {},
              settings: {},
              progress: {},
              books: {},
              chapters: {},
              names: {},
            };
            for (let [store, keyOptions] of Object.entries(schemas)) {
              if (!db.objectStoreNames.contains(store)) {
                db.createObjectStore(store, keyOptions);
              }
            }
            //for(let store of db.objectStoreNames) {
            //  if (!(store in schemas)) {
            //    console.warn('Delete store', store);
            //    db.deleteObjectStore(store);
            //  }
            //}
          },
          blocked: console.log,
          blocking: console.log,
          terminated: console.log,
        });

        dispatch(InitDbDone, { db });
      }
    ];

    let InitTheme = (state) => [
      state,
      (dispatch) => {
        let colors = { 'color:dark': 'night', 'color:light': 'white' };
        dispatch(ApplySettings, colors);
      }
    ];

    let InitRouter = (state) => [
      state,
      (dispatch) => {
        addEventListener('hashchange', (event) => {
          let from = state.router.parse(new URL(event.oldURL).hash.slice(1));
          let to = state.router.parse(new URL(event.newURL).hash.slice(1));
          if (!to.book) {
            dispatch(ShowRecentBooks);
          } else {
            dispatch(OpenBook, { bookId: to.book, chapterId: to.chapter });
          }
        });
      }
    ];

    let InitKeyboardNavigator = (dispatch) => {
      let onKeyDown = (event) => {
        let formElements = ['INPUT', 'TEXTAREA', 'SELECT', 'OPTION'];
        if(formElements.includes(event.target.tagName)) return;

        switch(event.key) {
          case 'ArrowRight': dispatch(OpenNextChapter, +1); break;
          case 'ArrowLeft': dispatch(OpenNextChapter, -1); break;
          case 'Backspace': dispatch(ShowRecentBooks); break;
          default: break;
        }
      };
      addEventListener('keydown', onKeyDown);
      return () => removeEventListener('keydown', onKeyDown);
    };

    let InitCommandPalette = async (dispatch) => {
      onKey('Cmd+K', ToggleCommandPalette)(dispatch);
      onKey('Escape', [ToggleCommandPalette, { open: false }])(dispatch);

      await nextTick();
      let dialog = document.querySelector('#command-palette');
      onKey('ArrowUp', SelectPrevCommand, { target: dialog })(dispatch);
      onKey('ArrowDown', SelectNextCommand, { target: dialog })(dispatch);
    };

    let ToggleCommandPalette = (state, options) => {
      let open = options?.open != null ? !!options.open : !state.commandPalette.open;
      return [
        {
          ...state,
          commandPalette: {
            ...state.commandPalette,
            open,
          }
        },
        async (dispatch) => {
          if(open) {
            await nextTick();
            document.querySelector('#command-palette input').select();
            dispatch(HighlightMatches);
          }
        }
      ];
    };

    let SelectCommand = (state, index) => [
      {
        ...state,
        commandPalette: {
          ...state.commandPalette,
          selectedIndex: index,
        }
      },
      async () => {
        await nextTick();

        //scroll selected command into view
        let ul = document.querySelector('#command-palette ul');
        if (!ul) return;
        let li = ul.querySelector('li.selected');
        if (li.offsetTop < ul.scrollTop) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop });
        } else if (ul.scrollTop + ul.clientHeight < li.offsetTop + li.clientHeight) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop + li.clientHeight - ul.clientHeight });
        }
      }
    ];

    let SelectNextCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex + 1];
    let SelectPrevCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex - 1];

    let SetCommandQuery = (state, q) => ({
      ...state,
      commandPalette: {
        ...state.commandPalette,
        q: q.trim().toLowerCase(),
      },
    });

    let ExecuteSelectedCommand = state => state;
    let HighlightMatches = (state) => [
      state,
      async () => {
        await nextTick();

        let ranges = [];
        let q = state.commandPalette.q;
        document.querySelectorAll('#command-palette a').forEach(el => {
          let text = el.firstChild;
          let match = latinize(text.textContent).toLowerCase();
          if(match.includes(q)) {
            let start = match.indexOf(q);
            let end = start + q.length;
            let range = new Range();
            range.setStart(text, start);
            range.setEnd(text, end);
            ranges.push(range);
          }
        });
        let hl = new Highlight(...ranges);
        CSS.highlights.set('match', hl);
      }
    ];

    let MultipleActions = (state, actions) => [
      state,
      async (dispatch) => {
        for(let action of actions) {
          await nextTick();
          dispatch(...[].concat(action));
        }
      }
    ];

    let nextTick = async () => {
      await new Promise(resolve => requestAnimationFrame(resolve));
      await new Promise(resolve => requestAnimationFrame(resolve));
    };

    let onKey = (key, action, options) => (dispatch) => {
      let el = options?.target || window;
      let onKeyDown = (event) => {
        let opts = key.toLowerCase().split('+').reduce((opts, k) => {
          switch(k) {
            case 'ctrl':
            case 'shift':
            case 'alt':
              opts[k + 'Key'] = true;
              break;
            case 'cmd':
            case 'win':
            case 'super':
              opts.metaKey = true;
              break;
            default:
              opts.key = k;
          }
          return opts;
        }, {});
        if(event.key.toLowerCase() == opts.key.toLowerCase() && ['metaKey', 'ctrlKey', 'shiftKey', 'altKey'].every(f => Boolean(event[f]) == Boolean(opts[f]))) {
          event.preventDefault();
          dispatch(action);
        }
      };
      el.addEventListener('keydown', onKeyDown);
      return () => el.removeEventListener('keydown', onKeyDown);
    };

    let LoadSettings = (state) => [
      state,
      async (dispatch) => {
        let settings = {};
        let cursor = await state.db.transaction('settings').store.openCursor();
        while (cursor) {
          settings[cursor.key] = cursor.value;
          cursor = await cursor.continue();
        }
        dispatch(ApplySettings, settings);
      }
    ];
    let ApplySettings = (state, settings) => [
      { ...state, settings: { ...state.settings, ...settings } },
      () => {
        for (let [key, value] of Object.entries(settings)) {
          document.documentElement.dataset[key] = (value ?? '');
        }
      }
    ];
    let SaveSettings = (state, settings) => [
      state,
      async (dispatch) => {
        dispatch(ApplySettings, settings);

        let tx = state.db.transaction('settings', 'readwrite');
        await Promise.all([
          ...Object.entries(settings).map(([key, value]) => {
            document.documentElement.dataset[key] = (value || '');
            return tx.store.put(value, key);
          }),
          tx.done,
        ]);
      }
    ];

    let LoadRecentBooksDone = (state, { files }) => ({ ...state, files });
    let LoadRecentBooks = (state) => [
      state,
      async (dispatch) => {
        let files = await state.db.getAll('files');
        files.sort((a, z) => a.name.localeCompare(z.name, 'vi-VN', { sensitivity: 'accent' }));
        dispatch(LoadRecentBooksDone, { files });
      }
    ];

    let LoadProgressDone = (state, { progress }) => ({ ...state, progress });
    let LoadProgress = (state) => [state, async (dispatch) => {
      let progress = {};
      let cursor = await state.db.transaction('progress').store.openCursor();
      while (cursor) {
        progress[cursor.key] = cursor.value;
        cursor = await cursor.continue();
      }
      dispatch(LoadProgressDone, { progress });
    }];

    let LoadRecentBook = (state) => [
      state,
      (dispatch) => {
        let bookId = state.router.get('book');
        let chapterId = state.router.get('chapter');
        if (bookId) {
          dispatch(OpenBook, { bookId, chapterId })
        }
      }
    ];

    let OpenBookDone = (state, { book, chapter }) => [
      { ...state, book, chapter },
      (dispatch) => {
        if (state.book?.id == book.id)
          state.router.replace({ book: book.id, chapter: chapter.id });
        else
          state.router.push({ book: book.id, chapter: chapter.id });

        document.title = [...new Set([book.name, chapter.title])].join(' | ');

        requestAnimationFrame(() => {
          scroll(0, 0);

          //scroll bookmark into view
          let bookmark = document.querySelector('nav .active');
          let nav = document.querySelector('nav');
          let bookmarkRect = bookmark.getBoundingClientRect();
          let isOutOfView = bookmarkRect.top < 0 || nav.clientHeight < bookmarkRect.bottom;
          if (isOutOfView) bookmark.scrollIntoView({ block: 'center' });
        });
      }
    ];
    let OpenBook = (state, { bookId, chapterId, migrate = true, retry = true }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [book, chapter] = await Promise.all([
          state.db.get('books', bookId),
          state.db.get('chapters', bookId + '/' + chapterId),
        ]);
        if (!book) {
          console.info('Book not found:', { book, chapter });
          if (migrate) dispatch(RefreshBook, { bookId, onSuccess: [OpenBook, { bookId, chapterId, migrate: false, retry }] });
          return
        }
        if (!chapter) {
          console.info('Chapter not found:', { bookId, chapterId });
          if (retry) {
            chapterId = book.chapters[0].id;
            dispatch(OpenBook, { bookId, chapterId, retry: false });
          }
          return;
        }

        let chapters = [...book.chapters];
        let chapterIndex = chapters.findIndex(c => c.id == chapter.id);
        if (chapterIndex < 0) chapterIndex = 0;
        chapters[chapterIndex] = chapter;

        dispatch(LoadNames, { bookId: book.id });
        dispatch(OpenBookDone, { book, chapter });
        dispatch(ToggleCommandPalette, { open: false });
        clearTimeout(window.saveProgressTimer);
        window.saveProgressTimer = setTimeout(() => {
          dispatch(SaveProgress, { book, chapter });
        }, 10000);
      }
    ];

    let ToggleNamesEditor = (state, { open }) => ({ ...state, namesEditor: { ...state.namesEditor, open } });
    let SetNames = (state, names) => ({ ...state, namesEditor: { ...state.namesEditor, names } });
    let SaveNames = (state, { bookId, names }) => [state, async (dispatch) => {
      await state.db.put('names', names, bookId);
    }];
    let LoadNames = (state, { bookId }) => [state, async (dispatch) => {
      let names = await state.db.get('names', bookId);
      dispatch(SetNames, names);
      dispatch(HighlightNames);
    }];
    let correctNames = _.memoize((content, names) => {
      if(!names) return content;
      names = names.split('\n');
      // add short name automatically
      for(let name of names) {
        if(name.includes('->') || name.includes('→')) continue;
        name = name.split(/\s/);
        if(name.length == 3) names.push(name[1] + ' ' + name[2]);
      }
      for(let name of names) {
        name = name.trim();
        if (!name) continue;
        let from, to;
        if(name.includes('->')) {
          [from, to] = name.split('->').map(n => n.trim());
        } else if(name.includes('→')) {
          [from, to] = name.split('→').map(n => n.trim());
        } else {
          from = name;
          to = name.toLowerCase().replace(/(?<=^|[^\p{L}])./gu, c => c.toUpperCase());
        }
        if(from) {
          let fromRegex = new RegExp(`(?<=^|[^\\p{L}])${from}(?=[^\\p{L}]|$)`, 'gui');
          content = content.replaceAll(fromRegex, to);
        }
      }
      return content;
    }, (content, names) => content + names);
    let HighlightNames = (state) => [state, async () => {
      await nextTick();

      CSS.highlights.clear();

      // collect names
      let names = new Set();
      document.querySelectorAll('article p').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          let nameRegex = buildRegex([
            /{Word}(\s{Word})+/,
            /{wb}a {Word}(?!{Word})/,
            /(?<!{Word}){wb}{Word} (thúc|di|ca|tổng|lang|nô){wb}/,
            /(tiểu) {Word}(?!{wb}{Word})/,
          ], {
            'wb': /$|(?<=[^\p{L}"])|(?=[^\p{L}])/,
            'Upper': /\p{Lu}/,
            'Lower': /\p{Ll}/,
            'Word': /{wb}{Upper}{Lower}*{wb}/,
          }, 'gu');

          for(let match of el.textContent.matchAll(nameRegex)) {
            let name = match[0];
            names.add(name);
          }
        });
      });

      // create ranges;
      let ranges = {};
      document.querySelectorAll('article p').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          let nameRegex = buildRegex([
            '{wb}(' + [...names].join('|') + '){wb}',
          ], {
            'wb': /^|$|(?<=[^\p{L}])|(?=[^\p{L}])/,
          }, 'gu');

          for(let match of el.textContent.matchAll(nameRegex)) {
            let range = new Range();
            range.setStart(el, match.index);
            range.setEnd(el, match.index + match[0].length);
            let nameId = slug(match[0]);
            if(!ranges[nameId]) ranges[nameId] = [];
            ranges[nameId].push(range);
          }
        });
      });

      // merge sub ranges
      let nameIds = Object.keys(ranges).sort((a, z) => z.length - a.length);
      for(let nameId in ranges) {
        let fullNameId = nameIds.find(id => id.endsWith('-' + nameId));
        if(fullNameId) {
          ranges[fullNameId].push(...ranges[nameId]);
          delete ranges[nameId];
        }
      }

      for(let nameId in ranges) {
        let color = stc(nameId);
        CSS.highlights.set(nameId, new Highlight(...ranges[nameId]));
        let styleEl = document.head.querySelector(`style[name="hl-${nameId}"]`);
        if(!styleEl) {
          styleEl = document.createElement('style');
          styleEl.setAttribute('name', `hl-${nameId}`);
          styleEl.textContent = `article ::highlight(${nameId}) { color: ${color}; }`;
          document.head.appendChild(styleEl);
        }
      }
    }];

    let OpenNextChapter = (state, indexDelta = 1) => [
      state,
      (dispatch) => {
        let chapterIndex = state.book.chapters.findIndex(c => c.id == state.chapter.id);
        let nextChapter = state.book.chapters[chapterIndex + indexDelta];
        if (nextChapter) {
          dispatch(OpenBook, { bookId: state.book.id, chapterId: nextChapter.id });
        }
      }
    ];

    let SaveProgressDone = (state, { book, progress }) => ({ ...state, progress: { ...state.progress, [book.id]: progress } });
    let SaveProgress = (state, { book, chapter }) => {
      return [
        state,
        async (dispatch) => {
          let progress = (await state.db.get('progress', book.id) || {});
          progress.chapterId = chapter.id;
          progress.chapterIndex = book.chapters.findIndex(c => c.id == chapter.id) + (book.chapters[0].id ? 1 : 0);
          progress.chapterCount = (book.chapters[0].id ? book.chapters.length : book.chapters.length - 1);
          progress.updatedAt = new Date().toISOString();
          await state.db.put('progress', progress, book.id);
          dispatch(SaveProgressDone, { book, progress });
        }
      ];
    };

    let InitDropzone = (state) => [
      state,
      (dispatch) => {
        addEventListener('dragenter', event => { event.preventDefault(); });
        addEventListener('dragover', event => { event.preventDefault(); });
        addEventListener('drop', event => {
          event.preventDefault();
          let files = [...event.dataTransfer.files].filter(file => file.type == 'text/plain');
          dispatch(StoreFiles, { files });
        });
      }
    ];

    let StoreFilesDone = (state, { files }) => [
      state,
      async (dispatch) => {
        //refresh recent books in state
        dispatch(LoadRecentBooks);

        let filesOpenInNewTab = files;
        let fileOpenInCurrentTab = null;
        if(state.book) {
          //if this book is already open, open other files in new tabs
          fileOpenInCurrentTab = files.find(file => (Book(file).id == state.book.id));
          filesOpenInNewTab = files.filter(file => (file != fileOpenInCurrentTab));
        } else {
          //if no book is open, open the first file in current tab, other files in new tabs
          [fileOpenInCurrentTab, ...filesOpenInNewTab] = files;
        }

        if(fileOpenInCurrentTab) {
          let book = Book(fileOpenInCurrentTab);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          state.router.push({ book: book.id, chapterId });
          dispatch(OpenBook, { bookId: book.id, chapterId });
        }
        for(let { file } of filesOpenInNewTab) {
          let book = Book(file);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          window.open(`#book=${book.id}&chapter=${chapterId}`, '_blank');
        }
      }
    ];
    let StoreFiles = (state, { files: localFiles, fileContents }) => [
      state,
      async (dispatch) =>  {
        let readFile = (localFile) => new Promise(resolve => {
          let reader = new FileReader();
          reader.addEventListener('load', event => {
            let file = {
              name: localFile.name,
              size: localFile.size,
            };
            let fileContent = event.target.result;
            resolve({ file, fileContent });
          });
          reader.readAsText(localFile);
        });

        let files = [];
        for (let localFile of localFiles) {
          files.push(await readFile(localFile));
        }

        dispatch(StoreBooks, { files, onSuccess: [StoreFilesDone, { files }] });
        /**
        for (let i = 0; i < localFiles.length; i++) {
          let reader = new FileReader();
          reader.addEventListener('load', async event => {
            fileContents[i] = event.target.result;
            files[i] = {
              name: localFiles[i].name,
              size: localFiles[i].size,
            };

            let book = Book(files[i]);
            let existingFile = await state.db.get('files', book.id);
            if (existingFile?.size != files[i].size) {
              book = Book(files[i], fileContents[i]);
              dispatch(SaveProgress, { book, chapter: book.chapters[0] });
              updated[i] = true;
            }

            let tx = state.db.transaction(['files', 'fileContents'], 'readwrite');
            await Promise.all([
              tx.objectStore('files').put(files[i], book.id),
              tx.objectStore('fileContents').put(fileContents[i], book.id),
              tx.done,
            ]);

            dispatch(StoreBook, { bookId: book.id });
            storedCount++;

            if (storedCount == localFiles.length) {

            }
          });
          reader.readAsText(localFiles[i]);
        }
        /**/
      },
    ];

    let StoreBooks = (state, { files, onSuccess }) => [
      state,
      async (dispatch) => {
        let chapterKeys = await state.db.getAllKeys('chapters');

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          ...files.flatMap(({ file, fileContent }) => {
            let book = Book(file, fileContent);
            return [
              tx.objectStore('files').put(file, book.id),
              tx.objectStore('fileContents').put(fileContent, book.id),
              tx.objectStore('books').put(book.toJSON(), book.id),
              ...chapterKeys.filter(k => k.startsWith(book.id + '/')).map(k => tx.objectStore('chapters').delete(k)),
              ...book.chapters.map(c => tx.objectStore('chapters').put(c.toJSON(), book.id + '/' + c.id)),
            ];
          }),
          tx.done,
        ]);

        if (onSuccess) dispatch(...onSuccess);
      }
    ];

    let RefreshBook = (state, { bookId, onSuccess }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [file, fileContent] = await Promise.all([
          state.db.get('files', bookId),
          state.db.get('fileContents', bookId),
        ]);
        if (!file || !fileContent) {
          console.info('File not found:', { bookId, file, fileContent });
          return;
        }

        if (!onSuccess) onSuccess = [OpenBook, { bookId, chapterId: state.chapter.id }];

        dispatch(StoreBooks, {
          files: [{ file, fileContent }],
          onSuccess,
        });
      }
    ];

    let DeleteBookDone = (state, { bookId }) => ({ ...state, files: state.files.filter(file => Book(file).id != bookId) });
    let DeleteBook = (state, { bookId }) => [
      state,
      async (dispatch) => {
        let chapterKeys = (await state.db.getAllKeys('chapters')).filter(k => k.startsWith(bookId + '/'));

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          tx.objectStore('files').delete(bookId),
          tx.objectStore('fileContents').delete(bookId),
          tx.objectStore('books').delete(bookId),
          ...chapterKeys.map(k => tx.objectStore('chapters').delete(k)),
          tx.done,
        ]);

        dispatch(DeleteBookDone, { bookId });
      }
    ];

    let ShowRecentBooks = (state) => {
      if (!state.book) return state;
      return [
        { ...state, book: null, chapter: null },
        (dispatch) => {
          clearTimeout(window.saveProgressTimer);
          state.router.push({});
          document.title = 'Text Reader';
          requestAnimationFrame(() => {
            scroll(0, 0);
          });
          dispatch(ToggleCommandPalette, { open: false });
        }
      ];
    };

    let sizeFormatter = new Intl.NumberFormat(undefined, { notation: 'compact', style: 'unit', unit: 'byte', unitDisplay: 'narrow' });
    let formatSize = sizeFormatter.format.bind(sizeFormatter);

    let dateFormatter = new Intl.RelativeTimeFormat();
    let formatDate = (iso) => {
      if(!iso) return;
      let diff = (Date.now () - new Date(iso)) / 1000;
      for (let [unit, seconds] of Object.entries({
        months: 30 * 24 * 60 * 60,
        days: 24 * 60 * 60,
        hours: 60 * 60,
        minutes: 60,
        seconds: 0,
      })) {
        if (diff >= seconds) return dateFormatter.format(-Math.round(diff / (seconds || 1)), unit);
      }
    };

    app({
      init: [
        {
          router: new HashRouter(),
          db: null,
          files: [],
          book: null,
          chapter: null,
          progress: {},
          settings: {
            sort: {
              field: 'updatedAt',
              direction: 'desc'
            }
          },
          commandPalette: {
            open: false,
            q: '',
            selectedIndex: 0,
          },
          namesEditor: {
            open: false,
            names: '',
            form: {
              names: '',
            },
          },
        },
        (dispatch) => {
          dispatch(InitRouter);
          dispatch(InitTheme);
          dispatch(InitDb);
          dispatch(InitDropzone);
        }
      ],
      dispatch: (dispatch) => {
        return (action, payload) => {
          if (!action) return;

          if (typeof action == 'function' && action.name.match(/^[A-Z]/)) {
            let log = [action.name];
            if (payload !== undefined) log.push(payload);
            console.warn(...log);
          }

          dispatch(action, payload);
        };
      },
      subscriptions: (state) => [
        [InitKeyboardNavigator],
        [InitCommandPalette],
      ],
      node: document.body,
      view: ({ router, files, book, chapter, progress, settings, commandPalette, namesEditor }) => {
        let fixNames = text => correctNames(text, namesEditor.names);
        let cachedCommands = window.cachedCommands = (window.cachedCommands || new Map());
        let commands = [], selectedCommand, commandKey;
        if(!book) {
          commandKey = '';
          if(!cachedCommands.has(commandKey)) {
            cachedCommands.set(commandKey, files.map(f => Book(f))
              .map((book, index) => {
                let { chapterId } = (progress[book.id] || {});
                return {
                  label: book.name,
                  action: OpenBook,
                  payload: { bookId: book.id, chapterId },
                  term: latinize(book.name).toLowerCase(),
                };
              })
            );
          }
        } else {
          commandKey = book.id;
          if(!cachedCommands.has(commandKey)) {
            cachedCommands.set(commandKey, book.chapters
              .map(chapter => ({
                label: fixNames(chapter.title),
                action: OpenBook,
                payload: { bookId: book.id, chapterId: chapter.id },
                term: latinize(chapter.title).toLowerCase(),
              }))
            );
          }
        }
        commands = cachedCommands.get(commandKey).filter(cmd => cmd.term.includes(commandPalette.q));
        selectedCommand = commands[(commandPalette.selectedIndex + commands.length) % commands.length];
        return (
          h('body', {}, [
            h('nav', {}, [
              (book?.chapters?.length > 0) && (
                h('ol', { start: 0 }, [
                  ...book.chapters.map(c => (
                    h('li', { class: { active: c.id == chapter.id } }, [
                      h('a', {
                        href: router.route({ book: book.id, chapter: c.id }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId: c.id }];
                        },
                        title: fixNames(c.title),
                      }, [
                        text(fixNames(c.title))
                      ])
                    ])
                  ))
                ])
              )
            ]),
            !book && (
              h('div', { class: 'table' }, [
                h('a', {
                  class: 'th text-left',
                  'data-sort': settings.sort.field == 'name' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'name', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('File'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'size' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'size', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Size'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'chapterCount' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'chapterCount', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Chapters'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'updatedAt' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'updatedAt', direction = 'desc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Date'))),
                h('span', { class: 'th' }, h('span', {})),
                ...files.sort((a, z) => {
                  let { field, direction } = settings.sort;
                  let A = Book(a), Z = Book(z);
                  let result;
                  if (field == 'name') {
                    result = A.name.localeCompare(Z.name, 'vi-VN', { sensitivity: 'accent' });
                  } else if (field == 'size') {
                    result = a[field] - z[field];
                  } else if (field == 'updatedAt') {
                    a = new Date(progress[A.id]?.[field] || 0);
                    z = new Date(progress[Z.id]?.[field] || 0);
                    result = a - z;
                  } else if (field == 'chapterCount') {
                    result = (progress[A.id]?.[field] || 1) - (progress[Z.id]?.[field] || 1);
                  }
                  if ((direction == 'desc') && (result != 0)) result = -result;
                  return result;
                }).flatMap(file => {
                  let book = Book(file);
                  let { chapterId, chapterIndex, chapterCount, updatedAt } = (progress[book.id] || {});
                  return [
                    h('div', { class: 'td' }, [
                      h('a', {
                        class: 'name',
                        href: router.route({ book: book.id, chapter: chapterId }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId }];
                        }
                      }, [
                        text(book.name)
                      ]),
                      book.description && (
                        h('small', { class: 'desc' }, text(book.description))
                      )
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatSize(file.size)))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(!chapterCount ? '-' : `${chapterIndex}/${chapterCount}`))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatDate(updatedAt) || '-'))
                    ]),
                    h('div', { class: 'td' }, [
                      h('a', { class: 'delete', onclick: [DeleteBook, { bookId: book.id }] }, [
                        h('small', {}, text('delete'))
                      ])
                    ])
                  ]
                })
              ])
            ),
            chapter && (
              h('main', {}, [
                h('article', {}, [
                  ...fixNames(chapter.content).split(/\n|<\/?\w+>/gi).map(line => {
                    if (/^[-]+$/.test(line)) return h('hr', {});
                    if (/^[^\p{L}\p{N}"]+$/u.test(line)) return h('p', { class: 'text-center indent-none' }, text(line));
                    let content = [], m;
                    while ((m = /https?:\/\/\S+/.exec(line))) {
                      if (m.index > 0) content.push(text(line.slice(0, m.index)));
                      content.push(h('a', { href: m[0], target: '_blank' }, [text(m[0])]));
                      line = line.slice(m.index + m[0].length);
                    }
                    if (line) content.push(text(line));
                    // if (/^"/.test(line)) return h('p', {}, h('em', {}, text(line)));
                    return h('p', {}, content);
                  })
                ])
              ])
            ),
            h('aside', { class: 'settings' }, [
              chapter && (
                h('div', {}, [
                  h('a', {
                    class: 'close',
                    href: router.route({}),
                    onclick: (_, event) => {
                      event.preventDefault();
                      return [ShowRecentBooks];
                    },
                    title: 'Back to bookshelf',
                  })
                ])
              ),
              h('div', { class: 'colors' }, ['white', 'sepia', 'gray', 'night', 'rose-pine', 'rose-pine-moon', 'rose-pine-dawn'].map(color => (
                h('button', {
                  class: [color, { 'checked:light': settings['color:light'] == color, 'checked:dark': settings['color:dark'] == color }],
                  onclick: () => [SaveSettings, { [`color:${getColorScheme()}`]: color }],
                  title: `Theme: ${color}`,
                })
              ))),
              h('div', { class: 'paper-size' }, ['sm', 'md', 'lg', 'xl'].map(size => (
                h('button', {
                  class: ['size', size, { selected: settings.paperSize == size }],
                  onclick: [SaveSettings, { paperSize: size }],
                  title: `Page size: ${size}`,
                }, text(size))
              ))),
              chapter && (
                h('div', {}, [
                  h('button', {
                    class: 'refresh',
                    onclick: [RefreshBook, { bookId: book.id, chapterId: chapter.id }],
                    title: 'Refresh book',
                  }),
                  h('button', {
                    class: 'zen',
                    onclick: [SaveSettings, { zen: !settings.zen }],
                    title: 'Toggle Zen Mode',
                  }),
                  h('button', {
                    class: 'names-editor',
                    onclick: [ToggleNamesEditor, { open: true }],
                    title: 'Edit names',
                  }),
                ])
              )
            ]),
            h('dialog', { id: 'command-palette', open: commandPalette.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [selectedCommand.action, selectedCommand.payload],
                    [ToggleCommandPalette, { open: false }],
                  ]];
                }
              }, [
                h('input', {
                  oninput: (_, event) => [MultipleActions, [
                    [SetCommandQuery, event.target.value],
                    [SelectCommand, 0],
                    [HighlightMatches],
                  ]],
                }),
                h('input', { type: 'submit', hidden: true }),
              ]),
              commands.length > 0 && h('ul', {}, [
                ...commands.map((command, index) => (
                  h('li', {
                    class: { selected: command == selectedCommand }
                  },
                    h('a', {
                      href: router.route({ book: command.payload.bookId, chapter: command.payload.chapterId }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [MultipleActions, [
                          [SelectCommand, index],
                          [command.action, command.payload],
                          [ToggleCommandPalette, { open: false }],
                        ]]
                      },
                      title: command.label,
                    },[
                      text(command.label),
                    ])
                  )
                ))
              ])
            ]),
            h('dialog', { id: 'names-editor', open: namesEditor.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [ToggleNamesEditor, { open: false }],
                    [SaveNames, { bookId: book.id, names: namesEditor.names }],
                    [HighlightNames],
                  ]];
                }
              }, [
                h('textarea', {
                  value: namesEditor.names,
                  oninput: (_, event) => [SetNames, event.target.value],
                  onkeydown: (_, event) => {
                    if (event.key == 'Escape') {
                      return [ToggleNamesEditor, { open: false }];
                    } else if (event.key == 'Enter' && event.metaKey) {
                      return [MultipleActions, [
                        [ToggleNamesEditor, { open: false }],
                        [SaveNames, { bookId: book.id, names: namesEditor.names }],
                        [HighlightNames],
                      ]];
                    }
                  },
                }),
                h('button', { type: 'submit' }, [text('Save')]),
              ])
            ])
          ])
        );
      }
    });

    function Book(file, fileContent, chapters) {
      let id, name, description;
      if (file?.name) {
        name = /(?<name>^[^(]*).*?\.txt/.exec(file.name.normalize()).groups.name.trim();
        description = /(?<description>\(.*)\.txt/.exec(file?.name.normalize())?.groups?.description?.trim();
        id = slug(name);
      }
      if (fileContent) {
        fileContent = normalizeFileContent(fileContent);
        // fileContent = titleizeHumanName(fileContent);
        chapters = extractChapters(name, fileContent, { name });
      }
      return {
        id,
        name,
        description,
        chapters,
        toJSON() {
          return {
            id,
            name,
            description,
            chapters: chapters.map(c => {
              c = c.toJSON();
              delete c.content;
              return c;
            }),
          }
        }
      };
    }

    function normalizeFileContent(text) {
      text = text.normalize();
      text = text.replace(/[^.\n]*(Sắc Hiện Viện|Sắc Hiệp Viện|Sachiepvien\.net)[^.\n]*\.?/g, '');
      text = text.replace(/[\r\n]+/g, '\n');
      text = text.replace(/(.+)/g, (s) => s.trim());
      text = text.replace(/^'([^']+)'$/gm, '"$1"');
      text = text.replace(/(\d)\s*(\.)\s*(\d)/gm, '$1$2$3');
      text = text.replace(/\s+([.,;:?!\]】)])/gm, '$1');
      text = text.replace(/([([【])\s+/gm, '$1');
      text = text.replace(/([:—]{2,})/gm, c => c.slice(0, 1));
      text = text.replace(/(:)[^\s\w]+\s*/gm, '$1 ');
      text = text.replace(/^\s*"\s+|\s+"\s*$/gm, '"');
      return text;
    }

    function Chapter(_, { chapters, filename, text }) {
      return {
        _,
        get title() {
          let title, titleBook, titleChap, phienNgoai, half;
          if (_.bookType) {
            if (_.bookNum) titleBook = this.bookType + ' ' + _.bookNum;
            else if (_.bookText) titleBook = this.bookType + ' ' + _.bookText;
          }
          if (/phiên ngoại/iu.test(_.text) && !/phiên ngoại/iu.test(_.title)) phienNgoai = 'Phiên ngoại';
          if (this.chapter != null) titleChap = this.chapType + ' ' + this.chapter;
          if (this.half && !_.title?.includes('(' + this.half + ')')) half = '(' + this.half + ')';
          title = [titleBook, phienNgoai, titleChap].filter(Boolean).join(' ');
          title = [title, _.title].filter(Boolean).join(': ');
          title = [title, half].filter(Boolean).join(' ');
          if (!title) title = this.chapType + ' ' + (this.i + 1);
          return title;
        },
        get i() {
          return chapters.indexOf(this);
        },
        get startIndex() {
          // return text.lastIndexOf('\n', _.index);
          return _.index;
        },
        get endIndex() {
          if (this.i == chapters.length-1) return text.length;
          return chapters[this.i + 1].startIndex;
        },
        get id() {
          return slug(this.title) + '-' + this.i;
        },
        get content() {
          return text.slice(this.startIndex, this.endIndex).trim();
        },
        get chapter() {
          return _.chapNum || _.chapText;
        },
        get chapNo() {
          if (this.chapter) return Number(this.chapter)
        },
        get chapType() {
          return _.chapType || 'Chương'
        },
        get length() {
          return this.endIndex - this.startIndex;
        },
        get half() {
          if (_.half) return _.half.toLowerCase();
          let m = /(?<=\()(thượng|trung|hạ)(?=\))/iu.exec(_.title);
          if (m) return m[0].toLowerCase();
        },
        get bookType() {
          if (_.bookType) return _.bookType.toLowerCase().replace(/^./, c => c.toUpperCase());
        },
        get bookNo() {
          if (_.bookNum) return Number(_.bookNum);
          if (_.bookText) return Number(_.bookText);
        },
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            content: this.content,
          }
        }
      };
    }

    function extractChapters(filename, text, { name }) {
      let NUMERIC = '(\\d{1,4}(\\.\\d{1,2})*)';
      let NUMERIC_DECIMAL = '(\\d{1,4}(\\.\\d{1,2})+)';
      let NUMERIC_WORDS = '(mười( (một|hai|ba|bốn|lăm|sáu|bảy|tám|chín))?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( (mốt|hai|ba|bốn|lăm|sáu|bảy|tám|chín))?|một|hai|ba|bốn|năm|sáu|bảy|tám|chín)|(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập)';
      let patterns = [
        /*
        【xanh biếc lữ du tiên】 bộ 2 tự chương
        【xanh biếc lữ du tiên】 bộ 2 thứ 01 chương
        Xanh Biếc lữ du tiên bộ 2 thứ 09 chương
        【xanh biếc lữ du tiên bộ 2】 thứ 10 chương Đông hải tiên các (1)
        Xanh Biếc lữ du tiên bộ 2 thứ 13 chương Nữ Đế dâm tâm
        【xanh biếc lữ du tiên】 Chương 8:
        【Chương 8: Tông môn dâm loạn (nhất)】
        【xanh biếc lữ du tiên】 Chương 6:
        【Chương 6: Hoàng thành long ảnh】
        Thứ 02 chương: Hong Kong
        Thứ 1 chương đại nghịch bất đạo ái đồ, nhưng lại hy vọng đem sư tôn dạy dỗ vì song tu chuyên dụng ấu thê!
        Thứ 10 chương, võ diễm hòa không rõ thân phận nam nhân thông đồng cùng với trần san cùng ca ca trần vừa loạn luân địt bi chuyện xưa
        【mẹ thành gia bên trong bảo mẫu con dâu】(15) hoàn
        Nhị, thay đổi
        【bạn gái đệ đệ】3
        "Bạn gái đệ đệ" 11
        Thượng (2)
        Chính Văn Chương 07: Chỉnh quân
        Nhất, lời dẫn tưởng nói ngắn gọn, nhưng không biết từ đâu nói lên.
        Thứ 34 chương mẫu thượng công lược (3.11) An Nặc tiến bệnh viện
        — Chương 2: (dịch nóng thể)—
        2020 năm tháng 1 6 ngày
        Hạ bộ — chị em yêu nhau (lục hi hòa lục nếu)
        【mẹ con】(nhị -- yêu nói hết)
        (nhị -- yêu nói hết)
        ch. 1
        Hồi 1: Ngây thơ diện mạo Khuynh Thành vận giao mui xe thị lão Ông phủ ấu tử từ huệ thục hiền Hongkong
        Thứ 41-48 chương
        */
        //Chương 23:
        //Phiên ngoại Chương 18:
        '^(Phiên Ngoại )?CHAP_TYPE CHAP_NUM:$',
        //Chương 1: Tân niên đặc biệt thiên (thượng)
        //Phiên Ngoại Chương 8: Treo đầu dê bán thịt chó
        //...đã ngủ say. Chương 59: mẹ phát hiện chân tướng
        //Hồi 2: · phẫn vũ nữ khinh thân dụ địch tù, nhu vú to thát tử loạn tâm trí
        '(^|(?<=\\W ))(Phiên Ngoại )?CHAP_TYPE CHAP_NUM([^\\p{L}\\p{N}]+TITLE)?$',
        //Ngũ
        //Hai mươi mốt
        '^CHAP_TEXT$',
        // (1)
        '^\\(CHAP_NUM\\)$',
        //8.1
        '^CHAP_NUM$',
        // (tứ)
        // (mười một)
        '^\\(CHAP_TEXT\\)$',
        //Thứ 7 chương mẫu thượng công lược (1.7) tiểu ma nữ phục vụ
        // '^Thứ BOOK_NUM chương ' + name + ' \\(CHAP_NUM\\)([: ]TITLE)?',
        //Thứ 31 chương
        //Tập thứ nhất thứ 01 chương thất đọa vách núi đen
        '^(BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT) )?Thứ CHAP_NUM CHAP_TYPE([: ]TITLE)?',
        //[thứ 1 chương]
        '^\\[thứ CHAP_NUM CHAP_TYPE\\]',
        //Bảy năm vợ chồng gần ba năm cùng hai cái đơn nam đệ tử chuyện xưa (5)
        '^' + name + ' \\(CHAP_NUM\\)',
        //2019-7-19 mười lăm
        '^DATE CHAP_TEXT',
        //Mười hai, nửa năm sau cuộc sống vẫn đang tiếp tục. Phố xá như trước thái bình.
        '^CHAP_TEXT[,] TITLE$',
        //Quyển thứ hai Chương 11: Mỹ mẫu cầu xin
        //Tập 6 Chương 110: Nhân thay mới trang
        '^BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT) CHAP_TYPE CHAP_NUM: TITLE',
        //Lời dẫn
        '^(?<title>CHAP_TYPE (cuối|kết)|tự chương|Lời dẫn)$',
        //(Chương 20: hèn chó diễn phượng (che giấu thiên 3)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE',
        //Phiên Ngoại hai mươi lăm chương
        '^(Phiên Ngoại )CHAP_TEXT CHAP_TYPE',
        //【 đọa phụ 】 Chương 2:: Khuất nhục phu nhân
        '^【NAME】 CHAP_TYPE CHAP_NUM: TITLE',
        //【xanh biếc lữ du tiên】 bộ 2 thứ 08 chương
        '^【NAME】 bộ BOOK_NUM thứ CHAP_NUM CHAP_TYPE',
        //Xanh biếc lữ du tiên bộ 2 Chương 8: Sơ ngộ bích du
        '^NAME bộ BOOK_NUM CHAP_TYPE CHAP_NUM: TITLE',
        //【bạn gái đệ đệ】9
        '^【NAME】CHAP_NUM([: ]TITLE)?',
        //【các huynh đệ loạn luân thịnh yến】(tam)
        //【không chỉ tình yêu】(1)
        //【không chỉ tình yêu】(18) hoàn
        '^【NAME】\\((CHAP_TEXT|CHAP_NUM)\\)( TITLE)?',
        //【của ta giang hồ】(thứ 2 chương)
        '^【NAME】\\(thứ CHAP_NUM CHAP_TYPE\\)',
        //【không chỉ tình yêu】(phiên ngoại) cảnh phỉ mẹ con kích tình thượng kính
        '^【NAME】(phiên ngoại) TITLE',
        //【phiên ngoại thiên chi Diệp Minh Hi tự bạch】(1)
        '【(?=.*?phiên ngoại)(?<title>.*?)】\\(CHAP_NUM\\)',
        //【không chỉ tình yêu】(phiên ngoại) cảnh phỉ mẹ con kích tình thượng kính
        '^【NAME】\\(phiên ngoại\\) TITLE',
        //Người nhà quần áo Chương 1: Mẹ dị thường
        '^NAME CHAP_TYPE CHAP_NUM: TITLE$',
        //Nón xanh mặc ta mang (nhất) kinh vi thiên nhân
        '^NAME \\(CHAP_TEXT\\) TITLE',
        //(bản cũ) dâm loạn gia đình thứ 01 chương: Sau khi tan lớp ba ba âu yếm
        'NAME thứ CHAP_NUM CHAP_TYPE: TITLE',
        //(16) A Kiện nói: Nàng... Nàng là ta... Muội muội
        '^\\(CHAP_NUM\\) TITLE',
        //..."Ân, ta đều nghe ngươi!" (13)
        '(?<=\\W) \\(CHAP_NUM\\)$',
        //(14) nghiêm hạo tại sofa phía trên thích không thể tự thoát ra được, nhất tinh mặc xong đồ ngủ, sau đó tiếp lấy đem nghiêm hạo ôm đến chân của mình phía trên, nhẹ nhàng âu yếm.
        '\\(CHAP_NUM\\)',
        //"2" hào môn bí mật
        '^"\\s*CHAP_NUM\\s*"( TITLE)?',
        //"13 chương kết"
        '^"CHAP_NUM TITLE"$',
        //Tập thứ hai thứ 36 chương con tin uy hiếp
        '^Tập thứ BOOK_TEXT thứ CHAP_NUM CHAP_TYPE TITLE$',
        //22)
        '^CHAP_NUM\\)$',
        //Tự mẫu một ngày (hạ)
        '^(?<!.*CHAP_TYPE.*TITLE) \\(HALF\\)$',
        //Thứ 1002 chương lữ mộng đẹp cảnh nhã nhàn bá mẫu (nhị)
        '^Thứ CHAP_NUM CHAP_TYPE TITLE',
        //Đệ nhất bộ tứ đại mỹ nữ chi đẹp nhất thị trưởng dương ngưng băng (thượng)
        '^Đệ (BOOK_NUM|BOOK_TEXT) BOOK_TYPE TITLE \\(HALF\\)',
        //Bộ 2 tứ đại mỹ nữ chi kim bài chủ trì dương ninh làm (hạ)
        '^BOOK_TYPE BOOK_NUM TITLE \\(HALF\\)',
        //(Chương 20: hèn chó diễn phượng (che giấu thiên 2)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE HALF\\)',
        //Đệ 1 chương: (Mẹ Mamako)
        //Đệ 8 chương, đẩy ngược phản bị địt.
        '^(Đệ|thứ) CHAP_NUM CHAP_TYPE[,:] TITLE',
        //Quyển thứ hai thiết giáp phong vân
        '^BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT) BOOK_TITLE',
        //Thứ 4 cuốn đế đô bi ca
        '^Thứ BOOK_NUM BOOK_TYPE BOOK_TITLE',
        //1.1 nhân vật chính kêu mũ
        '^CHAP_NUM_DECIMAL TITLE$',
        //(4.25)G con mẹ nó du học sinh
        '^\\(CHAP_NUM\\) ?TITLE$',
        //Chương mười:
        '^CHAP_TYPE CHAP_TEXT:$',
      ];
      let matches = [];
      for (let pattern of patterns) {
        let source = pattern
          .replace('NAME', '(?<name>' + [...new Set([name, name.replace('hệ liệt', '').trim()])].join('|') + ')')
          .replace('DATE', '\\d+-\\d+-\\d+')
          .replace('SEP', '[ :]')
          .replace('BOOK_TITLE', '(?<bookTitle>.+)')
          .replace('TITLE', '(?<title>.+)')
          .replace('BOOK_TYPE', '(?<bookType>(quyển|tập|bộ|cuốn))')
          .replace('CHAP_TYPE', '(?<chapType>(chương|hồi))')
          .replace('HALF', `(?<=\\()(?<half>(thượng|trung|hạ|${NUMERIC_WORDS}))(?=\\))`)
          .replace('CHAP_NUM_DECIMAL', `(?<chapNum>${NUMERIC_DECIMAL})`)
          .replace('CHAP_NUM', `(?<chapNum>${NUMERIC})`)
          .replace('CHAP_TEXT', `(?<chapText>${NUMERIC_WORDS})`)
          .replace('BOOK_NUM', `(?<bookNum>${NUMERIC})`)
          .replace('BOOK_TEXT', `(?<bookText>${NUMERIC_WORDS})`);
        let regex = new RegExp(source, 'gimu');
        let result = [...text.matchAll(regex)];
        console.debug({ pattern, regex, result });
        matches.push(...result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] })));
      }
      matches.forEach(m => {
        for (let f of ['chapText', 'bookText']) {
          if (m[f]) {
            let c = m[f].toLowerCase();
            let vn = {
              'mươi$': 0,
              'mươi': '',
              '(mười|thập)(?=.+)|m[ộố]t|nhất': 1,
              'hai|nhị': 2,
              'ba|tam': 3,
              'bốn|tứ': 4,
              '[nl]ăm|ngũ': 5,
              'sáu|lục': 6,
              'bảy|thất': 7,
              'tám|bát': 8,
              'chín|cửu': 9,
              'mười|thập': 10,
            };
            Object.entries(vn).forEach(([w, i]) => {
              w = new RegExp(w, 'gimu');
              c = c.replace(w, i);
            });
            c = c.replace(/\s/g, '');
            m[f] = Number.parseInt(c);
          }
        }
        for (let f of ['chapNum', 'bookNum']) {
          if (m[f]) {
            m[f] = m[f].split('.').map(Number).join('.');
          }
        }
      });
      matches.sort((a, z) => a.index - z.index);
      debug({ matches });

      if (matches.length < 2) {
        let paragraphsPerChapter = 60;
        let pattern = '(.*\n){1,' + paragraphsPerChapter + '}';
        let regex = new RegExp(pattern, 'gimu')
        let result = [...text.matchAll(regex)];
        matches = result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] }));
      }

      let chapters = [];
      matches.forEach(m => {
        chapters.push(Chapter(m, { chapters, filename, text }));
      });

      dedupeChapters(chapters);
      mergeShortChapters(chapters, 200);
      cleanupChapters(chapters);
      addPrologue(chapters, filename, text);

      return chapters;
    }

    function mergeBehind(chapters, i, reason) {
      // chapters[i].endIndex = chapters[i+1].endIndex;
      let [ch, ci] = [chapters[i-1], chapters[i]];
      let c;
      if (!ch.chapNo && ci.chapNo) c = ci;
      else if (ch.chapNo == ci.chapNo) {
        if (!ch._.title && ci._.title) c = ci;
      }
      console.log('merge', [ch._.text, ci._.text], 'because', reason, c == ci, { ch, ci });
      if (c) {
        Object.assign(ch._, {
          title: c._.title,
          chapNum: c._.chapNum,
          chapText: c._.chapText,
          bookNum: c._.bookNum,
          bookText: c._.bookText,
          bookType: c._.bookType,
          half: c._.half,
        });
      }
      chapters.splice(i, 1);
    }

    function dedupeChapters(chapters) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let h = i-1;
        let [ch, ci] = [chapters[h], chapters[i]];
        let shouldMerge = false;
        if (ch.startIndex == ci.startIndex) shouldMerge = true;
        if (ch.chapNo != null && ch.chapNo == ci.chapNo && ch.half == ci.half) shouldMerge = true;
        if (shouldMerge) {
          // console.log('dedupe', [ch.title, ci.title]);
          mergeBehind(chapters, i, 'dedupe');
        }
      }
    }

    function cleanupChapters(chapters) {
      let phienNgoai = c => /phiên ngoại/iu.test(c._.title);

      // debug({chapters})
      let i = 1;
      while (i < chapters.length - 1) {
        let [ch, ci, cj] = [chapters[i-1], chapters[i], chapters[i+1]];
        let shouldMerge = false;
        //ci is not continuity of ch
        if (ch.chapNo != null && ci.chapNo != null && (ch.chapNo + 1 != ci.chapNo)) {
          // console.log('phien ngoai', [ch._.title, ci._.title]);
          if (phienNgoai(ch) != phienNgoai(ci) || ch.half != ci.half) {
            i++;
            continue;
          }
          if (!cj && !/phiên ngoại/iu.test(ci._.title)) {
            //ci is the last chapter, can merge
            shouldMerge = true;
          } else {
            //find continuity of ch
            for (let j = i + 1; j <= i + 3 && j < chapters.length; j++) {
              cj = chapters[j];
              // console.log(ch.chapNo, cj.chapNo);
              if (cj.chapNo != null && (ch.chapNo + 1 == cj.chapNo)) {
                shouldMerge = true;
                break;
              }
            }
          }
        }
        if (shouldMerge) {
          console.debug('cleanupChapters', ch.chapNo, '<-', ci.chapNo, cj?.chapNo);
          mergeBehind(chapters, i, 'cleanup');
        } else {
          i++;
        }
      }
    }

    function mergeShortChapters(chapters, minLength = 2_000) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let [h, j] = [i-1, i+1];
        let [ch, ci, cj] = [chapters[h], chapters[i], chapters[j]];
        if (ci.length < minLength) {
          let fields = [];
          if (ci.bookNo) fields.push('bookNo');
          if (ci.chapter != null) fields.push('chapter');
          if (ci.half) fields.push('half');
          if (fields.every(f => ch[f] == ci[f]))
            mergeBehind(chapters, i, 'short and dupe of prev');
          else if (cj && fields.every(f => cj[f] == ci[f]))
            mergeBehind(chapters, j, 'short and dupe of next');
          else if (fields.length == 0) {
            if (ci._.name && cj)
              mergeBehind(chapters, j, 'short with name');
            else
              mergeBehind(chapters, i, 'short');
          }
        }
      }
    }

    function mergeShortChapters1(chapters, minLength = 2e3) {
      let isShort = chapter => ((chapter.endIndex - chapter.startIndex) <= minLength);
      let isLong = chapter => !isShort(chapter);
      //delete all first short chapters, they belongs to prologue
      let firstLongChapterIndex = chapters.findIndex(isLong);
      chapters.splice(0, firstLongChapterIndex);
      //merge short chapters to next long chapter
      let short;
      while((short = chapters.find(isShort))) {
        let shortIndex = chapters.indexOf(short);
        let long = chapters.find((chapter, index) => isLong(chapter) && index >= shortIndex);
        let longIndex = chapters.indexOf(long);
        if (long) {
          short.endIndex = long.endIndex;
          chapters.splice(shortIndex, longIndex - shortIndex);
        } else {
          //merge last short chapters to previous long chapter
          long = chapters[shortIndex - 1];
          if (long) {
            long.endIndex = text.length;
            chapters.length = shortIndex;
          }
          break;
        }
      }
    }

    function addPrologue(chapters, filename, text) {
      //extract prologue
      let prologue = text.slice(0, chapters[0]?.startIndex ?? -1).trim();
      if(prologue) {
        chapters.unshift(Chapter({
          title: filename,
          index: 0,
        }, { chapters, filename, text }));
      }
    }

    function extractChapters1(filename, text, { name }) {
      let debug = true;
      debug && console.log({ name });
      //let chapterPattern = /^\s*\[?\s*(?:chapter)?\s*:?\s*Thứ\s+\w+(\s*-\s*\d+)?\s+chương\b.*|\bChương\s+\d+\s*:?.*|^(?:\d+\s*\.?\s*)+$|^\s*\d+\s+Chương\s*:?\s*|^【.*?】\([\d-]+\)$|^【.*?】\s*bộ(\s+\d+)+$|^\d+[.!].*|^\s*\d+(\s*-\s*\d+)?\s*$|^[-]+$/gimu;
      let certainPatterns = [
        /^chương \d+$/,
        /^chương \d+:/,
        /^— ?chương \d+:.*? ?—/,
        /^chương (cuối|kết)/,
        /^tự chương/,
        /^Lời dẫn/,
        /^bộ \d+:? chương \d+/, // bộ 01: chương 05:
        /^thứ \d+ bộ thứ \d+ chương/, // thứ 01 bộ thứ 02 chương
        /^\d+([\.\s]+\d+)*$/,
        /thứ \d+ chương/,
        /^\(\d+\)/,
        /^Hồi \d+/,
        new RegExp('^【' + name + '】\\d+$'),
        new RegExp('^"' + name + '" \\d+$'),
        /^ch\. \d+/,
        /^ ?\[? ?(?:chapter)? ?:? ?Thứ \w+( ?- ?\d+)? chương/,
        /^ ?\d+ Chương ?:? ?/,
        /^【.*?】\([\d-]+\)$/,
        /^【.*?】 ?bộ( \d+)+$/,
        /^\d+[.!].*/,
        /^ ?\d+( ?- ?\d+)? ?$/,
        /quyển (thứ )?(\d+|(một|hai|ba|bốn|năm|sáu|bảy|tám|chín|(mười( một)?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( mốt)?)( (hai|ba|bốn|lăm|sáu|bảy|tám|chín))?)) chương \d.*/,
        /(phiên ngoại|chính văn) chương \d+:/,
        /phiên ngoại .* chương/,
        /^(thượng|trung|hạ) \(\d+\)$/,
        /^(thượng|trung|hạ) bộ/,
      ];
      let loosePatterns = [
        new RegExp('^【' + name + '】.*$'),
        new RegExp('^"' + name + '".*$'),
        new RegExp('^' + name + ' [\\(\\.:\\d]'),
        /^.*\((thượng|trung|hạ)\):?$/, // phản kích (thượng)
        /^([(]?)(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập|(mười) (một|hai|ba|bốn|năm|sáu|bảy|tám|chín|mươi))(?=[,:)])([^.]*)$/,
        /^(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập).*/,
        /^\[.*\]$/,
        /^[-—* ]+$/,
      ];
      let matches;
      for (let patterns of [certainPatterns, loosePatterns]) {
        let regex = new RegExp('(?:' + patterns.map(p => '(?:' + p.source + ')').join('|') + ').*', 'gimu');
        matches = [...regex[Symbol.matchAll](text)];
        debug && console.log({ regex, matches })
        if (matches.length > 0) break;
      }
      let chapters = matches.map((match, i) => {
        let startIndex = text.lastIndexOf('\n', match.index);
        if (startIndex == -1) startIndex = 0;
        let endIndex = text.length;
        if (matches[i+1]) endIndex = text.lastIndexOf('\n', matches[i+1].index);
        let title = match[0].trim();
        if (/^[-—]+$/.test(title)) title = `-Chương ${i+1}-`;
        title = title.replace(new RegExp('^【(' + name + ')】\s*', 'i'), '');
        title = title.replace(new RegExp('^"(' + name + ')"\s*', 'i'), '');
        title = title.replace(new RegExp('^(' + name + ')\s*', 'i'), '');
        return {
          title,
          startIndex,
          endIndex,
        }
      });

      return mergeChapters(chapters, filename, text);
    }

    function slug(s) {
      s = latinize(s);
      s = s.replace(/\W+/g, '-');
      s = s.replace(/^-+|-+$/g, '');
      s = s.toLowerCase();
      return s;
    }

    function latinize(s) {
      s = s.replace(/[ÁĂẮẶẰẲẴǍÂẤẬẦẨẪÄǞȦǠẠȀÀẢȂĀĄÅǺḀȺÃⱯᴀ]/g, 'A');
      s = s.replace(/[Ꜳ]/g, 'AA');
      s = s.replace(/[ÆǼǢᴁ]/g, 'AE');
      s = s.replace(/[Ꜵ]/g, 'AO');
      s = s.replace(/[Ꜷ]/g, 'AU');
      s = s.replace(/[ꜸꜺ]/g, 'AV');
      s = s.replace(/[Ꜽ]/g, 'AY');
      s = s.replace(/[ḂḄƁḆɃƂʙᴃБ]/g, 'B');
      s = s.replace(/[ĆČÇḈĈĊƇȻꜾᴄ]/g, 'C');
      s = s.replace(/[ĎḐḒḊḌƊḎǲǅĐÐƋꝹᴅД]/g, 'D');
      s = s.replace(/[ǱǄ]/g, 'DZ');
      s = s.replace(/[ÉĔĚȨḜÊẾỆỀỂỄḘËĖẸȄÈẺȆĒḖḔĘɆẼḚƐƎᴇⱻЕЭ]/g, 'E');
      s = s.replace(/[Ꝫ]/g, 'ET');
      s = s.replace(/[ḞƑꝻꜰФ]/g, 'F');
      s = s.replace(/[ǴĞǦĢĜĠƓḠǤꝽɢʛГҐ]/g, 'G');
      s = s.replace(/[ḪȞḨĤⱧḦḢḤĦʜХ]/g, 'H');
      s = s.replace(/[ÍĬǏÎÏḮİỊȈÌỈȊĪĮƗĨḬІɪЙЫИ]/g, 'I');
      s = s.replace(/[ꞂŔŘŖṘṚṜȐȒṞɌⱤʁʀᴙᴚР]/g, 'R');
      s = s.replace(/[ꞄŚṤŠṦŞŜȘṠṢṨꜱС]/g, 'S');
      s = s.replace(/[ꞆŤŢṰȚȾṪṬƬṮƮŦᴛТ]/g, 'T');
      s = s.replace(/[Ꝭ]/g, 'IS');
      s = s.replace(/[ĴɈᴊ]/g, 'J');
      s = s.replace(/[ḰǨĶⱩꝂḲƘḴꝀꝄᴋК]/g, 'K');
      s = s.replace(/[ĹȽĽĻḼḶḸⱠꝈḺĿⱢǈŁꞀʟᴌЛ]/g, 'L');
      s = s.replace(/[Ǉ]/g, 'LJ');
      s = s.replace(/[ḾṀṂⱮƜᴍМ]/g, 'M');
      s = s.replace(/[ŃŇŅṊṄṆǸƝṈȠǋÑɴᴎН]/g, 'N');
      s = s.replace(/[Ǌ]/g, 'NJ');
      s = s.replace(/[ÓŎǑÔỐỘỒỔỖÖȪȮȰỌŐȌÒỎƠỚỢỜỞỠȎꝊꝌŌṒṐƟǪǬØǾÕṌṎȬƆᴏᴐО]/g, 'O');
      s = s.replace(/[Ƣ]/g, 'OI');
      s = s.replace(/[Ꝏ]/g, 'OO');
      s = s.replace(/[Ȣᴕ]/g, 'OU');
      s = s.replace(/[ṔṖꝒƤꝔⱣꝐᴘП]/g, 'P');
      s = s.replace(/[ꝘꝖ]/g, 'Q');
      s = s.replace(/[ß]/g, 'ss');
      s = s.replace(/[ɅꝞṾƲṼᴠВ]/g, 'V');
      s = s.replace(/[Ꜩ]/g, 'TZ');
      s = s.replace(/[ÚŬǓÛṶÜǗǙǛǕṲỤŰȔÙỦƯỨỰỪỬỮȖŪṺŲŮŨṸṴᴜУ]/g, 'U');
      s = s.replace(/[Ꝡ]/g, 'VY');
      s = s.replace(/[ẂŴẄẆẈẀⱲᴡ]/g, 'W');
      s = s.replace(/[ẌẊ]/g, 'X');
      s = s.replace(/[ÝŶŸẎỴỲƳỶỾȲɎỸʏ]/g, 'Y');
      s = s.replace(/[Ї]/g, 'YI');
      s = s.replace(/[ŹŽẐⱫŻẒȤẔƵᴢЗ]/g, 'Z');
      s = s.replace(/[Þ]/g, 'TH');
      s = s.replace(/[Ĳ]/g, 'IJ');
      s = s.replace(/[Œɶ]/g, 'OE');
      s = s.replace(/[áăắặằẳẵǎâấậầẩẫäǟȧǡạȁàảȃāąᶏẚåǻḁⱥãɐₐАа]/g, 'a');
      s = s.replace(/[ꜳ]/g, 'aa');
      s = s.replace(/[æǽǣᴂ]/g, 'ae');
      s = s.replace(/[ꜵ]/g, 'ao');
      s = s.replace(/[ꜷ]/g, 'au');
      s = s.replace(/[ꜹꜻ]/g, 'av');
      s = s.replace(/[ꜽ]/g, 'ay');
      s = s.replace(/[ḃḅɓḇᵬᶀƀƃб]/g, 'b');
      s = s.replace(/[ɵóŏǒôốộồổỗöȫȯȱọőȍòỏơớợờởỡȏꝋꝍⱺōṓṑǫǭøǿõṍṏȭɔᶗᴑᴓₒо]/g, 'o');
      s = s.replace(/[ćčçḉĉɕċƈȼↄꜿ]/g, 'c');
      s = s.replace(/[ďḑḓȡḋḍɗᶑḏᵭᶁđɖƌðꝺд]/g, 'd');
      s = s.replace(/[ıíĭǐîïḯịȉìỉȋīįᶖɨĩḭіᴉᵢйыи]/g, 'i');
      s = s.replace(/[ȷɟʄǰĵʝɉⱼ]/g, 'j');
      s = s.replace(/[ǳǆ]/g, 'dz');
      s = s.replace(/[éĕěȩḝêếệềểễḙëėẹȅèẻȇēḗḕⱸęᶒɇẽḛɛᶓɘǝₑеэ]/g, 'e');
      s = s.replace(/[ꝫ]/g, 'et');
      s = s.replace(/[ḟƒᵮᶂꝼф]/g, 'f');
      s = s.replace(/[ǵğǧģĝġɠḡᶃǥᵹɡᵷгґ]/g, 'g');
      s = s.replace(/[ḫȟḩĥⱨḧḣḥɦẖħɥʮʯх]/g, 'h');
      s = s.replace(/[ƕ]/g, 'hv');
      s = s.replace(/[ꞃŕřŗṙṛṝȑɾᵳȓṟɼᵲᶉɍɽɿɹɻɺⱹᵣр]/g, 'r');
      s = s.replace(/[ꞅſẜẛẝśṥšṧşŝșṡṣṩʂᵴᶊȿс]/g, 's');
      s = s.replace(/[ꞇťţṱțȶẗⱦṫṭƭṯᵵƫʈŧʇт]/g, 't');
      s = s.replace(/[ꝭ]/g, 'is');
      s = s.replace(/[ḱǩķⱪꝃḳƙḵᶄꝁꝅʞк]/g, 'k');
      s = s.replace(/[ĺƚɬľļḽȴḷḹⱡꝉḻŀɫᶅɭłꞁл]/g, 'l');
      s = s.replace(/[ǉ]/g, 'lj');
      s = s.replace(/[ḿṁṃɱᵯᶆɯɰм]/g, 'm');
      s = s.replace(/[ńňņṋȵṅṇǹɲṉƞᵰᶇɳñн]/g, 'n');
      s = s.replace(/[ǌ]/g, 'nj');
      s = s.replace(/[ƣ]/g, 'oi');
      s = s.replace(/[ꝏ]/g, 'oo');
      s = s.replace(/[ȣ]/g, 'ou');
      s = s.replace(/[ṕṗꝓƥᵱᶈꝕᵽꝑп]/g, 'p');
      s = s.replace(/[ꝙʠɋꝗ]/g, 'q');
      s = s.replace(/[ᴝúŭǔûṷüǘǚǜǖṳụűȕùủưứựừửữȗūṻųᶙůũṹṵᵤу]/g, 'u');
      s = s.replace(/[ᵺþ]/g, 'th');
      s = s.replace(/[ᴔœ]/g, 'oe');
      s = s.replace(/[ʌⱴꝟṿʋᶌⱱṽᵥв]/g, 'v');
      s = s.replace(/[ʍẃŵẅẇẉẁⱳẘ]/g, 'w');
      s = s.replace(/[ʎýŷÿẏỵỳƴỷỿȳẙɏỹ]/g, 'y');
      s = s.replace(/[ꜩ]/g, 'tz');
      s = s.replace(/[ᵫ]/g, 'ue');
      s = s.replace(/[ꝸ]/g, 'um');
      s = s.replace(/[ꝡ]/g, 'vy');
      s = s.replace(/[ẍẋᶍₓ]/g, 'x');
      s = s.replace(/[ї]/g, 'yi');
      s = s.replace(/[źžẑʑⱬżẓȥẕᵶᶎʐƶɀз]/g, 'z');
      s = s.replace(/[ﬀ]/g, 'ff');
      s = s.replace(/[ﬃ]/g, 'ffi');
      s = s.replace(/[ﬄ]/g, 'ffl');
      s = s.replace(/[ﬁ]/g, 'fi');
      s = s.replace(/[ﬂ]/g, 'fl');
      s = s.replace(/[ĳ]/g, 'ij');
      s = s.replace(/[ﬆ]/g, 'st');
      s = s.replace(/[Ё]/g, 'YO');
      s = s.replace(/[Ц]/g, 'TS');
      s = s.replace(/[Ш]/g, 'SH');
      s = s.replace(/[Щ]/g, 'SCH');
      s = s.replace(/[ЪъЬь]/g, '\'');
      s = s.replace(/[ё]/g, 'yo');
      s = s.replace(/[ц]/g, 'ts');
      s = s.replace(/[ш]/g, 'sh');
      s = s.replace(/[щ]/g, 'sch');
      s = s.replace(/[Ж]/g, 'ZH');
      s = s.replace(/[ж]/g, 'zh');
      s = s.replace(/[Я]/g, 'Ya');
      s = s.replace(/[Ч]/g, 'CH');
      s = s.replace(/[Ю]/g, 'YU');
      s = s.replace(/[я]/g, 'ya');
      s = s.replace(/[ч]/g, 'ch');
      s = s.replace(/[ю]/g, 'yu');
      return s;
    }

    function titleizeHumanName(s, minOccurence = 10, occurenceThreshold = 0.8) {
      let debug = false;
      debug && console.time('titleizeHumanName');
      let pattern = /(?:(?<pre>\p{Ll}+)[ ]+)?(?<name>[\p{Lu}A-Z]\p{Ll}+(?:[ ]+\p{Lu}\p{Ll}+)?)(?:[ ]+(?<post>\p{Ll}+))?/gu;
      let counts = {};
      let match;
      let titleize = s => s.replace(/(?<=^|[^\p{L}])\p{L}/gu, s => s.toUpperCase());
      let c = 0;
      while ((match = pattern.exec(s))) {
        if (++c < 10) debug && console.log({ match });
        let { pre, name, post } = match.groups;
        if (!counts[name]) counts[name] = { total: 0, pre: {}, post: {} };
        counts[name].total += 1;
        if (pre) {
          if (!counts[name].pre[pre]) counts[name].pre[pre] = 0;
          counts[name].pre[pre] += 1;
        }
        if (post) {
          if (!counts[name].post[post]) counts[name].post[post] = 0;
          counts[name].post[post] += 1;
        }
      }
      debug && console.dir(counts);
      analyze: for (let [name, { total, pre, post }] of Object.entries(counts)) {
        if (total < minOccurence) {
          debug && console.debug(name, 'is too few .. IGNORE', { total });
          continue analyze;
        }
        for (let [prefix, prefixCount] of Object.entries(pre)) {
          if (prefixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(prefix), name, { total, prefixCount });
            s = s.replace(new RegExp(prefix + '\\s+' + name, 'gu'), titleize);
            continue analyze;
          }
        }
        for (let [postfix, postfixCount] of Object.entries(post)) {
          if (postfixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(postfix), name, { total, postfixCount });
            s = s.replace(new RegExp(name + '\\s+' + postfix, 'gu'), titleize);
            continue analyze;
          }
        }
      }
      debug && console.timeEnd('titleizeHumanName');
      return s;
    }

    function debug(...args) {
      if (args.length == 1) {
        console.table(Object.values(args[0])[0]);
      } else {
        console.info(...args);
      }
    }

    function getColorScheme() {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
      return 'light';
    }

    function buildRegex(patterns, placeholders, flags) {
      patterns = patterns.map((p, i) => `(?<Case${i+1}>${p.source || p})`).join('|');
      let counts = Object.fromEntries(Object.keys(placeholders).map(k => [k, 0]));
      for(let i = 1; i <= 10; i++) {
        for(let [p, r] of Object.entries(placeholders)) {
          patterns = patterns.replaceAll(`{${p}}`, () => `(?<${p}${++counts[p]}>${r.source || r})`);
        }
      }
      return new RegExp(patterns, flags);
    }
  </script>
</body>
</html>
