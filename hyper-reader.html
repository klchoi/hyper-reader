<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìñ</text></svg>">
  <title>Text Reader</title>
  <style>
    @font-face {
      font-family: Reader1;
      src: local('LMRoman12-Regular'), url('https://mirror.kku.ac.th/CTAN/fonts/lm/fonts/opentype/public/lm/lmroman12-regular.otf') format('opentype');
    }
    @font-face {
      font-family: Reader;
      font-weight: 400;
      src: local('WorkSans-Regular');
    }
    @font-face {
      font-family: Reader;
      font-weight: 500;
      src: local('WorkSans-Medium');
    }

    /** reset **/
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      border: 0;
      outline: 0;
      transform-origin: 50% 50%;
    }
    p {
      margin: 1em 0;
    }
    hr {
      border: 0;
      height: 1px;
      background: rgba(0, 0, 0, .2);
    }
    a,
    a:any-link {
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-skip-ink: none;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    small {
      font-size: 0.875em;
    }

    /** rose pine **/
    :root {
      --rp-main-base: #191724;
      --rp-main-surface: #1f1d2e;
      --rp-main-overlay: #26233a;
      --rp-main-muted: #6e6a86;
      --rp-main-subtle: #908caa;
      --rp-main-text: #e0def4;
      --rp-main-love: #eb6f92;
      --rp-main-gold: #f6c177;
      --rp-main-rose: #ebbcba;
      --rp-main-pine: #31748f;
      --rp-main-foam: #9ccfd8;
      --rp-main-iris: #c4a7e7;
      --rp-main-highlight-low: #21202e;
      --rp-main-highlight-low-alpha: #6e6a861a;
      --rp-main-highlight-med: #403d52;
      --rp-main-highlight-med-alpha: #6e6a8633;
      --rp-main-highlight-high: #524f67;
      --rp-main-highlight-high-alpha: #6e6a8666;
      --rp-moon-base: #232136;
      --rp-moon-surface: #2a273f;
      --rp-moon-overlay: #393552;
      --rp-moon-muted: #6e6a86;
      --rp-moon-subtle: #908caa;
      --rp-moon-text: #e0def4;
      --rp-moon-love: #eb6f92;
      --rp-moon-gold: #f6c177;
      --rp-moon-rose: #ea9a97;
      --rp-moon-pine: #3e8fb0;
      --rp-moon-foam: #9ccfd8;
      --rp-moon-iris: #c4a7e7;
      --rp-moon-highlight-low: #2a283e;
      --rp-moon-highlight-low-alpha: #817c9c14;
      --rp-moon-highlight-med: #44415a;
      --rp-moon-highlight-med-alpha: #817c9c26;
      --rp-moon-highlight-high: #56526e;
      --rp-moon-highlight-high-alpha: #817c9c4d;
      --rp-dawn-base: #faf4ed;
      --rp-dawn-surface: #fffaf3;
      --rp-dawn-overlay: #f2e9e1;
      --rp-dawn-muted: #9893a5;
      --rp-dawn-subtle: #797593;
      --rp-dawn-text: #575279;
      --rp-dawn-love: #b4637a;
      --rp-dawn-gold: #ea9d34;
      --rp-dawn-rose: #d7827e;
      --rp-dawn-pine: #286983;
      --rp-dawn-foam: #56949f;
      --rp-dawn-iris: #907aa9;
      --rp-dawn-highlight-low: #f4ede8;
      --rp-dawn-highlight-low-alpha: #6e6a860d;
      --rp-dawn-highlight-med: #dfdad9;
      --rp-dawn-highlight-med-alpha: #6e6a8614;
      --rp-dawn-highlight-high: #cecacd;
      --rp-dawn-highlight-high-alpha: #6e6a8626;
    }

    /** variables **/
    :root {
      --nav-width: 300px;
      --aside-width: 60px;
      --gap: 1rem;
      --paper-padding: calc(var(--gap) * 3);
      cursor: default;
    }
    .settings .colors button.white {
      --body-font-color: rgb(27, 27, 27);
      --body-background-color: rgb(230, 230, 230);
      --paper-background-color: rgb(255, 255, 255);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(65, 110, 210);
      --horizontal-line-color: rgb(220, 220, 220);
    }
    :root[data-color\:light=white] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    :root[data-color\:dark=white] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    .settings .colors button.sepia {
      --body-font-color: rgb(79, 50, 28);
      --body-background-color: rgb(225, 216, 200);
      --paper-background-color: rgb(248, 241, 227);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(209, 150, 0);
      --horizontal-line-color: rgb(230, 218, 201);
    }
    :root[data-color\:light=sepia] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    :root[data-color\:dark=sepia] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    .settings .colors button.gray {
      --body-font-color: rgba(255, 255, 255, 0.78);
      --body-background-color: rgb(50, 50, 51);
      --paper-background-color: rgb(74, 74, 77);
      /*--paper-shadow-color: rgba(0, 0, 0, .24); */
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(111, 111, 111);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=gray] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=gray] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.night {
      --body-font-color: rgb(176, 176, 176);
      --body-background-color: rgb(0, 0, 0);
      --paper-background-color: rgb(18, 18, 18);
      --paper-outline-color: #272727;
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(62, 62, 62);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=night] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=night] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine {
      --body-font-color: var(--rp-main-subtle);
      --body-background-color: var(--rp-main-surface);
      --paper-background-color: var(--rp-main-base);
      --paper-outline-color: var(--rp-main-highlight-med-alpha);
      --link-color: var(--rp-main-pine);
      --horizontal-line-color: var(--rp-main-highlight-high-alpha);
      --selection-bg: var(--rp-main-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-moon {
      --body-font-color: var(--rp-moon-subtle);
      --body-background-color: var(--rp-moon-surface);
      --paper-background-color: var(--rp-moon-base);
      --paper-outline-color: var(--rp-moon-highlight-med-alpha);
      --link-color: var(--rp-moon-rose);
      --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
      --selection-bg: var(--rp-moon-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine-moon] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine-moon] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-dawn {
      --body-font-color: var(--rp-dawn-text);
      --body-background-color: var(--rp-dawn-base);
      --paper-background-color: var(--rp-dawn-overlay);
      --paper-outline-color: var(--rp-dawn-highlight-med);
      --link-color: var(--rp-dawn-love);
      --horizontal-line-color: var(--rp-dawn-highlight-high);
      --selection-bg: var(--rp-dawn-highlight-med);
    }
    :root[data-color\:light=rose-pine-dawn] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }
    :root[data-color\:dark=rose-pine-dawn] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }
    .settings .colors button.solarized,
    :root[data-color\:light=solarized] {
      @media (prefers-color-scheme:light) {
        --body-font-color: #002a35;
        --body-background-color: #f3edda;
        --paper-background-color: #fdf6e3;
        --paper-outline-color: #e0d9c6;
        --link-color: #cb4b17;
        --horizontal-line-color: #9faaa8;
        --selection-bg: #cadcdf;
      }
    }
    .settings .colors button.solarized,
    :root[data-color\:dark=solarized] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: #002a35;
        --body-background-color: #f3edda;
        --paper-background-color: #fdf6e3;
        --paper-outline-color: #e0d9c6;
        --link-color: #cb4b17;
        --horizontal-line-color: #9faaa8;
        --selection-bg: #cadcdf;
      }
    }
    .settings .colors button.kiselevka,
    :root[data-color\:light=kiselevka] {
      @media (prefers-color-scheme:light) {
        --body-font-color: #81a8bf;
        --body-background-color: #14222c;
        --paper-background-color: #0f1921;
        --paper-outline-color: #1e3140;
        --link-color: #a99d8c;
        --horizontal-line-color: #2d3941;
        --selection-bg: #153d4f;
      }
    }
    .settings .colors button.kiselevka,
    :root[data-color\:dark=kiselevka] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: #81a8bf;
        --body-background-color: #14222c;
        --paper-background-color: #0f1921;
        --paper-outline-color: #1e3140;
        --link-color: #a99d8c;
        --horizontal-line-color: #2d3941;
        --selection-bg: #153d4f;
      }
    }
    :root[data-color\:dark] {
      --body-font-smoothing: antialiased;
    }

    :root,
    :root[data-paper-size=sm] { --paper-width: 90ex; }
    :root[data-paper-size=md] { --paper-width: 120ex; }
    :root[data-paper-size=lg] { --paper-width: 160ex; }
    :root[data-paper-size=xl] { --paper-width: 100%; }

    *::selection {
      background-color: var(--selection-bg);
    }

    /** layout **/
    body {
      display: grid;
      grid-template-columns: minmax(var(--nav-width), 1fr) minmax(auto, calc(var(--paper-width) + 2*var(--paper-padding))) minmax(var(--aside-width), 1fr);
    }

    /** global **/
    html,
    body {
      font: 16pt/1.4 Reader;
      color: var(--body-font-color);
      background: var(--body-background-color);
      font-variant-numeric: oldstyle-nums tabular-nums slashed-zero;
      -webkit-font-smoothing: var(--body-font-smoothing, normal);
    }
    a {
      color: var(--link-color);
    }

    @property --scroll-progress {
      syntax: '<percentage>';
      initial-value: 100%;
      inherits: false;
    }
    @keyframes scrollProgress {
      0% {
        --scroll-progress: 0%;
      }
      100% {
        --scroll-progress: 100%;
      }
    }

    /** nav **/
    nav {
      height: 100vh;
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: sticky;
      top: 0;
      padding: calc(var(--gap) * 0.75);
      font-size: 0.875rem;
      line-height: 1.2;
      ol {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.5em;
        align-items: start;
        li {
          /**/
          max-width: 100%;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          /**/
          padding-top: 0.1ex;
          padding-bottom: 0.1ex;
          padding-left: calc(var(--gap) * 0.25);
          padding-right: calc(var(--gap) * 0.25);
          &.active {
            background: var(--body-font-color);
            outline: calc(var(--gap) * 0.15) solid var(--body-font-color);
            border-radius: 0.5ex;
            color: var(--body-background-color);
            a {
              pointer-events: none;
              color: inherit;
            }
          }
          a {
            color: var(--body-font-color);
            &:hover {
              color: var(--link-color);
            }
          }
          &:first-child a {
            font-weight: bold;
          }
        }
      }
    }

    /** aside **/
    aside {
      position: sticky;
      top: 0;
      height: 100vh;
    }
    aside a,
    aside button {
      appearance: none;
      background: var(--paper-background-color);
      color: var(--body-font-color);
      outline: 1px solid var(--horizontal-line-color);
      width: 100%;
      min-width: 25px;
      aspect-ratio: 1;
      display: grid;
      place-content: center;
      border-radius: 50%;
      cursor: pointer;
    }
    aside > div {
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      padding-left: var(--gap);
      padding-right: var(--gap);
      display: flex;
      flex-direction: column;
      row-gap: calc(var(--gap) * .5);
      width: var(--aside-width);
    }
    aside > div + div {
      position: relative;
    }
    aside > div + div::before {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate3d(-50%, 0, 0);
      content: '';
      display: block;
      width: calc(var(--gap) * 2);
      height: 1px;
      background: var(--horizontal-line-color);
      opacity: 0.5;
    }
    aside .colors button {
      &::before {
        content: var(--checkmark);
        font-size: .7em;
      }
      @media (prefers-color-scheme:light) {
        &.checked\:light {
          --checkmark: '‚úî';
        }
      }
      @media (prefers-color-scheme:dark) {
        &.checked\:dark {
          --checkmark: '‚úî';
        }
      }
    }
    aside a.close {
      position: relative;
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::before,
      &::after {
        content: '';
        display: block;
        width: 50%;
        height: 1px;
        transform: translate3d(-50%, -50%, 0) rotateZ(var(--rotate, 45deg));
        position: absolute;
        top: 50%;
        left: 50%;
        background: currentColor;
      }
      &::after {
        --rotate: -45deg;
      }

      outline: 0;
      background: radial-gradient(closest-side, var(--paper-background-color) 79%, transparent 80% 100%), conic-gradient(var(--link-color) var(--scroll-progress, 0%), var(--horizontal-line-color) 0);
      animation: scrollProgress auto linear;
      animation-timeline: scroll();
    }
    aside button.refresh {
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::after {
        content: '‚Üª';
        font-size: 1rem;
        position: relative;
        top: -1px;
      }
    }
    aside .paper-size button {
      border-radius: 0.75ex;
      outline-width: 0;
      &.selected {
        font-weight: bold;
      }
    }
    aside button.zen {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: '‚Ñ§';
      }
    }
    aside button.names-editor {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: '‚Ñï';
      }
    }

    /** main **/
    main {
      /**
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      /**/
      display: flex;
      background: var(--paper-background-color);
      padding: 1rem 3rem;
      outline: 1px solid var(--paper-outline-color, transparent);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color, transparent);
      article {
        flex: 1;
        text-indent: 3ch;
        max-width: var(--paper-width, 90ex);
        margin: 0 auto;
        p:first-child {
          line-height: 1.2;
          font-size: 1.5rem;
          font-weight: bold;
        }
        hr {
          background: var(--horizontal-line-color);
        }

        ::highlight(name) {
          color: var(--link-color);
        }
      }
    }

    /** table **/
    .table {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      row-gap: var(--gap);
      column-gap: calc(var(--gap) * 2);
      padding: 0 var(--gap) var(--gap);
      background: var(--paper-background-color);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color);
      outline: 1px solid var(--paper-outline-color);
      line-height: 1.2;
      align-self: stretch;
      align-content: start;
    }
    .table .name {
      font-weight: bold;
    }
    .table .th {
      white-space: nowrap;
      padding: calc(var(--gap)/2) 0;
      position: sticky;
      top: 0;
      background: var(--paper-background-color);
    }
    .table .th::before {
      content: '';
      display: block;
      border-bottom: 1px solid var(--horizontal-line-color);
      width: calc(100% + 1ex);
      height: calc(2ex + 2px);
      box-shadow: 0 calc(1ex - 5px) 1.4ex -1ex rgba(0, 0, 0, .5);
      position: absolute;
      bottom: -1px;
      left: calc(-1ex / 2);
    }
    .table .th span {
      display: inline-block;
      position: relative;
    }
    .table .th span::after {
      position: absolute;
      bottom: calc(1ex/4);
      right: -1.8ex;
      color: var(--body-font-color);
    }
    .table .th[data-sort=asc] span::after { content: '‚Üë'; }
    .table .th[data-sort=desc] span::after { content: '‚Üì'; }
    .table .desc { display: block; }
    .table .delete { color: inherit; }
    .table .delete:hover { color: var(--link-color); }

    /** disable scroll when mouse is not over **/
    /**
    nav,
    main {
      height: 100%;
      overflow-y: hidden;
    }
    nav:hover,
    main:hover {
      overflow-y: auto;
    }
    /**/

    /** zen mode **/
    [data-zen=true] nav {
      opacity: 0;
      transition: opacity .15s ease-in-out;
      &:hover {
        opacity: 1;
      }
    }

    /** command palette **/
    #command-palette[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      max-height: 70%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      padding: 0.7ex;

      form {
        display: contents;

        input {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
        }
      }

      ul {
        list-style: none;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overscroll-behavior-y: contain;
        position: relative;
        margin-top: 0.7ex;
        gap: 1px;

        li {
          a {
            display: block;
            padding: 0.5ex 1.3ex;
            border-radius: 0.8ex;
            color: var(--body-font-color);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }

          &:hover,
          &.selected {
            a {
              background: var(--paper-background-color);
            }
          }

          ::highlight(match) {
            background: yellow;
          }
        }
      }
    }

    /** names editor **/
    #names-editor[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      height: 80%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      gap: 0.7ex;
      padding: 0.7ex;

      form {
        display: contents;

        textarea {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
          flex: 1;
        }

        button {
          appearance: none;
          background: transparent;
          /**
          &:hover,
          &:focus,
          &:active {
            background: var(--paper-background-color);
          }
          /**/
          color: var(--body-font-color);
          width: 100%;
          min-width: 25px;
          display: grid;
          place-content: center;
          border-radius: 0.8ex;
          cursor: pointer;
          font-size: inherit;
          line-height: 1.8;
        }
      }
    }

    .text-left { text-align: left; }
    .text-right { text-align: right; }
    .text-center { text-align: center; }
    .indent-none { text-indent: 0; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, text, app } from 'https://cdn.jsdelivr.net/npm/hyperapp/+esm';
    import { openDB } from 'https://cdn.jsdelivr.net/npm/idb/+esm';
    // import { generateColor as stc } from 'https://cdn.jsdelivr.net/npm/@marko19907/string-to-color/+esm';
    import _ from 'https://cdn.jsdelivr.net/npm/lodash-es/+esm';
    import chromaJs from 'https://cdn.jsdelivr.net/npm/chroma-js@2.4/+esm';

    class HashRouter extends EventTarget {
      parse(hash) {
        return [...(new URLSearchParams(hash)).entries()].reduce((route, [k, v]) => (route[k] = v, route), {});
      }
      get(key) {
        return new URLSearchParams(location.hash.slice(1)).get(key);
      }
      current() {
        return this.parse(location.hash.slice(1));
      }
      route(route) {
        let hash = new URLSearchParams(Object.entries(route).filter(([k, v]) => v !== '' && v != null)).toString();
        if (hash) hash = '#' + hash;
        return hash;
      }
      push(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.pushState(null, null, url);
        }
      }
      replace(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.replaceState(null, null, url);
        }
      }
    }

    let InitDbDone = (state, { db }) => [
      { ...state, db },
      (dispatch) => {
        window.db = db;
        dispatch(LoadSettings);
        dispatch(LoadProgress);
        dispatch(LoadRecentBooks);
        dispatch(LoadRecentBook);
      }
    ];
    let InitDb = (state) => [
      state,
      async (dispatch) => {
        let db = await openDB('text-reader', 23, {
          upgrade(db, oldVersion, newVersion, transaction, events) {
            console.log('upgrade db', { oldVersion, newVersion, transaction, events });
            let schemas = {
              files: {},
              fileContents: {},
              settings: {},
              progress: {},
              books: {},
              chapters: {},
              names: {},
            };
            for (let [store, keyOptions] of Object.entries(schemas)) {
              if (!db.objectStoreNames.contains(store)) {
                db.createObjectStore(store, keyOptions);
              }
            }
            //for(let store of db.objectStoreNames) {
            //  if (!(store in schemas)) {
            //    console.warn('Delete store', store);
            //    db.deleteObjectStore(store);
            //  }
            //}
          },
          blocked: console.log,
          blocking: console.log,
          terminated: console.log,
        });

        dispatch(InitDbDone, { db });
      }
    ];

    let InitTheme = (state) => [
      state,
      (dispatch) => {
        let colors = { 'color:dark': 'night', 'color:light': 'white' };
        dispatch(ApplySettings, colors);
      }
    ];

    let InitRouter = (state) => [
      state,
      (dispatch) => {
        addEventListener('hashchange', (event) => {
          let from = state.router.parse(new URL(event.oldURL).hash.slice(1));
          let to = state.router.parse(new URL(event.newURL).hash.slice(1));
          if (!to.book) {
            dispatch(ShowRecentBooks);
          } else {
            dispatch(OpenBook, { bookId: to.book, chapterId: to.chapter });
          }
        });
      }
    ];

    let InitKeyboardNavigator = (dispatch) => {
      let onKeyDown = (event) => {
        let formElements = ['INPUT', 'TEXTAREA', 'SELECT', 'OPTION'];
        if(formElements.includes(event.target.tagName)) return;

        switch(event.key) {
          case 'ArrowRight': dispatch(OpenNextChapter, +1); break;
          case 'ArrowLeft': dispatch(OpenNextChapter, -1); break;
          case 'Backspace': dispatch(ShowRecentBooks); break;
          default: break;
        }
      };
      addEventListener('keydown', onKeyDown);
      return () => removeEventListener('keydown', onKeyDown);
    };

    let InitCommandPalette = async (dispatch) => {
      onKey('Cmd+K', ToggleCommandPalette)(dispatch);
      onKey('Escape', [ToggleCommandPalette, { open: false }])(dispatch);

      await nextTick();
      let dialog = document.querySelector('#command-palette');
      onKey('ArrowUp', SelectPrevCommand, { target: dialog })(dispatch);
      onKey('ArrowDown', SelectNextCommand, { target: dialog })(dispatch);
    };

    let ToggleCommandPalette = (state, options) => {
      let open = options?.open != null ? !!options.open : !state.commandPalette.open;
      return [
        {
          ...state,
          commandPalette: {
            ...state.commandPalette,
            open,
          }
        },
        async (dispatch) => {
          if(open) {
            await nextTick();
            document.querySelector('#command-palette input').select();
            dispatch(HighlightMatches);
          }
        }
      ];
    };

    let SelectCommand = (state, index) => [
      {
        ...state,
        commandPalette: {
          ...state.commandPalette,
          selectedIndex: index,
        }
      },
      async () => {
        await nextTick();

        //scroll selected command into view
        let ul = document.querySelector('#command-palette ul');
        if (!ul) return;
        let li = ul.querySelector('li.selected');
        if (li.offsetTop < ul.scrollTop) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop });
        } else if (ul.scrollTop + ul.clientHeight < li.offsetTop + li.clientHeight) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop + li.clientHeight - ul.clientHeight });
        }
      }
    ];

    let SelectNextCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex + 1];
    let SelectPrevCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex - 1];

    let SetCommandQuery = (state, q) => ({
      ...state,
      commandPalette: {
        ...state.commandPalette,
        q: q.trim().toLowerCase(),
      },
    });

    let ExecuteSelectedCommand = state => state;
    let HighlightMatches = (state) => [
      state,
      async () => {
        await nextTick();

        let ranges = [];
        let q = state.commandPalette.q;
        document.querySelectorAll('#command-palette a').forEach(el => {
          let text = el.firstChild;
          let match = latinize(text.textContent).toLowerCase();
          if(match.includes(q)) {
            let start = match.indexOf(q);
            let end = start + q.length;
            let range = new Range();
            range.setStart(text, start);
            range.setEnd(text, end);
            ranges.push(range);
          }
        });
        let hl = new Highlight(...ranges);
        CSS.highlights.set('match', hl);
      }
    ];

    let MultipleActions = (state, actions) => [
      state,
      async (dispatch) => {
        for(let action of actions) {
          await nextTick();
          dispatch(...[].concat(action));
        }
      }
    ];

    let nextTick = async () => {
      await new Promise(resolve => requestAnimationFrame(resolve));
      await new Promise(resolve => requestAnimationFrame(resolve));
    };

    let onKey = (key, action, options) => (dispatch) => {
      let el = options?.target || window;
      let onKeyDown = (event) => {
        let opts = key.toLowerCase().split('+').reduce((opts, k) => {
          switch(k) {
            case 'ctrl':
            case 'shift':
            case 'alt':
              opts[k + 'Key'] = true;
              break;
            case 'cmd':
            case 'win':
            case 'super':
              opts.metaKey = true;
              break;
            default:
              opts.key = k;
          }
          return opts;
        }, {});
        if(event.key.toLowerCase() == opts.key.toLowerCase() && ['metaKey', 'ctrlKey', 'shiftKey', 'altKey'].every(f => Boolean(event[f]) == Boolean(opts[f]))) {
          event.preventDefault();
          dispatch(action);
        }
      };
      el.addEventListener('keydown', onKeyDown);
      return () => el.removeEventListener('keydown', onKeyDown);
    };

    let LoadSettings = (state) => [
      state,
      async (dispatch) => {
        let settings = {};
        let cursor = await state.db.transaction('settings').store.openCursor();
        while (cursor) {
          settings[cursor.key] = cursor.value;
          cursor = await cursor.continue();
        }
        dispatch(ApplySettings, settings);
      }
    ];
    let ApplySettings = (state, settings) => [
      { ...state, settings: { ...state.settings, ...settings } },
      () => {
        for (let [key, value] of Object.entries(settings)) {
          document.documentElement.dataset[key] = (value ?? '');
        }
      }
    ];
    let SaveSettings = (state, settings) => [
      state,
      async (dispatch) => {
        dispatch(ApplySettings, settings);

        let tx = state.db.transaction('settings', 'readwrite');
        await Promise.all([
          ...Object.entries(settings).map(([key, value]) => {
            document.documentElement.dataset[key] = (value || '');
            return tx.store.put(value, key);
          }),
          tx.done,
        ]);
      }
    ];

    let LoadRecentBooksDone = (state, { files }) => ({ ...state, files });
    let LoadRecentBooks = (state) => [
      state,
      async (dispatch) => {
        let files = await state.db.getAll('files');
        files.sort((a, z) => a.name.localeCompare(z.name, 'vi-VN', { sensitivity: 'accent' }));
        dispatch(LoadRecentBooksDone, { files });
      }
    ];

    let LoadProgressDone = (state, { progress }) => ({ ...state, progress });
    let LoadProgress = (state) => [state, async (dispatch) => {
      let progress = {};
      let cursor = await state.db.transaction('progress').store.openCursor();
      while (cursor) {
        progress[cursor.key] = cursor.value;
        cursor = await cursor.continue();
      }
      dispatch(LoadProgressDone, { progress });
    }];

    let LoadRecentBook = (state) => [
      state,
      (dispatch) => {
        let bookId = state.router.get('book');
        let chapterId = state.router.get('chapter');
        if (bookId) {
          dispatch(OpenBook, { bookId, chapterId })
        }
      }
    ];

    let OpenBookDone = (state, { book, chapter }) => [
      { ...state, book, chapter },
      (dispatch) => {
        if (state.book?.id == book.id)
          state.router.replace({ book: book.id, chapter: chapter.id });
        else
          state.router.push({ book: book.id, chapter: chapter.id });

        document.title = [...new Set([book.name, chapter.title])].join(' | ');

        requestAnimationFrame(() => {
          scroll(0, 0);

          //scroll bookmark into view
          let bookmark = document.querySelector('nav .active');
          let nav = document.querySelector('nav');
          let bookmarkRect = bookmark.getBoundingClientRect();
          let isOutOfView = bookmarkRect.top < 0 || nav.clientHeight < bookmarkRect.bottom;
          if (isOutOfView) bookmark.scrollIntoView({ block: 'center' });
        });
      }
    ];
    let OpenBook = (state, { bookId, chapterId, migrate = true, retry = true }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [book, chapter] = await Promise.all([
          state.db.get('books', bookId),
          state.db.get('chapters', bookId + '/' + chapterId),
        ]);
        if (!book) {
          console.info('Book not found:', { book, chapter });
          if (migrate) dispatch(RefreshBook, { bookId, onSuccess: [OpenBook, { bookId, chapterId, migrate: false, retry }] });
          return
        }
        if (!chapter) {
          console.info('Chapter not found:', { bookId, chapterId });
          if (retry) {
            chapterId = book.chapters[0].id;
            dispatch(OpenBook, { bookId, chapterId, retry: false });
          }
          return;
        }

        let chapters = [...book.chapters];
        let chapterIndex = chapters.findIndex(c => c.id == chapter.id);
        if (chapterIndex < 0) chapterIndex = 0;
        chapters[chapterIndex] = chapter;

        dispatch(LoadNames, { bookId: book.id });
        dispatch(OpenBookDone, { book, chapter });
        dispatch(ToggleCommandPalette, { open: false });
        clearTimeout(window.saveProgressTimer);
        window.saveProgressTimer = setTimeout(() => {
          dispatch(SaveProgress, { book, chapter });
        }, 10000);
      }
    ];

    let ToggleNamesEditor = (state, { open }) => ({ ...state, namesEditor: { ...state.namesEditor, open } });
    let SetNames = (state, names) => ({ ...state, namesEditor: { ...state.namesEditor, names } });
    let SaveNames = (state, { bookId, names }) => [state, async (dispatch) => {
      names = names.trim() + '\n';
      await state.db.put('names', names, bookId);
    }];
    let LoadNames = (state, { bookId }) => [state, async (dispatch) => {
      let names = await state.db.get('names', bookId);
      dispatch(SetNames, names);
      dispatch(HighlightNames);
    }];
    memoize(function correctNames(content, names) {
      if(!names) return content;
      names = names.split('\n');
      // add short name automatically
      for(let name of names) {
        if(name.match(/->|‚Üí/)) continue;
        name = name.split(/\s/);
        if(name.length == 3 || name.length == 4) names.push(name.at(-2) + ' ' + name.at(-1));
      }
      for(let name of names) {
        name = name.trim();
        if (!name) continue;
        let [from, to] = name.split(/->|‚Üí/).map(n => n?.trim());
        if(to != undefined) {
          to = useCase(from, to);
        } else {
          from = name;
          to = titleCase(name);
        }
        if(from) {
          let fromRegex = new RegExp(`(?<=^|[^\\p{L}])${from}(?=[^\\p{L}]|$)`, 'gui');
          content = content.replaceAll(fromRegex, name => {
            if(typeof to == 'function') name = to(name);
            else name = to;
            name = name.split(' ').map(w => {
              return toCase({
                'm∆∞a': 'v≈©',
                'nh·∫π': 'khinh',
                'm√¢y': 'v√¢n',
              }[w.toLowerCase()] || w, getCase(w));
            }).join(' ');
            return name;
          });
        }
      }
      return content;
    });
    let HighlightNames = (state) => [state, async () => {
      await nextTick();

      CSS.highlights.clear();

      // names from editor
      let knowNames = [];
      if(state.namesEditor.names) {
        let names = (state.namesEditor.names || '').split('\n');
        // add short name automatically
        for(let name of names) {
          if(name.match(/->|‚Üí/)) continue;
          name = name.trim();
          name = name.split(/\s/);
          if(name.length == 3 || name.length == 4) names.push(name.at(-2) + ' ' + name.at(-1));
        }
        for(let name of names) {
          name = name.trim();
          if (!name) continue;
          let [from, to] = name.split(/->|‚Üí/).map(n => n?.trim());
          if(to == undefined) {
            from = name;
            to = titleCase(name);
          }
          if(to && getCase(to) != 'lower') {
            to = to.split(' ').map(w => {
              return toCase({
                'm∆∞a': 'v≈©',
                'nh·∫π': 'khinh',
                'm√¢y': 'v√¢n',
                'm·∫∑t': 'nhan',
              }[w.toLowerCase()] || w, getCase(w));
            }).join(' ');
            knowNames.push(to);
          }
        }
      }

      // collect names
      let nameRegex = buildRegex([
        knowNames.join('|'),
        /{NameBegin}{Word}(\s{Word}){1,3}/,
        /{wb}a {Word}(?!{Word})/,
        /{NameBegin}({Word} )?{Word} (ba( ba)?|m·ª• m·ª•|m·∫π|th√∫c|di|ca( ca)?|t·ª∑( t·ª∑)?|t·ªïng|lang|n√¥|b√°( b√°)?|b√° ph·ª•|b√° m·∫´u|ƒë·∫°i t·ª∑|ƒë·∫°i ca|l√£o b√†){wb}/,
        /c√¥ c√¥|th√∫c th√∫c|b√° b√°|th·∫©m th·∫©m|nh·∫°c ph·ª•|nh·∫°c m·∫´u|b√° ph·ª•|b√° m·∫´u/,
        /(ti·ªÉu|l√£o) {Word}(?!{wb}{Word})( t·ª≠)?/,
      ], {
        'wb': /$|(?<=[^\p{L}])|(?=[^\p{L}])/,
        'Upper': /\p{Lu}/,
        'Lower': /\p{Ll}/,
        'Word': /{wb}{Upper}{Lower}*{wb}/,
        'NameBegin': /(?<!^|[.:"'!?()[\]] ?|{Word} )/,
      }, 'gu');
      let names = new Set();
      document.querySelectorAll('article p, nav a').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          for(let match of el.textContent.matchAll(nameRegex)) {
            let name = match[0];
            names.add(name);
            name = name.split(/\s/);
            if(name.length == 3 || name.length == 4) names.add(name.at(-2) + ' ' + name.at(-1));
          }
        });
      });
      names = [...names].sort((a, z) => {
        return z.length - a.length;
      });
      //console.log({names})

      // create ranges;
      nameRegex = buildRegex([
        '{wb}(' + [...names].join('|') + '){wb}',
      ], {
        'wb': /^|$|(?<=[^\p{L}])|(?=[^\p{L}])/,
      }, 'gui');
      //console.log('nameRegex:', nameRegex);
      let ranges = {};
      document.querySelectorAll('article p, nav a').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          for(let match of el.textContent.matchAll(nameRegex)) {
            let range = new Range();
            range.setStart(el, match.index);
            range.setEnd(el, match.index + match[0].length);
            let nameId = match[0].toLowerCase();
            if(!ranges[nameId]) ranges[nameId] = [];
            ranges[nameId].push(range);
            //console.debug('HighlightNames', 'found', {
            //  name: match[0],
            //  excerp: el.textContent.slice(Math.max(0, match.index - 50), match.index + match[0].length + 50),
            //  nameId,
            //  range,
            //});
          }
        });
      });

      // merge sub ranges
      let nameIds = Object.keys(ranges).sort((a, z) => z.length - a.length);
      //console.debug(Object.keys(ranges));
      for(let nameId in ranges) {
        let fullNameId = nameIds.find(id => id.endsWith(' ' + nameId));
        if(fullNameId) {
          ranges[fullNameId].push(...ranges[nameId]);
          delete ranges[nameId];
        }
      }
      //console.debug(Object.keys(ranges));
      //console.debug((ranges));

      for(let nameId in ranges) {
        let hash = ((hashCode(nameId) % 360) + 360) % 360;
        let color = chromaJs.hcl(hash, 100, 70);
        let styleId = 'hl-' + hash;
        let highlight = new Highlight();
        for(let range of ranges[nameId]) {
          highlight.add(range);
          //console.debug('HighlightNames', 'highlight', range.toString(), {
          //  nameId,
          //  range,
          //  color,
          //  styleId,
          //});
        }
        CSS.highlights.set(styleId, highlight);
        let styleEl = document.head.querySelector(`style[name="${styleId}"]`);
        if(!styleEl) {
          styleEl = document.createElement('style');
          styleEl.setAttribute('name', styleId);
          // styleEl.textContent = `::highlight(${styleId}) { text-decoration: underline 5px solid ${color} !important; text-underline-offset: 6px; text-decoration-skip-ink: none; }`;
          styleEl.textContent = `::highlight(${styleId}) { color: ${color} !important; }`;
          document.head.appendChild(styleEl);
        }
      }
    }];

    let OpenNextChapter = (state, indexDelta = 1) => [
      state,
      (dispatch) => {
        let chapterIndex = state.book.chapters.findIndex(c => c.id == state.chapter.id);
        let nextChapter = state.book.chapters[chapterIndex + indexDelta];
        if (nextChapter) {
          dispatch(OpenBook, { bookId: state.book.id, chapterId: nextChapter.id });
        }
      }
    ];

    let SaveProgressDone = (state, { book, progress }) => ({ ...state, progress: { ...state.progress, [book.id]: progress } });
    let SaveProgress = (state, { book, chapter }) => {
      return [
        state,
        async (dispatch) => {
          let progress = (await state.db.get('progress', book.id) || {});
          progress.chapterId = chapter.id;
          progress.chapterIndex = book.chapters.findIndex(c => c.id == chapter.id) + (book.chapters[0].id ? 1 : 0);
          progress.chapterCount = (book.chapters[0].id ? book.chapters.length : book.chapters.length - 1);
          progress.updatedAt = new Date().toISOString();
          await state.db.put('progress', progress, book.id);
          dispatch(SaveProgressDone, { book, progress });
        }
      ];
    };

    let InitDropzone = (state) => [
      state,
      (dispatch) => {
        addEventListener('dragenter', event => { event.preventDefault(); });
        addEventListener('dragover', event => { event.preventDefault(); });
        addEventListener('drop', event => {
          event.preventDefault();
          let files = [...event.dataTransfer.files].filter(file => file.type == 'text/plain');
          dispatch(StoreFiles, { files });
        });
      }
    ];

    let StoreFilesDone = (state, { files }) => [
      state,
      async (dispatch) => {
        //refresh recent books in state
        dispatch(LoadRecentBooks);

        let filesOpenInNewTab = files;
        let fileOpenInCurrentTab = null;
        if(state.book) {
          //if this book is already open, open other files in new tabs
          fileOpenInCurrentTab = files.find(file => (Book(file).id == state.book.id));
          filesOpenInNewTab = files.filter(file => (file != fileOpenInCurrentTab));
        } else {
          //if no book is open, open the first file in current tab, other files in new tabs
          [fileOpenInCurrentTab, ...filesOpenInNewTab] = files;
        }

        if(fileOpenInCurrentTab) {
          let book = Book(fileOpenInCurrentTab);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          state.router.push({ book: book.id, chapterId });
          dispatch(OpenBook, { bookId: book.id, chapterId });
        }
        for(let { file } of filesOpenInNewTab) {
          let book = Book(file);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          window.open(`#book=${book.id}&chapter=${chapterId}`, '_blank');
        }
      }
    ];
    let StoreFiles = (state, { files: localFiles, fileContents }) => [
      state,
      async (dispatch) =>  {
        let readFile = (localFile) => new Promise(resolve => {
          let reader = new FileReader();
          reader.addEventListener('load', event => {
            let file = {
              name: localFile.name,
              size: localFile.size,
            };
            let fileContent = event.target.result;
            resolve({ file, fileContent });
          });
          reader.readAsText(localFile);
        });

        let files = [];
        for (let localFile of localFiles) {
          files.push(await readFile(localFile));
        }

        dispatch(StoreBooks, { files, onSuccess: [StoreFilesDone, { files }] });
        /**
        for (let i = 0; i < localFiles.length; i++) {
          let reader = new FileReader();
          reader.addEventListener('load', async event => {
            fileContents[i] = event.target.result;
            files[i] = {
              name: localFiles[i].name,
              size: localFiles[i].size,
            };

            let book = Book(files[i]);
            let existingFile = await state.db.get('files', book.id);
            if (existingFile?.size != files[i].size) {
              book = Book(files[i], fileContents[i]);
              dispatch(SaveProgress, { book, chapter: book.chapters[0] });
              updated[i] = true;
            }

            let tx = state.db.transaction(['files', 'fileContents'], 'readwrite');
            await Promise.all([
              tx.objectStore('files').put(files[i], book.id),
              tx.objectStore('fileContents').put(fileContents[i], book.id),
              tx.done,
            ]);

            dispatch(StoreBook, { bookId: book.id });
            storedCount++;

            if (storedCount == localFiles.length) {

            }
          });
          reader.readAsText(localFiles[i]);
        }
        /**/
      },
    ];

    let StoreBooks = (state, { files, onSuccess }) => [
      state,
      async (dispatch) => {
        let chapterKeys = await state.db.getAllKeys('chapters');

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          ...files.flatMap(({ file, fileContent }) => {
            console.log('new Book');
            let book = Book(file, fileContent);
            return [
              tx.objectStore('files').put(file, book.id),
              tx.objectStore('fileContents').put(fileContent, book.id),
              tx.objectStore('books').put(book.toJSON(), book.id),
              ...chapterKeys.filter(k => k.startsWith(book.id + '/')).map(k => tx.objectStore('chapters').delete(k)),
              ...book.chapters.map(c => tx.objectStore('chapters').put(c.toJSON(), book.id + '/' + c.id)),
            ];
          }),
          tx.done,
        ]);

        if (onSuccess) dispatch(...onSuccess);
      }
    ];

    let RefreshBook = (state, { bookId, onSuccess }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [file, fileContent] = await Promise.all([
          state.db.get('files', bookId),
          state.db.get('fileContents', bookId),
        ]);
        if (!file || !fileContent) {
          console.info('File not found:', { bookId, file, fileContent });
          return;
        }

        if (!onSuccess) onSuccess = [OpenBook, { bookId, chapterId: state.chapter.id }];

        dispatch(StoreBooks, {
          files: [{ file, fileContent }],
          onSuccess,
        });
      }
    ];

    let DeleteBookDone = (state, { bookId }) => ({ ...state, files: state.files.filter(file => Book(file).id != bookId) });
    let DeleteBook = (state, { bookId }) => [
      state,
      async (dispatch) => {
        let chapterKeys = (await state.db.getAllKeys('chapters')).filter(k => k.startsWith(bookId + '/'));

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          tx.objectStore('files').delete(bookId),
          tx.objectStore('fileContents').delete(bookId),
          tx.objectStore('books').delete(bookId),
          ...chapterKeys.map(k => tx.objectStore('chapters').delete(k)),
          tx.done,
        ]);

        dispatch(DeleteBookDone, { bookId });
      }
    ];

    let ShowRecentBooks = (state) => {
      if (!state.book) return state;
      return [
        { ...state, book: null, chapter: null },
        (dispatch) => {
          clearTimeout(window.saveProgressTimer);
          state.router.push({});
          document.title = 'Text Reader';
          requestAnimationFrame(() => {
            scroll(0, 0);
          });
          dispatch(ToggleCommandPalette, { open: false });
        }
      ];
    };

    let sizeFormatter = new Intl.NumberFormat(undefined, { notation: 'compact', style: 'unit', unit: 'byte', unitDisplay: 'narrow' });
    let formatSize = sizeFormatter.format.bind(sizeFormatter);

    let dateFormatter = new Intl.RelativeTimeFormat();
    let formatDate = (iso) => {
      if(!iso) return;
      let diff = (Date.now () - new Date(iso)) / 1000;
      for (let [unit, seconds] of Object.entries({
        months: 30 * 24 * 60 * 60,
        days: 24 * 60 * 60,
        hours: 60 * 60,
        minutes: 60,
        seconds: 0,
      })) {
        if (diff >= seconds) return dateFormatter.format(-Math.round(diff / (seconds || 1)), unit);
      }
    };

    app({
      init: [
        {
          router: new HashRouter(),
          db: null,
          files: [],
          book: null,
          chapter: null,
          progress: {},
          settings: {
            sort: {
              field: 'updatedAt',
              direction: 'desc'
            }
          },
          commandPalette: {
            open: false,
            q: '',
            selectedIndex: 0,
          },
          namesEditor: {
            open: false,
            names: '',
            form: {
              names: '',
            },
          },
        },
        (dispatch) => {
          dispatch(InitRouter);
          dispatch(InitTheme);
          dispatch(InitDb);
          dispatch(InitDropzone);
        }
      ],
      dispatch: (dispatch) => {
        return (action, payload) => {
          if (!action) return;

          if (typeof action == 'function' && action.name.match(/^[A-Z]/)) {
            let log = [action.name];
            if (payload !== undefined) log.push(payload);
            //console.warn(...log);
          }

          dispatch(action, payload);
        };
      },
      subscriptions: (state) => [
        [InitKeyboardNavigator],
        [InitCommandPalette],
      ],
      node: document.body,
      view: ({ router, files, book, chapter, progress, settings, commandPalette, namesEditor }) => {
        let fixNames = text => correctNames(text, namesEditor.names);
        let cachedCommands = window.cachedCommands = (window.cachedCommands || new Map());
        let commands = [], selectedCommand, commandKey;
        if(!book) {
          commands = simpleCache({
            key: 'commands/books',
            fallbackValue: [],
            getHash() { return files.length; },
            getValue() {
              return files.map((file, index) => {
                let book = Book(file);
                let { chapterId } = (progress[book.id] || {});
                return {
                  label: book.name,
                  action: OpenBook,
                  payload: { bookId: book.id, chapterId },
                  term: latinize(book.name).toLowerCase(),
                };
              });
            },
          });
        } else {
          commands = simpleCache({
            key: 'commands/books/' + book.id,
            fallbackValue: [],
            getHash() {
              let file = files.find(f => Book(f).id == book.id);
              return file.size;
            },
            getValue() {
              return book.chapters.map(chapter => ({
                label: fixNames(chapter.title),
                action: OpenBook,
                payload: { bookId: book.id, chapterId: chapter.id },
                term: latinize(chapter.title).toLowerCase(),
              }));
            },
          });
        }
        commands = commands.filter(cmd => cmd.term.includes(commandPalette.q)) ?? [];
        selectedCommand = commands[(commandPalette.selectedIndex + commands.length) % commands.length];
        return (
          h('body', {}, [
            h('nav', {}, [
              (book?.chapters?.length > 0) && (
                h('ol', { start: 0 }, [
                  ...book.chapters.map(c => (
                    h('li', { class: { active: c.id == chapter.id } }, [
                      h('a', {
                        href: router.route({ book: book.id, chapter: c.id }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId: c.id }];
                        },
                        title: fixNames(c.title),
                      }, [
                        text(fixNames(c.title))
                      ])
                    ])
                  ))
                ])
              )
            ]),
            !book && (
              h('div', { class: 'table' }, [
                h('a', {
                  class: 'th text-left',
                  'data-sort': settings.sort.field == 'name' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'name', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('File'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'size' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'size', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Size'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'chapterCount' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'chapterCount', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Chapters'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'updatedAt' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'updatedAt', direction = 'desc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Date'))),
                h('span', { class: 'th' }, h('span', {})),
                ...files.sort((a, z) => {
                  let { field, direction } = settings.sort;
                  let A = Book(a), Z = Book(z);
                  let result;
                  if (field == 'name') {
                    result = A.name.localeCompare(Z.name, 'vi-VN', { sensitivity: 'accent' });
                  } else if (field == 'size') {
                    result = a[field] - z[field];
                  } else if (field == 'updatedAt') {
                    a = new Date(progress[A.id]?.[field] || 0);
                    z = new Date(progress[Z.id]?.[field] || 0);
                    result = a - z;
                  } else if (field == 'chapterCount') {
                    result = (progress[A.id]?.[field] || 1) - (progress[Z.id]?.[field] || 1);
                  }
                  if ((direction == 'desc') && (result != 0)) result = -result;
                  return result;
                }).flatMap(file => {
                  let book = Book(file);
                  let { chapterId, chapterIndex, chapterCount, updatedAt } = (progress[book.id] || {});
                  return [
                    h('div', { class: 'td' }, [
                      h('a', {
                        class: 'name',
                        href: router.route({ book: book.id, chapter: chapterId }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId }];
                        }
                      }, [
                        text(book.name)
                      ]),
                      book.description && (
                        h('small', { class: 'desc' }, text(book.description))
                      )
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatSize(file.size)))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(!chapterCount ? '-' : `${chapterIndex}/${chapterCount}`))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatDate(updatedAt) || '-'))
                    ]),
                    h('div', { class: 'td' }, [
                      h('a', { class: 'delete', onclick: [DeleteBook, { bookId: book.id }] }, [
                        h('small', {}, text('delete'))
                      ])
                    ])
                  ]
                })
              ])
            ),
            chapter && (
              h('main', {}, [
                h('article', {}, [
                  ...fixNames(chapter.content).split(/\n|<\/?\w+>/gi).map(line => {
                    if (/^[-]+$/.test(line)) return h('hr', {});
                    if (/^[^\p{L}\p{N}"]+$/u.test(line)) return h('p', { class: 'text-center indent-none' }, text(line));
                    let content = [], m;
                    while ((m = /https?:\/\/\S+/.exec(line))) {
                      if (m.index > 0) content.push(text(line.slice(0, m.index)));
                      content.push(h('a', { href: m[0], target: '_blank' }, [text(m[0])]));
                      line = line.slice(m.index + m[0].length);
                    }
                    if (line) content.push(text(line));
                    // if (/^"/.test(line)) return h('p', {}, h('em', {}, text(line)));
                    return h('p', {}, content);
                  })
                ])
              ])
            ),
            h('aside', { class: 'settings' }, [
              chapter && (
                h('div', {}, [
                  h('a', {
                    class: 'close',
                    href: router.route({}),
                    onclick: (_, event) => {
                      event.preventDefault();
                      return [ShowRecentBooks];
                    },
                    title: 'Back to bookshelf',
                  })
                ])
              ),
              h('div', { class: 'colors' }, ['white', 'sepia', 'gray', 'night', 'rose-pine', 'rose-pine-moon', 'rose-pine-dawn', 'solarized', 'kiselevka'].map(color => (
                h('button', {
                  class: [color, { 'checked:light': settings['color:light'] == color, 'checked:dark': settings['color:dark'] == color }],
                  onclick: () => [SaveSettings, { [`color:${getColorScheme()}`]: color }],
                  title: `Theme: ${color}`,
                })
              ))),
              h('div', { class: 'paper-size' }, ['sm', 'md', 'lg', 'xl'].map(size => (
                h('button', {
                  class: ['size', size, { selected: settings.paperSize == size }],
                  onclick: [SaveSettings, { paperSize: size }],
                  title: `Page size: ${size}`,
                }, text(size))
              ))),
              chapter && (
                h('div', {}, [
                  h('button', {
                    class: 'refresh',
                    onclick: [RefreshBook, { bookId: book.id, chapterId: chapter.id }],
                    title: 'Refresh book',
                  }),
                  h('button', {
                    class: 'zen',
                    onclick: [SaveSettings, { zen: !settings.zen }],
                    title: 'Toggle Zen Mode',
                  }),
                  h('button', {
                    class: 'names-editor',
                    onclick: [ToggleNamesEditor, { open: true }],
                    title: 'Edit names',
                  }),
                ])
              )
            ]),
            h('dialog', { id: 'command-palette', open: commandPalette.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [selectedCommand.action, selectedCommand.payload],
                    [ToggleCommandPalette, { open: false }],
                  ]];
                }
              }, [
                h('input', {
                  oninput: (_, event) => [MultipleActions, [
                    [SetCommandQuery, event.target.value],
                    [SelectCommand, 0],
                    [HighlightMatches],
                  ]],
                }),
                h('input', { type: 'submit', hidden: true }),
              ]),
              //commandPalette.q && h('style', {}, text(`#command-palette [data-term]:not([data-term*="${commandPalette.q}"]) { display: none; }`)),
              commands.length > 0 && h('ul', {}, [
                ...commands.map((command, index) => (
                  h('li', {
                    'data-term': command.term,
                    class: { selected: command == selectedCommand }
                  },
                    h('a', {
                      href: router.route({ book: command.payload.bookId, chapter: command.payload.chapterId }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [MultipleActions, [
                          [SelectCommand, index],
                          [command.action, command.payload],
                          [ToggleCommandPalette, { open: false }],
                        ]]
                      },
                      title: command.label,
                    },[
                      text(command.label),
                    ])
                  )
                ))
              ])
            ]),
            h('dialog', { id: 'names-editor', open: namesEditor.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [ToggleNamesEditor, { open: false }],
                    [SaveNames, { bookId: book.id, names: namesEditor.names }],
                    [HighlightNames],
                  ]];
                }
              }, [
                h('textarea', {
                  value: namesEditor.names,
                  oninput: (_, event) => [SetNames, event.target.value],
                  onkeydown: (_, event) => {
                    if (event.key == 'Escape') {
                      return [ToggleNamesEditor, { open: false }];
                    } else if (event.key == 'Enter' && event.metaKey) {
                      return [MultipleActions, [
                        [ToggleNamesEditor, { open: false }],
                        [SaveNames, { bookId: book.id, names: namesEditor.names }],
                        [HighlightNames],
                      ]];
                    }
                  },
                }),
                h('button', { type: 'submit' }, [text('Save')]),
              ])
            ])
          ])
        );
      }
    });

    function Book(file, fileContent, chapters) {
      let id, name, description;
      if (file?.name) {
        name = /(?<name>^[^(]*).*?\.txt/.exec(file.name.normalize()).groups.name.trim();
        description = /(?<description>\(.*)\.txt/.exec(file?.name.normalize())?.groups?.description?.trim();
        id = slug(name);
      }
      if (fileContent) {
        fileContent = normalizeFileContent(fileContent);
        // fileContent = titleizeHumanName(fileContent);
        chapters = extractChapters(name, fileContent, { name });
      }
      return {
        id,
        name,
        description,
        chapters,
        toJSON() {
          return {
            id,
            name,
            description,
            chapters: chapters.map(c => {
              c = c.toJSON();
              delete c.content;
              return c;
            }),
          }
        }
      };
    }

    function normalizeFileContent(text) {
      text = text.normalize();
      text = text.replace(/[\r\n]+/g, '\n');
      text = text.replace(/\t+/g, '\n');
      text = text.replace(/(?<=\S) {2,}(?=\p{Lu})/gu, '\n');
      text = text.replace(/(.+)/g, (s) => s.trim());
      text = text.replace(/^'([^']+)'$/gm, '"$1"');
      text = text.replace(/(\d)\s*(\.)\s*(\d)/gm, '$1$2$3');
      text = text.replace(/\s+([.,;:?!\]„Äë)])/gm, '$1');
      text = text.replace(/([([„Äê])\s+/gm, '$1');
      text = text.replace(/([:‚Äî]{2,})/gm, c => c.slice(0, 1));
      text = text.replace(/(:)[^\s\w]+\s*/gm, '$1 ');
      text = text.replace(/^\s*"\s+|\s+"\s*$/gm, '"');
      // text = text.replace(/(?<=[.,:] *)"\n/g, '\n"');
      //"QQ Group 712797052"
      text = text.replace(/\s?"?QQ Group \d+"?/gu, '');
      //t√¨m s√°ch a "Cu·ªôc ƒë·ªùi n√†y kh√¥ng ph·ª• di√™n ƒëu√¥i t√¨nh" c√° nh√¢n c·∫£i bi√™n
      text = text.replaceAll('  t√¨m s√°ch a "Cu·ªôc ƒë·ªùi n√†y kh√¥ng ph·ª• di√™n ƒëu√¥i t√¨nh" c√° nh√¢n c·∫£i bi√™n', '');
      text = text.replace(/\b(?<protocol>https?:)(?:\/\/)? (?<path>(?:\w+)(?:\. \w+)+(?:\/(?:(?:\. )?[\w\/])+)?)/gm, (...args) => {
        let { protocol, path } = args.pop();
        path = path.replace(/\s/g, '');
        if (protocol) return protocol + '//' + path;
        return path;
      });
      text = text.replaceAll('cha m·∫π v·ª£', 'm·∫π v·ª£');
      return text;
    }

    let printed = true;
    function Chapter(_, { chapters, filename, text }) {
      return {
        _,
        merged: 1,
        get title() {
          let originalTitle = _.title || _.titleShort;
          let title, titleBook, titleChap, phienNgoai, halfPre, halfPost;
          titleBook = this.book;
          if (/phi√™n ngo·∫°i/iu.test(_.text) && !/phi√™n ngo·∫°i/iu.test(originalTitle)) phienNgoai = 'Phi√™n ngo·∫°i';
          if (this.chapter != null) titleChap = this.chapType + ' ' + this.chapter;
          if (this.half && !originalTitle?.includes('(' + this.half + ')')) {
            if (_.halfType) halfPre = this.half + ':';
            else halfPost = '(' + this.half + ')';
          }
          title = [titleBook, phienNgoai, titleChap].filter(Boolean).join(' ');
          title = [title, (originalTitle || '').replace(/./, c => c.toUpperCase())].filter(Boolean).join(': ');
          title = [halfPre, title, halfPost].filter(Boolean).join(' ');
          if (!title) title = this.chapType + ' ' + (this.i + 1);
          if (!printed) {
            printed = true;
          }
          return title;
        },
        get i() {
          return chapters.indexOf(this);
        },
        get startIndex() {
          // return text.lastIndexOf('\n', _.index);
          return _.index;
        },
        get endIndex() {
          if (this.i == chapters.length-1) return text.length;
          return chapters[this.i + 1].startIndex;
        },
        get id() {
          return slug(this.title) + '-' + this.i;
        },
        get content() {
          return text.slice(this.startIndex, this.endIndex).trim();
        },
        get chapter() {
          return _.chapNum || _.chapText;
        },
        get chapNo() {
          if (this.chapter) return Number(this.chapter)
        },
        get chapType() {
          return _.chapType || 'Ch∆∞∆°ng'
        },
        get length() {
          return this.endIndex - this.startIndex;
        },
        get half() {
          return [_.halfType, _.halfNum || _.halfText].filter(Boolean).join(' ');
        },
        get halfNo() {
          if (_.halfNum) return Number(_.halfNum);
        },
        get halfType() {
          return _.halfType;
        },
        get bookType() {
          if (_.bookType) return _.bookType.toLowerCase().replace(/^./, c => c.toUpperCase());
        },
        get bookNo() {
          if (_.bookNum) return Number(_.bookNum);
          if (_.bookText) return Number(_.bookText);
        },
        get book() {
          if(_.bookNum || _.bookText) {
            return [_.bookType || 'Quy·ªÉn', Number(_.bookNum) || Number(_.bookText)].filter(Boolean).join(' ');
          }
        },
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            content: this.content,
          }
        }
      };
    }

    function extractChapters(filename, text, { name }) {
      let NUMERIC = '(\\d{1,4}(\\.\\d{1,2})*)';
      let NUMERIC_DECIMAL = '(\\d{1,4}(\\.\\d{1,2})+)';
      let LEAD_NUMERIC_WORDS = '(((th·∫≠p|b√°ch|thi√™n|v·∫°n) )?(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p))+';
      let TAIL_NUMERIC_WORDS = '(m∆∞·ªùi( (m·ªôt|hai|ba|b·ªën|lƒÉm|s√°u|b·∫£y|t√°m|ch√≠n))?|(hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n) m∆∞∆°i( (m·ªët|hai|ba|b·ªën|lƒÉm|s√°u|b·∫£y|t√°m|ch√≠n))?|m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n)|[MDCLXVI]+|(((th·∫≠p|b√°ch|thi√™n|v·∫°n) )?(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p))+';
      let NUMERIC_WORDS = `${LEAD_NUMERIC_WORDS}|${TAIL_NUMERIC_WORDS}`;
      let patterns = [
        /*
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 t·ª± ch∆∞∆°ng
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 th·ª© 01 ch∆∞∆°ng
        Xanh Bi·∫øc l·ªØ du ti√™n b·ªô 2 th·ª© 09 ch∆∞∆°ng
        „Äêxanh bi·∫øc l·ªØ du ti√™n b·ªô 2„Äë th·ª© 10 ch∆∞∆°ng ƒê√¥ng h·∫£i ti√™n c√°c (1)
        Xanh Bi·∫øc l·ªØ du ti√™n b·ªô 2 th·ª© 13 ch∆∞∆°ng N·ªØ ƒê·∫ø d√¢m t√¢m
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë Ch∆∞∆°ng 8:
        „ÄêCh∆∞∆°ng 8: T√¥ng m√¥n d√¢m lo·∫°n (nh·∫•t)„Äë
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë Ch∆∞∆°ng 6:
        „ÄêCh∆∞∆°ng 6: Ho√†ng th√†nh long ·∫£nh„Äë
        Th·ª© 02 ch∆∞∆°ng: Hong Kong
        Th·ª© 1 ch∆∞∆°ng ƒë·∫°i ngh·ªãch b·∫•t ƒë·∫°o √°i ƒë·ªì, nh∆∞ng l·∫°i hy v·ªçng ƒëem s∆∞ t√¥n d·∫°y d·ªó v√¨ song tu chuy√™n d·ª•ng ·∫•u th√™!
        Th·ª© 10 ch∆∞∆°ng, v√µ di·ªÖm h√≤a kh√¥ng r√µ th√¢n ph·∫≠n nam nh√¢n th√¥ng ƒë·ªìng c√πng v·ªõi tr·∫ßn san c√πng ca ca tr·∫ßn v·ª´a lo·∫°n lu√¢n ƒë·ªãt bi chuy·ªán x∆∞a
        „Äêm·∫π th√†nh gia b√™n trong b·∫£o m·∫´u con d√¢u„Äë(15) ho√†n
        Nh·ªã, thay ƒë·ªïi
        „Äêb·∫°n g√°i ƒë·ªá ƒë·ªá„Äë3
        "B·∫°n g√°i ƒë·ªá ƒë·ªá" 11
        Th∆∞·ª£ng (2)
        Ch√≠nh VƒÉn Ch∆∞∆°ng 07: Ch·ªânh qu√¢n
        Nh·∫•t, l·ªùi d·∫´n t∆∞·ªüng n√≥i ng·∫Øn g·ªçn, nh∆∞ng kh√¥ng bi·∫øt t·ª´ ƒë√¢u n√≥i l√™n.
        Th·ª© 34 ch∆∞∆°ng m·∫´u th∆∞·ª£ng c√¥ng l∆∞·ª£c (3.11) An N·∫∑c ti·∫øn b·ªánh vi·ªán
        ‚Äî Ch∆∞∆°ng 2: (d·ªãch n√≥ng th·ªÉ)‚Äî
        2020 nƒÉm th√°ng 1 6 ng√†y
        H·∫° b·ªô ‚Äî ch·ªã em y√™u nhau (l·ª•c hi h√≤a l·ª•c n·∫øu)
        „Äêm·∫π con„Äë(nh·ªã -- y√™u n√≥i h·∫øt)
        (nh·ªã -- y√™u n√≥i h·∫øt)
        ch. 1
        H·ªìi 1: Ng√¢y th∆° di·ªán m·∫°o Khuynh Th√†nh v·∫≠n giao mui xe th·ªã l√£o √îng ph·ªß ·∫•u t·ª≠ t·ª´ hu·ªá th·ª•c hi·ªÅn Hongkong
        Th·ª© 41-48 ch∆∞∆°ng
        */
        //Ch∆∞∆°ng 23:
        //Phi√™n ngo·∫°i Ch∆∞∆°ng 18:
        // '^(Phi√™n Ngo·∫°i )?CHAP_TYPE CHAP_NUM:$',
        //Ch∆∞∆°ng 1: T√¢n ni√™n ƒë·∫∑c bi·ªát thi√™n (th∆∞·ª£ng)
        //Phi√™n Ngo·∫°i Ch∆∞∆°ng 8: Treo ƒë·∫ßu d√™ b√°n th·ªãt ch√≥
        //...ƒë√£ ng·ªß say. Ch∆∞∆°ng 59: m·∫π ph√°t hi·ªán ch√¢n t∆∞·ªõng
        //H·ªìi 2: ¬∑ ph·∫´n v≈© n·ªØ khinh th√¢n d·ª• ƒë·ªãch t√π, nhu v√∫ to th√°t t·ª≠ lo·∫°n t√¢m tr√≠
        '(^|(?<=\\W ))(Phi√™n Ngo·∫°i )?CHAP_TYPE CHAP_NUM([^\\p{L}\\p{N}\\n]+TITLE)?$',
        //Ng≈©
        //Hai m∆∞∆°i m·ªët
        '^CHAP_TEXT$',
        // (1)
        '^\\(CHAP_NUM\\)$',
        //8.1
        '^CHAP_NUM$',
        // (t·ª©)
        // (m∆∞·ªùi m·ªôt)
        '^\\(CHAP_TEXT\\)$',
        //Th·ª© 7 ch∆∞∆°ng m·∫´u th∆∞·ª£ng c√¥ng l∆∞·ª£c (1.7) ti·ªÉu ma n·ªØ ph·ª•c v·ª•
        // '^Th·ª© BOOK_NUM ch∆∞∆°ng ' + name + ' \\(CHAP_NUM\\)([: ]TITLE)?',
        //Th·ª© 31 ch∆∞∆°ng
        //T·∫≠p th·ª© nh·∫•t th·ª© 01 ch∆∞∆°ng th·∫•t ƒë·ªça v√°ch n√∫i ƒëen
        '^(BOOK_TYPE( th·ª©)? (BOOK_NUM|BOOK_TEXT) )?Th·ª© CHAP_NUM CHAP_TYPE([: ]TITLE)?',
        //[th·ª© 1 ch∆∞∆°ng]
        '^\\[th·ª© CHAP_NUM CHAP_TYPE\\]',
        //B·∫£y nƒÉm v·ª£ ch·ªìng g·∫ßn ba nƒÉm c√πng hai c√°i ƒë∆°n nam ƒë·ªá t·ª≠ chuy·ªán x∆∞a (5)
        '^' + name + ' \\(CHAP_NUM\\)',
        //2019-7-19 m∆∞·ªùi lƒÉm
        '^DATE CHAP_TEXT',
        //Ngo·∫°i truy·ªán nh·∫•t
        '^CHAP_TYPE CHAP_TEXT',
        //M∆∞·ªùi hai, n·ª≠a nƒÉm sau cu·ªôc s·ªëng v·∫´n ƒëang ti·∫øp t·ª•c. Ph·ªë x√° nh∆∞ tr∆∞·ªõc th√°i b√¨nh.
        '^CHAP_TEXT[,] TITLE$',
        //Quy·ªÉn th·ª© hai Ch∆∞∆°ng 11: M·ªπ m·∫´u c·∫ßu xin
        //T·∫≠p 6 Ch∆∞∆°ng 110: Nh√¢n thay m·ªõi trang
        '^BOOK_TYPE( th·ª©)? (BOOK_NUM|BOOK_TEXT) CHAP_TYPE CHAP_NUM: TITLE',
        //L·ªùi d·∫´n
        '^(?<title>CHAP_TYPE (cu·ªëi|k·∫øt)|t·ª± ch∆∞∆°ng|L·ªùi d·∫´n)$',
        //(Ch∆∞∆°ng 20: h√®n ch√≥ di·ªÖn ph∆∞·ª£ng (che gi·∫•u thi√™n 3)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE',
        //Phi√™n Ngo·∫°i hai m∆∞∆°i lƒÉm ch∆∞∆°ng
        '^(Phi√™n Ngo·∫°i )CHAP_TEXT CHAP_TYPE',
        //„Äê ƒë·ªça ph·ª• „Äë Ch∆∞∆°ng 2:: Khu·∫•t nh·ª•c phu nh√¢n
        '^„ÄêNAME„Äë CHAP_TYPE CHAP_NUM: TITLE',
        //„Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 th·ª© 08 ch∆∞∆°ng
        '^„ÄêNAME„Äë b·ªô BOOK_NUM th·ª© CHAP_NUM CHAP_TYPE',
        //Xanh bi·∫øc l·ªØ du ti√™n b·ªô 2 Ch∆∞∆°ng 8: S∆° ng·ªô b√≠ch du
        '^NAME b·ªô BOOK_NUM CHAP_TYPE CHAP_NUM: TITLE',
        //„Äêb·∫°n g√°i ƒë·ªá ƒë·ªá„Äë9
        '^„ÄêNAME„ÄëCHAP_NUM([: ]TITLE)?',
        //„Äêc√°c huynh ƒë·ªá lo·∫°n lu√¢n th·ªãnh y·∫øn„Äë(tam)
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(1)
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(18) ho√†n
        '^„ÄêNAME„Äë\\((CHAP_TEXT|CHAP_NUM)\\)( TITLE)?',
        //„Äêc·ªßa ta giang h·ªì„Äë(th·ª© 2 ch∆∞∆°ng)
        '^„ÄêNAME„Äë\\(th·ª© CHAP_NUM CHAP_TYPE\\)',
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(phi√™n ngo·∫°i) c·∫£nh ph·ªâ m·∫π con k√≠ch t√¨nh th∆∞·ª£ng k√≠nh
        '^„ÄêNAME„Äë(phi√™n ngo·∫°i) TITLE',
        //„Äêphi√™n ngo·∫°i thi√™n chi Di·ªáp Minh Hi t·ª± b·∫°ch„Äë(1)
        '„Äê(?=.*?phi√™n ngo·∫°i)(?<title>.*?)„Äë\\(CHAP_NUM\\)',
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(phi√™n ngo·∫°i) c·∫£nh ph·ªâ m·∫π con k√≠ch t√¨nh th∆∞·ª£ng k√≠nh
        '^„ÄêNAME„Äë\\(phi√™n ngo·∫°i\\) TITLE',
        //Ng∆∞·ªùi nh√† qu·∫ßn √°o Ch∆∞∆°ng 1: M·∫π d·ªã th∆∞·ªùng
        '^NAME CHAP_TYPE CHAP_NUM: TITLE',
        //N√≥n xanh m·∫∑c ta mang (nh·∫•t) kinh vi thi√™n nh√¢n
        '^NAME \\(CHAP_TEXT\\) TITLE',
        //(b·∫£n c≈©) d√¢m lo·∫°n gia ƒë√¨nh th·ª© 01 ch∆∞∆°ng: Sau khi tan l·ªõp ba ba √¢u y·∫øm
        'NAME th·ª© CHAP_NUM CHAP_TYPE: TITLE',
        //(16) A Ki·ªán n√≥i: N√†ng... N√†ng l√† ta... Mu·ªôi mu·ªôi
        '^\\(CHAP_NUM\\) TITLE',
        //..."√Çn, ta ƒë·ªÅu nghe ng∆∞∆°i!" (13)
        '(?<=\\W) \\(CHAP_NUM\\)$',
        //(14) nghi√™m h·∫°o t·∫°i sofa ph√≠a tr√™n th√≠ch kh√¥ng th·ªÉ t·ª± tho√°t ra ƒë∆∞·ª£c, nh·∫•t tinh m·∫∑c xong ƒë·ªì ng·ªß, sau ƒë√≥ ti·∫øp l·∫•y ƒëem nghi√™m h·∫°o √¥m ƒë·∫øn ch√¢n c·ªßa m√¨nh ph√≠a tr√™n, nh·∫π nh√†ng √¢u y·∫øm.
        '\\(CHAP_NUM\\)',
        //"2" h√†o m√¥n b√≠ m·∫≠t
        '^"\\s*CHAP_NUM\\s*"( TITLE)?',
        //"13 ch∆∞∆°ng k·∫øt"
        '^"CHAP_NUM TITLE"$',
        //T·∫≠p th·ª© hai th·ª© 36 ch∆∞∆°ng con tin uy hi·∫øp
        '^T·∫≠p th·ª© BOOK_TEXT th·ª© CHAP_NUM CHAP_TYPE TITLE$',
        //22)
        '^CHAP_NUM\\)$',
        //2,
        '^CHAP_NUM,$',
        //Ch∆∞∆°ng 157: (1)
        '^CHAP_TYPE CHAP_NUM: \\(HALF_NUM\\)',
        //T·ª± m·∫´u m·ªôt ng√†y (h·∫°)
        '^(?<!.*CHAP_TYPE.*TITLE) \\(HALF_TEXT\\)$',
        //Th·ª© 1002 ch∆∞∆°ng l·ªØ m·ªông ƒë·∫πp c·∫£nh nh√£ nh√†n b√° m·∫´u (nh·ªã)
        '^Th·ª© CHAP_NUM CHAP_TYPE TITLE',
        //ƒê·ªá nh·∫•t b·ªô t·ª© ƒë·∫°i m·ªπ n·ªØ chi ƒë·∫πp nh·∫•t th·ªã tr∆∞·ªüng d∆∞∆°ng ng∆∞ng bƒÉng (th∆∞·ª£ng)
        '^ƒê·ªá (BOOK_NUM|BOOK_TEXT) BOOK_TYPE TITLE \\(HALF_TEXT\\)',
        //B·ªô 2 t·ª© ƒë·∫°i m·ªπ n·ªØ chi kim b√†i ch·ªß tr√¨ d∆∞∆°ng ninh l√†m (h·∫°)
        '^BOOK_TYPE BOOK_NUM TITLE \\(HALF_TEXT\\)',
        //(Ch∆∞∆°ng 20: h√®n ch√≥ di·ªÖn ph∆∞·ª£ng (che gi·∫•u thi√™n 2)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE HALF_TEXT\\)',
        //ƒê·ªá 1 ch∆∞∆°ng: (M·∫π Mamako)
        //ƒê·ªá 8 ch∆∞∆°ng, ƒë·∫©y ng∆∞·ª£c ph·∫£n b·ªã ƒë·ªãt.
        '^(ƒê·ªá|th·ª©) CHAP_NUM CHAP_TYPE[,:]? TITLE',
        //Quy·ªÉn th·ª© hai thi·∫øt gi√°p phong v√¢n
        '^BOOK_TYPE( th·ª©)? (BOOK_NUM|BOOK_TEXT)( BOOK_TITLE)?$',
        //Th·ª© 4 cu·ªën ƒë·∫ø ƒë√¥ bi ca
        '^Th·ª© BOOK_NUM BOOK_TYPE BOOK_TITLE',
        //1.1 nh√¢n v·∫≠t ch√≠nh k√™u m≈©
        '^CHAP_NUM_DECIMAL TITLE$',
        //(4.25)G con m·∫π n√≥ du h·ªçc sinh
        '^\\(CHAP_NUM\\) ?TITLE$',
        //Ch∆∞∆°ng m∆∞·ªùi:
        '^CHAP_TYPE CHAP_TEXT:$',
        //Ch∆∞∆°ng ba m∆∞∆°i lƒÉm l·∫°i r√¨nh coi
        '^CHAP_TYPE CHAP_TEXT TITLE$',
        //Ba m∆∞∆°i t√°m ch∆∞∆°ng Tuy·∫øt Nhi t√¢n h√¥n
        '^CHAP_TEXT CHAP_TYPE TITLE$',
        //B·ªën m∆∞∆°i ch∆∞∆°ng
        '^CHAP_TEXT CHAP_TYPE$',
        //(tam) m·∫•y ng√†y k·∫ø ti·∫øp, m·∫π ng∆∞·ª£c l·∫°i kh√¥ng h∆∞·ªõng ƒë·∫øn L√Ω T∆∞ oa trong nh√† ch·∫°y, m·ªói ng√†y t·∫°i trong nh√† n·∫•u c∆°m mang ƒë·ª©a nh·ªè, t√¢m t√¨nh th∆∞·ª£ng c≈©ng kh√¥ng t·ªá.
        '^\\(CHAP_TEXT\\)',
        //(c√≤n ti·∫øp) m∆∞·ªùi ba (th∆∞·ª£ng) ƒë√£ x·∫£y ra chuy·ªán ‚Äî ba ch·ªØ n√†y b√¨nh th∆∞·ªùng l√† ch·ªâ ph√°t sinh kh√¥ng t·ªët s·ª± t√¨nh, chuy·ªán t·ªët nhi c≈©ng kh√¥ng c√≥ kh·∫£ nƒÉng d√πng n√†y ba t·ª±, h∆°n n·ªØa c√≥ th·ªÉ l·ªõn c√≥ th·ªÉ nh·ªè, nh·ªè ƒë·∫øn t·∫°i ban th∆∞·ª£ng ngh·ªãch ng·ª£m g√¢y s·ª± ƒë√πa gi·ª°n b·∫°n h·ªçc g√°i b·ªã l√£o s∆∞ ƒë√£ bi·∫øt, l·ªõn ƒë·∫øn hai qu·ªëc gia ph√°t sinh chi·∫øn tranh, ƒë·ªÅu c√≥ th·ªÉ k√™u ƒë√£ x·∫£y ra chuy·ªán.
        '^\\(c√≤n ti·∫øp\\) CHAP_TEXT \\(HALF_TEXT\\)',
        //M∆∞·ªùi ba (h·∫°) theo l·ªõn m·∫≠p gia trong nh√† ƒëi ra ta li·ªÅn h∆∞·ªõng ƒë·∫øn gia ƒëu·ªïi, th·∫≠m ch√≠ s·ª£ th·ªùi gian ƒëu·ªïi kh√¥ng k·ªãp ƒëi nhanh ch·∫°y, k·ª≥ th·∫≠t ta l√† kh√¥ng qu√° nguy·ªán √Ω h∆∞·ªõng ƒë·∫øn ch·ªó ƒë√≥ nghƒ©, n·ªôi t√¢m th·∫≠m ch√≠ c√≥ m·ªôt ch√∫t kh√°ng c·ª± c√°i √Ω nghƒ© n√†y, nh∆∞ng n·∫øu nh∆∞ hi·ªán th·ª±c ch√≠nh l√† nh∆∞ v·∫≠y ƒë√¢u.
        '^CHAP_TEXT \\(HALF_TEXT\\)',
        //(c√≤n ti·∫øp) m∆∞·ªùi b·∫£y ƒë√£ tr·∫£i qua nhi·ªÅu nh∆∞ v·∫≠y ly k·ª≥ s·ª± t√¨nh, ta cho r·∫±ng ch√≠nh m√¨nh ƒë√£ l√† ng∆∞·ªùi l·ªõn, t√≠nh l√† c√πng ƒë·∫°i nh√¢n c√≥ ch√∫t ch√™nh l·ªách, c≈©ng kh√¥ng c√≥ kh·∫£ nƒÉng kh√°c bi·ªát qu√° xa.
        '^\\(c√≤n ti·∫øp\\) CHAP_TEXT',
        //(c√≤n ti·∫øp)(m∆∞·ªùi m·ªôt) "Ti·ªÉu Ch√≠ ti·ªÉu L√¥i r·ªùi gi∆∞·ªùng ƒÉn c∆°m."
        '^\\(c√≤n ti·∫øp\\)\\(CHAP_TEXT\\)',
        //M∆∞·ªùi b·ªën "Ti·ªÉu Ch√≠ nh∆∞ th·∫ø n√†o c√≤n kh√¥ng c√≥ r·ªùi gi∆∞·ªùng, ng∆∞∆°i kh√¥ng g·ªçi h·∫Øn ƒÉn ƒëi·ªÉm t√¢m a."
        //'^CHAP_TEXT',
        //Ch∆∞∆°ng 1:
        '^CHAP_TYPE CHAP_NUM:',
        //„ÄêCh∆∞∆°ng 1:
        '^„ÄêCHAP_TYPE CHAP_NUM: TITLE',
        //22.
        '^CHAP_NUM\\.$',
        //09. Thi ch·∫°y
        '^CHAP_NUM\\. TITLE$',
        //ƒê·∫°i ph·ª•ng g√µ m√µ c·∫ßm canh nh√¢n chi xanh mi·∫øt #1 t√°c gi·∫£: H·ªë ni
        '^NAME #CHAP_NUM',
        //(h·∫°)
        '^\\(HALF_TEXT\\)$',
        //"B·∫°n g√°i ƒë·ªá ƒë·ªá" 11
        '^"NAME" CHAP_NUM$',
        //Th·ª© 1 ti·∫øt tay ngh·ªÅ ti·ªÉu t·ª≠ & Uzumaki Naruto
        '^(ƒê·ªá|th·ª©) HALF_NUM HALF_TYPE TITLE$',
        //Ti·∫øt th·ª© hai Hyuga Hinata
        //Ti·∫øt th·ª© nƒÉm: Naruto c·ª±c kh·ªï ng√†y
        '^HALF_TYPE th·ª© HALF_TEXT[:]? TITLE$',
        //Th·ª© b·∫£y ti·∫øt trƒÉm h√†o Ti·ªÉu Anh! M·ªôt c√¢u b·∫°ch c·∫•p
        //Th·ª© s√°u ti·∫øt: Hinata c·ª±c kh·ªï ng√†y
        //ƒê·ªá th·∫≠p nh·∫•t ti·∫øt Sasuke xanh bi·∫øc n√¥ thu·ªôc t√≠nh chuy·ªán l·ªõn h·∫•p th·ª• √°nh s√°ng!
        '^(ƒê·ªá|th·ª©) HALF_TEXT HALF_TYPE[:]? TITLE$',
        //„Äêh√†o hi·ªáp xanh bi·∫øc truy·ªán II„Äë
        '^„ÄêNAME BOOK_TEXT„Äë$',
        //„Äêch∆∞∆°ng k·∫øt, (L√£ ph√†m th·ªã gi√°c)„Äë
        '^„ÄêCHAP_TYPE CHAP_TEXT, \\(TITLE',
        //„Äêch∆∞∆°ng k·∫øt„Äë
        '^„ÄêCHAP_TYPE CHAP_TEXT„Äë$',
        //Ki·ªÅu th√™ chuy·ªán x∆∞a (nh·∫•t)
        '^NAME \\(CHAP_TEXT\\)$',
        //„Ää ki·ªÅu th√™ chuy·ªán x∆∞a „Äã2
        '^„Ää NAME „ÄãCHAP_NUM$',
        //#3 Ch∆∞∆°ng 3: D∆∞·ªõi √°nh trƒÉng chinh ph·ª•c
        '^#\\d+ Ch∆∞∆°ng CHAP_NUM: TITLE',
        //N√≥n xanh chi·∫øn th·∫ßn ng∆∞·ªùi ·ªü r·ªÉ (Ch∆∞∆°ng 5: ph·ªëi ƒë·ªì b·∫£n)
        '^NAME \\(Ch∆∞∆°ng CHAP_NUM: TITLE\\)',
        //Ph·ª•c 63 ch∆∞∆°ng
        '^Ph·ª•c CHAP_NUM ch∆∞∆°ng',
        //L√£o b√† Tuy·∫øt Nhi ƒë·ªïi th√™ tr·∫£i qua (th·∫≠p tam)
        '^NAME \\(CHAP_TEXT\\)TITLE',
        //‚Äî m·∫π v√∫ to ng∆∞·ªùi v·ª£ khu√™ m·∫≠t 84 c√πng m·∫π c√πng n·ªØ nhi
        '^[^\\p{L}]* NAME CHAP_NUM TITLE',
        //„Äê30, kh√∫c cu·ªëi„Äë
        '^„ÄêCHAP_NUM, TITLE„Äë$',
        //„Äêhai m∆∞∆°i b·∫£y ba ng∆∞·ªùi h·∫°nh ph√∫c (th∆∞·ª£ng)„Äë
        '^„ÄêCHAP_TEXT,? TITLE \\(HALF_TEXT\\)„Äë$',
        //„Äêhai m∆∞∆°i s√°u t√°i ki·∫øn tinh kh√¥ng„Äë
        //„Äêhai m∆∞∆°i ch√≠n, ba ng∆∞·ªùi h·∫°nh ph√∫c„Äë
        '^„ÄêCHAP_TEXT,? TITLE„Äë$',
        //Hai m∆∞∆°i t∆∞ du h√≠ tri·ªÉn
        '^CHAP_TEXT TITLE_SHORT$',
        //Th·ª© 1 cu·ªën 1, b·ªã phi√™u r·ªìi h·∫£?
        '^th·ª© BOOK_NUM BOOK_TYPE CHAP_NUM, TITLE$',
        //‚óè th·ª© 1 ch∆∞∆°ng ‚óè
        //
        //V√µ tr√†ng l√µa th·ªÉ luy·ªán ki·∫øm, th√¥i mi√™n t·ª± an ·ªßi ‚óè
        '^‚óè th·ª© CHAP_NUM CHAP_TYPE ‚óè$\\n+TITLE‚óè',
        //k·ªÉ ra m·ªôt c√°i ch·∫≥ng ph·∫£i thu·∫ßn khi·∫øt tr∆∞·ªüng th√†nh chuy·ªán x∆∞a Ch∆∞∆°ng 3: Thi·∫øu n·ªØ b·∫Øt gian nh·∫≠t k√Ω
        '(?<=\\s\\p{Ll}+\\s)CHAP_TYPE CHAP_NUM',
        //"B√≠ m·∫≠t nh·∫°c vi√™n" (Ch∆∞∆°ng 7: H√¥n n·ª≠a nƒÉm sau)
        '"NAME" \\(CHAP_TYPE CHAP_NUM: TITLE\\)',
        //Th·ª© 01 thi√™n: Tuy·ªát s·∫Øc gia t·ªôc chi c∆∞·ª°ng d√¢m (trung)
        'Th·ª© CHAP_NUM CHAP_TYPE: TITLE \\(HALF_TEXT\\)',
        //Ti·∫øp theo vi·∫øt th·ª© 8 ch∆∞∆°ng s∆° phong m√πi th∆°m
        'Ti·∫øp theo vi·∫øt th·ª© CHAP_NUM CHAP_TYPE TITLE',
        //Th·ª© hai n√≥i
        '^Th·ª© CHAP_TEXT n√≥i$',
        //001 ta v√† th√™ t·ª≠ vi√™n vi·ªán
        '^CHAP_NUM TITLE',
        //ƒê·ªá nh·∫•t b·ªô th·ª© 04 ch∆∞∆°ng
        '^ƒê·ªá BOOK_TEXT BOOK_TYPE th·ª© CHAP_NUM CHAP_TYPE',
        //Ti·∫øp theo th·ª© 05 ch∆∞∆°ng
        '^Ti·∫øp theo th·ª© CHAP_NUM CHAP_TYPE',
        //Th·ª© 084 d√¢m m·ªπ h√¨nh ·∫£nh
        '^Th·ª© CHAP_NUM TITLE$',
      ].sort((a, z) => {
        let specificity = (s) => {
          let specificity = 0;
          let r = /[A-Z_]{2,}/g;
          let m;
          while((m = r.exec(s))) {
            if(m.includes('_NUM')) specificity += 11;
            else specificity += 10;
          }
          return specificity;
        };
        if(specificity(a) > specificity(z)) return -1;
        if(specificity(a) < specificity(z)) return 1;
        return 0;
      });
      let matches = [];
      for (let pattern of patterns) {
        let source = pattern
          .replace('NAME', '(?<name>' + [...new Set([name, name.replace('h·ªá li·ªát', '').trim()])].join('|') + ')')
          .replace('DATE', '\\d+-\\d+-\\d+')
          .replace('SEP', '[ :]')
          .replace('TITLE_SHORT', '(?<titleShort>[^\n„Äë]{1,50}\\.*)')
          .replace('TITLE', '(?<title>[^\n„Äë]+\\.*)')
          .replace('BOOK_TITLE', '(?<bookTitle>[^\n„Äë]+\\.*)')
          .replace('BOOK_TYPE', '(?<bookType>(quy·ªÉn|t·∫≠p|b·ªô|cu·ªën|qu√Ω))')
          .replace('BOOK_NUM', `(?<bookNum>${NUMERIC})`)
          .replace('BOOK_TEXT', `(?<bookText>${NUMERIC_WORDS})`)
          .replace('HALF_TYPE', `(?<halfType>(ti·∫øt))`)
          .replace('HALF_NUM', `(?<halfNum>${NUMERIC})`)
          .replace('HALF_TEXT', `(?<halfText>(?<=\\()(th∆∞·ª£ng|trung|h·∫°|${NUMERIC_WORDS})(?=\\))|(?<=th·ª© )${NUMERIC_WORDS})`)
          .replace(/CHAP_TEXT(?=.*?CHAP_TYPE)/, 'CHAP_TEXT:LEAD')
          .replace(/(?<=CHAP_TYPE.*?)CHAP_TEXT/, 'CHAP_TEXT:TAIL')
          .replace('CHAP_TYPE', '(?<chapType>(ch∆∞∆°ng|h·ªìi|thi√™n|ngo·∫°i truy·ªán))')
          .replace('CHAP_NUM_DECIMAL', `(?<chapNum>${NUMERIC_DECIMAL})`)
          .replace('CHAP_NUM', `(?<chapNum>${NUMERIC})`)
          .replace('CHAP_TEXT:LEAD', `(?<chapText>cu·ªëi|k·∫øt|${LEAD_NUMERIC_WORDS})`)
          .replace('CHAP_TEXT:TAIL', `(?<chapText>cu·ªëi|k·∫øt|${TAIL_NUMERIC_WORDS})`)
          .replace('CHAP_TEXT', `(?<chapText>cu·ªëi|k·∫øt|${NUMERIC_WORDS})`);
        let regex = new RegExp(source, 'gimu');
        let result = [...text.matchAll(regex)];
        //console.debug({ pattern, regex, result });
        matches.push(...result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] })));
      }
      let falsePositives = [];
      matches.forEach((m, index) => {
        let shouldDelete = false;
        for (let f of ['chapText', 'bookText', 'halfText']) {
          if (m[f]) {
            if (/^[MDCLXVI]+$/i.test(m[f])) {
              let val = {
                I: 1,
                V: 5,
                X: 10,
                L: 50,
                C: 100,
                D: 500,
                M: 1000,
              };
              let totalValue = 0;
              let value = 0;
              let prev = 0;
              for (let c of m[f]) {
                let current = val[c];
                if (current > prev) {
                  // Undo the addition that was done, turn it into subtraction
                  totalValue -= 2 * value;
                }
                if (current != prev) { // Different symbol?
                  value = 0; // reset the sum for the new symbol
                }
                value += current; // keep adding same symbols
                totalValue += current;
                prev = current;
              }
              m[f] = totalValue;
              if(Number.isNaN(totalValue)) falsePositives.push(m);
            } else {
              let c = m[f].toLowerCase();
              let vn = {
                'm∆∞∆°i$|(?<=.)(th·∫≠p|b√°ch|thi√™n|v·∫°n)$': 0,
                'm∆∞∆°i': '',
                '(m∆∞·ªùi|th·∫≠p)(?=.+)|m[·ªô·ªë]t|nh·∫•t': 1,
                'hai|nh·ªã': 2,
                'ba|tam': 3,
                'b·ªën|t·ª©': 4,
                '[nl]ƒÉm|ng≈©': 5,
                's√°u|l·ª•c': 6,
                'b·∫£y|th·∫•t': 7,
                't√°m|b√°t': 8,
                'ch√≠n|c·ª≠u': 9,
                'm∆∞·ªùi|th·∫≠p': 10,
              };
              Object.entries(vn).forEach(([w, i]) => {
                w = new RegExp(w, 'gimu');
                c = c.replace(w, i);
              });
              c = c.replace(/\s/g, '');
              c = Number.parseInt(c);
              if (!Number.isNaN(c)) m[f] = Number.parseInt(c);
            }
          }
        }
        for (let f of ['chapNum', 'bookNum']) {
          if (m[f]) {
            m[f] = m[f].split('.').map(Number).join('.');
          }
        }
      });
      matches = matches.filter(m => !falsePositives.includes(m));
      matches.sort((a, z) => a.index - z.index);
      //debug({ matches });

      if (matches.length < 2) {
        let paragraphsPerChapter = 60;
        let pattern = '(.*\n){1,' + paragraphsPerChapter + '}';
        let regex = new RegExp(pattern, 'gimu')
        let result = [...text.matchAll(regex)];
        matches = result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] }));
      }

      let chapters = [];
      matches.forEach(m => {
        chapters.push(Chapter(m, { chapters, filename, text }));
      });

      let logResultSnapshot = [];
      let log = (label) => {
        let logResult = chapters.map(c => ({
          locked: c.locked != null ? true : undefined,
          lockType: c.locked,
          mergeDirection: c.mergeDirection,
          mergeReason: c.mergeReason,
          bookType: c._.bookType,
          bookNum: c._.bookNum,
          bookTitle: c._.bookTitle,
          chapType: c._.chapType,
          chapNum: c._.chapNum,
          halfType: c._.halfType,
          halfNum: c._.halfNum,
          text: c._.text,
          // pattern: c._.pattern,
          // title: c._.title || c._.titleShort,
        }));
        console.groupCollapsed(label);
        let action = /\w+/.exec(label)[0];
        if(logResultSnapshot.length == logResult.length) {
          console.table(logResult.map((chapter, i) => ({
            action: JSON.stringify(chapter) != JSON.stringify(logResultSnapshot[i]) ? action : undefined,
            ...chapter,
          })));
        } else {
          console.table(logResult);
        }
        console.groupEnd(label);
        logResultSnapshot = logResult;
      }

      log('parse result');
      for(let f of [
        dedupeByIndex,
        merge,
        lockCertain,
        merge,
        dedupeChapters,
        lockContinuous,
        analyzeUncertains,
        analyzeUncertains,
        dedupeChapters,
        merge,
        splitLongChapters,
      ]) {
        console.groupCollapsed(f.name);
        f(chapters);
        console.groupEnd(f.name);
        log(f.name + ' result');
      }
      // mergeShortChapters(chapters, 2000);
      // log('merge short');

      // cleanupChapters(chapters);
      // addPrologue(chapters, filename, text);

      return chapters;
    }

    function merge(chapters) {
      //merge up
      for(let i = chapters.length - 1; i > 0; i--) {
        let ci = chapters[i];
        if(ci.mergeDirection == 'up') {
          mergeBehind(chapters, i, ci.mergeReason);
        }
      }
      for(let i = 0; i < chapters.length - 1; i++) {
        let ci = chapters[i];
        if(ci.mergeDirection == 'down') {
          // mergeBehind()
        }
      }
    }

    function analyzeUncertains(chapters) {
      for(let i = 0; i < chapters.length; i++) {
        let ci = chapters[i];
        if(ci.locked) continue; //ignore certain chapters
        let ch, cj;
        for(let h = i - 1; h >= 0; h--) {
          if(chapters[h].locked) {
            ch = chapters[h];
            break;
          }
        }
        for(let j = i + 1; j < chapters.length; j++) {
          if(chapters[j].locked) {
            cj = chapters[j];
            break;
          }
        }
        if(ch && cj) {
          if((Number(ch._.chapNum) == Number(cj._.chapNum)) || ((Number(ch._.chapNum) + 1) == Number(cj._.chapNum))) {
            if(ci._.halfNum && (ci.halfNum != ch._.halfNum)) {
              console.group('keep separated half');
              console.log([ch?._.text, ci._.text, cj?._.text]);
              console.groupEnd();
              ci._.chapNum = ch._.chapNum;
              ci.mergeDirection = 'keep';
              ci.mergeReason = 'separated half';
            } else {
              console.group('merge up');
              console.log([ch?._.text, ci._.text, cj?._.text])
              console.log([ch?._.text, cj?._.text]);
              console.groupEnd();
              ci.mergeDirection = 'up';
              ci.mergeReason = 'same chapNum as prev/next';
            }
          } else if((Number(ch._.chapNum) <= Number(ci._.chapNum)) && (Number(ci._.chapNum) <= Number(cj._.chapNum))) {
            console.group('lock');
            console.log([ch?._.text, ci._.text, cj?._.text]);
            console.groupEnd();
            ci.locked = 'continuous';
          } else if(Number(cj._.chapNum) == 1) {
            console.group('merge end of book');
            console.log([ch?._.text, ci._.text, cj?._.text])
            console.log([ch?._.text, cj?._.text]);
            console.groupEnd();
            ci.mergeDirection = 'up';
            ci.mergeReason = 'end of book';
          }
        } else if(ch) {
          if(ci._.halfNum && (ci.halfNum != ch._.halfNum)) {
            console.group('keep separated half');
            console.log([ch?._.text, ci._.text, cj?._.text]);
            console.groupEnd();
            ci._.chapNum = ch._.chapNum;
            ci.mergeDirection = 'keep';
            ci.mergeReason = 'separated half';
          } else {
            console.group('merge all up');
            console.log([ch?._.text, ci._.text, cj?._.text]);
            console.log([ch?._.text]);
            console.groupEnd();
            ci.mergeDirection = 'up';
            ci.mergeReason = 'merge all';
          }
        } else if(cj) {
          if(ci._.halfNum && (ci.halfNum != cj._.halfNum)) {
            console.group('keep separated half');
            console.log([ch?._.text, ci._.text, cj?._.text]);
            console.groupEnd();
            ci._.chapNum = cj._.chapNum;
            ci.mergeDirection = 'keep';
            ci.mergeReason = 'separated half';
          } else {
            console.group('merge all down');
            console.log([ch?._.text, ci._.text, cj?._.text]);
            console.log([cj?._.text]);
            console.groupEnd();
            ci.mergeDirection = 'down';
            ci.mergeReason = 'merge all';
          }
        }
      }
    }

    function lockCertain(chapters) {
      for(let ci of chapters) {
        if(ci._.chapNum && ci._.chapType?.toLowerCase() == 'ch∆∞∆°ng') {
          console.log('Lock', [ci._.text]);
          ci.locked = 'certain';
        }
      }
    }

    function lockContinuous(chapters, lookupRange = 10) {
      let locked = [];
      //look behind
      console.group('Look behind');
      for(let i = 1; i < chapters.length; i++) {
        let ci = chapters[i];
        if(!ci._.chapNum) continue;
        for(let h = i - 1; h >= 0 && h >= i - lookupRange; h--) {
          let ch = chapters[h];
          let shouldLock = false;
          if(Number(ch._.chapNum) + 1 == Number(ci._.chapNum)) shouldLock = true;
          else if((ch._.chapNum == ci._.chapNum) && ch._.halfNum && (Number(ch._.halfNum) + 1 == Number(ci._.halfNum))) shouldLock = true;
          if(shouldLock) {
            console.log('Lock', [ch._.text, ci._.text]);
            ch.locked = 'continuous';
            ci.locked = 'continuous';
            break;
          }
        }
      }
      console.groupEnd('Look behind');
      console.group('Look ahead');
      //look ahead
      for(let i = chapters.length - 2; i >= 0; i--) {
        let ci = chapters[i];
        if(!ci._.chapNum) continue;
        if(ci.locked) continue;
        for(let j = i + 1; j < chapters.length && j < i + lookupRange; j++) {
          let cj = chapters[j];
          let shouldLock = false;
          if(Number(ci._.chapNum) + 1 == Number(cj._.chapNum)) shouldLock = true;
          else if((ci._.chapNum == cj._.chapNum) && ci._.halfNum && (Number(ci._.halfNum) + 1 == Number(cj._.halfNum))) shouldLock = true;
          if(shouldLock) {
            console.log('Lock', [ci._.text, cj._.text]);
            ci.locked = 'continuous';
            cj.locked = 'continuous';
            break;
          }
        }
      }
      console.groupEnd('Look ahead');
    }

    function splitLongChapters(chapters) {
      let averageLength = 1500; //1500 words per chapter
      let lockedWords = 0;
      let lockedChapters = 0;
      for(let ci of chapters) {
        if(ci.locked) {
          let words = ci.content.split(/\s+/).length;
          console.log('Certain words:', [ci._.text], words)
          lockedWords += words;
          lockedChapters++;
        }
      }
      if(lockedChapters > 0) averageLength = Math.floor(lockedWords / lockedChapters);
      console.log({lockedChapters});
      return;
      for(let i = chapters.length-1; i >= 0; i--) {
        let [ci, cj] = [chapters[i], chapters[i+1]];
        let ciLength = ci.endIndex - ci.startIndex;
        if(ciLength <= maxLength) continue;
        let partsCount = Math.floor(ciLength / maxLength);
        if(cj) {
          if(Number(ci._.chapNum) + 1 != Number(cj._.chapNum)) {
            partsCount = Number(cj._.chapNum) - Number(ci._.chapNum);
            step = 'chapNum';
          } else if(ci._.chapNum == cj._.chapNum && ci._.halfNum && Number(ci._.halfNum) + 1 != Number(cj._.halfNum)) {
            partsCount = Number(cj._.halfNum) - Number(ci._.halfNum);
            step = 'partNum';
          }
        }
        console.log('Split', [ci._.text], 'into', partsCount, 'chapters');
        let parts = [];
        let index = ci.startIndex;
        let partLength = ci.content.length / partsCount;
        for(let i = 1; i < partsCount; i++) {
          let endIndex = ci.content.slice(index + partlength).indexOf('\n');
          parts.push(endIndex);
          index = endIndex;
        }
        // for(let )
      }
    }

    function mergeBehind(chapters, i, reason) {
      // chapters[i].endIndex = chapters[i+1].endIndex;
      let [ch, ci] = [chapters[i-1], chapters[i]];
      let c;
      if (!ch.chapNo && ci.chapNo) c = ci;
      else if (ch.chapNo == ci.chapNo) {
        if (!ch._.title && ci._.title) c = ci;
      }
      //console.log('merge', [ch._.text, ci._.text], 'because', reason, c == ci, { ch, ci });
      if (c) {
        Object.assign(ch._, {
          title: c._.title,
          chapNum: c._.chapNum,
          chapText: c._.chapText,
          bookNum: c._.bookNum,
          bookText: c._.bookText,
          bookType: c._.bookType,
          halfNum: c._.halfNum,
          halfText: c._.halfText,
          halfType: c._.halfType,
        });
      }
      chapters.splice(i, 1);
      //console.log('  ->', [ch._.text])
      ch.merged++;
    }

    function dedupeChapters(chapters) {
      let shouldMerge = (i, j) => {
        let [ci, cj] = [chapters[i], chapters[j]];
        if(!cj) return false;
        if(!ci.locked) return false;
        if(!cj.locked) return false;
        if(ci._.chapNum && (ci._.chapNum == cj._.chapNum)) {
          //same chap num
          if(ci._.halfNum == cj._.halfNum) {
            //same half num
            return true;
          }
          if((ci._.halfNum && !cj._.halfNum) || (!ci._.halfNum && cj._.halfNum)) {
            //probably same half num
            return true;
          }
        }
        return false;
      };
      let i = 0;
      while(i < chapters.length) {
        let j = i+1;
        while(j < chapters.length) {
          if(shouldMerge(i, j)) {
            let [ci, cj] = [chapters[i], chapters[j]];
            console.log('Dedupe', [ci._.text, cj._.text]);
            cj.mergeDirection = 'up';
            cj.mergeReason = 'dedupe';
            j++;
          } else {
            break;
          }
        }
        i = j;
      }
    }

    function dedupeByIndex(chapters) {
      for(let i = 0; i < chapters.length-1; i++) {
        let [ci, cj] = [chapters[i], chapters[i+1]];
        if(ci.startIndex + 100 >= cj.startIndex) {
          console.log('Dedupe', [ci._.text, cj._.text]);
          cj.mergeDirection = 'up';
          cj.mergeReason = 'dedupe';
        }
      }
    }

    function cleanupChapters(chapters) {
      let phienNgoai = c => /phi√™n ngo·∫°i/iu.test(c._.title);

      // debug({chapters})
      let i = 1;
      while (i < chapters.length - 1) {
        let [ch, ci, cj] = [chapters[i-1], chapters[i], chapters[i+1]];
        let shouldMerge = false;
        //ci is not continuity of ch
        if (ch.chapNo != null && ci.chapNo != null && (ch.chapNo + 1 != ci.chapNo)) {
          // console.log('phien ngoai', [ch._.title, ci._.title]);
          if (phienNgoai(ch) != phienNgoai(ci) || ch.half != ci.half) {
            i++;
            continue;
          }
          if (!cj && !/phi√™n ngo·∫°i/iu.test(ci._.title)) {
            //ci is the last chapter, can merge
            shouldMerge = true;
          } else {
            //find continuity of ch
            for (let j = i + 1; j <= i + 3 && j < chapters.length; j++) {
              cj = chapters[j];
              // console.log(ch.chapNo, cj.chapNo);
              if (cj.chapNo != null && (ch.chapNo + 1 == cj.chapNo)) {
                shouldMerge = true;
                break;
              }
            }
          }
        }
        if (shouldMerge) {
          //console.debug('cleanupChapters', ch.chapNo, '<-', ci.chapNo, cj?.chapNo);
          mergeBehind(chapters, i, 'cleanup');
        } else {
          i++;
        }
      }
    }

    function mergeShortChapters(chapters, minLength = 2_000) {
      for(let i = 0; i < chapters.length; i++) {
        let ci = chapters[i];
        if(ci.mergeDirection) continue;
        if(ci.length > minLength) continue;
        let fields = [];
        if (ci._.bookNum) fields.push('bookNum');
        if (ci._.chapNum != null) fields.push('chapNum');
        if (ci._.halfNum) fields.push('halfNum');
        if(fields.length > 0) {
          for(let h = i - 1; h >= 0; h--) {
            let ch = chapters[h];
            if(ch.mergeDirection == 'up') continue;
            if(!ch.locked) continue;
            if (fields.every(f => ch._[f] == ci._[f])) {
              console.log('merge', h, '<-', i);
              ci.mergeDirection = 'up';
              ci.mergeReason = 'short and dupe of prev';
              break;
            }
          }
        }
      }
      return;
      for (let i = chapters.length - 1; i > 0; i--) {
        let [h, j] = [i-1, i+1];
        let [ch, ci, cj] = [chapters[h], chapters[i], chapters[j]];
        if ((ci.length / ci.merged) < minLength) {
          if(ci.locked) continue;
          console.group('merge short');
          console.warn(ci.id);
          let fields = [];
          if (ci.bookNo) fields.push('bookNo');
          if (ci.chapter != null) fields.push('chapter');
          if (ci.half) fields.push('half');
          if (fields.every(f => ch[f] == ci[f])) {
            console.log(chapters, i, 'short and dupe of prev');
            // mergeBehind(chapters, i, 'short and dupe of prev');
            ci.mergeDirection = 'up';
            ci.mergeReason = 'short and dupe of prev';
          } else if (cj && fields.every(f => cj[f] == ci[f])) {
            console.log(chapters, j, 'short and dupe of next');
            // mergeBehind(chapters, j, 'short and dupe of next');
            ci.mergeDirection = 'up';
            ci.mergeReason = 'short and dupe of next';
          } else if (fields.length == 0 || (fields.length == 1 && fields[0] == 'chapter')) {
            if (ci._.name && cj) {
              console.log(chapters, j, 'short with name');
              // mergeBehind(chapters, j, 'short with name');
              ci.mergeDirection = 'up';
              ci.mergeReason = 'short with name';
            } else {
              console.log('short', { ch: ch.title, ci: ci.title, cj: cj.title });
              // mergeBehind(chapters, i, 'short');
              ci.mergeDirection = 'up';
              ci.mergeReason = 'short';
            }
          }
          console.groupEnd('merge short');
        }
      }
    }

    function mergeShortChapters1(chapters, minLength = 2e3) {
      let isShort = chapter => ((chapter.endIndex - chapter.startIndex) <= minLength);
      let isLong = chapter => !isShort(chapter);
      //delete all first short chapters, they belongs to prologue
      let firstLongChapterIndex = chapters.findIndex(isLong);
      chapters.splice(0, firstLongChapterIndex);
      //merge short chapters to next long chapter
      let short;
      while((short = chapters.find(isShort))) {
        let shortIndex = chapters.indexOf(short);
        let long = chapters.find((chapter, index) => isLong(chapter) && index >= shortIndex);
        let longIndex = chapters.indexOf(long);
        if (long) {
          short.endIndex = long.endIndex;
          chapters.splice(shortIndex, longIndex - shortIndex);
        } else {
          //merge last short chapters to previous long chapter
          long = chapters[shortIndex - 1];
          if (long) {
            long.endIndex = text.length;
            chapters.length = shortIndex;
          }
          break;
        }
      }
    }

    function addPrologue(chapters, filename, text) {
      //extract prologue
      let prologue = text.slice(0, chapters[0]?.startIndex ?? -1).trim();
      if(prologue) {
        chapters.unshift(Chapter({
          title: filename,
          index: 0,
        }, { chapters, filename, text }));
      }
    }

    function extractChapters1(filename, text, { name }) {
      let debug = true;
      debug && console.log({ name });
      //let chapterPattern = /^\s*\[?\s*(?:chapter)?\s*:?\s*Th·ª©\s+\w+(\s*-\s*\d+)?\s+ch∆∞∆°ng\b.*|\bCh∆∞∆°ng\s+\d+\s*:?.*|^(?:\d+\s*\.?\s*)+$|^\s*\d+\s+Ch∆∞∆°ng\s*:?\s*|^„Äê.*?„Äë\([\d-]+\)$|^„Äê.*?„Äë\s*b·ªô(\s+\d+)+$|^\d+[.!].*|^\s*\d+(\s*-\s*\d+)?\s*$|^[-]+$/gimu;
      let certainPatterns = [
        /^ch∆∞∆°ng \d+$/,
        /^ch∆∞∆°ng \d+:/,
        /^‚Äî ?ch∆∞∆°ng \d+:.*? ?‚Äî/,
        /^ch∆∞∆°ng (cu·ªëi|k·∫øt)/,
        /^t·ª± ch∆∞∆°ng/,
        /^L·ªùi d·∫´n/,
        /^b·ªô \d+:? ch∆∞∆°ng \d+/, // b·ªô 01: ch∆∞∆°ng 05:
        /^th·ª© \d+ b·ªô th·ª© \d+ ch∆∞∆°ng/, // th·ª© 01 b·ªô th·ª© 02 ch∆∞∆°ng
        /^\d+([\.\s]+\d+)*$/,
        /th·ª© \d+ ch∆∞∆°ng/,
        /^\(\d+\)/,
        /^H·ªìi \d+/,
        new RegExp('^„Äê' + name + '„Äë\\d+$'),
        new RegExp('^"' + name + '" \\d+$'),
        /^ch\. \d+/,
        /^ ?\[? ?(?:chapter)? ?:? ?Th·ª© \w+( ?- ?\d+)? ch∆∞∆°ng/,
        /^ ?\d+ Ch∆∞∆°ng ?:? ?/,
        /^„Äê.*?„Äë\([\d-]+\)$/,
        /^„Äê.*?„Äë ?b·ªô( \d+)+$/,
        /^\d+[.!].*/,
        /^ ?\d+( ?- ?\d+)? ?$/,
        /quy·ªÉn (th·ª© )?(\d+|(m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n|(m∆∞·ªùi( m·ªôt)?|(hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n) m∆∞∆°i( m·ªët)?)( (hai|ba|b·ªën|lƒÉm|s√°u|b·∫£y|t√°m|ch√≠n))?)) ch∆∞∆°ng \d.*/,
        /(phi√™n ngo·∫°i|ch√≠nh vƒÉn) ch∆∞∆°ng \d+:/,
        /phi√™n ngo·∫°i .* ch∆∞∆°ng/,
        /^(th∆∞·ª£ng|trung|h·∫°) \(\d+\)$/,
        /^(th∆∞·ª£ng|trung|h·∫°) b·ªô/,
      ];
      let loosePatterns = [
        new RegExp('^„Äê' + name + '„Äë.*$'),
        new RegExp('^"' + name + '".*$'),
        new RegExp('^' + name + ' [\\(\\.:\\d]'),
        /^.*\((th∆∞·ª£ng|trung|h·∫°)\):?$/, // ph·∫£n k√≠ch (th∆∞·ª£ng)
        /^([(]?)(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p|(m∆∞·ªùi) (m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n|m∆∞∆°i))(?=[,:)])([^.]*)$/,
        /^(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p).*/,
        /^\[.*\]$/,
        /^[-‚Äî* ]+$/,
      ];
      let matches;
      for (let patterns of [certainPatterns, loosePatterns]) {
        let regex = new RegExp('(?:' + patterns.map(p => '(?:' + p.source + ')').join('|') + ').*', 'gimu');
        matches = [...regex[Symbol.matchAll](text)];
        debug && console.log({ regex, matches })
        if (matches.length > 0) break;
      }
      let chapters = matches.map((match, i) => {
        let startIndex = text.lastIndexOf('\n', match.index);
        if (startIndex == -1) startIndex = 0;
        let endIndex = text.length;
        if (matches[i+1]) endIndex = text.lastIndexOf('\n', matches[i+1].index);
        let title = match[0].trim();
        if (/^[-‚Äî]+$/.test(title)) title = `-Ch∆∞∆°ng ${i+1}-`;
        title = title.replace(new RegExp('^„Äê(' + name + ')„Äë\s*', 'i'), '');
        title = title.replace(new RegExp('^"(' + name + ')"\s*', 'i'), '');
        title = title.replace(new RegExp('^(' + name + ')\s*', 'i'), '');
        return {
          title,
          startIndex,
          endIndex,
        }
      });

      return mergeChapters(chapters, filename, text);
    }

    function slug(s) {
      s = latinize(s);
      s = s.replace(/\W+/g, '-');
      s = s.replace(/^-+|-+$/g, '');
      s = s.toLowerCase();
      return s;
    }

    function latinize(s) {
      s = s.replace(/[√ÅƒÇ·∫Æ·∫∂·∫∞·∫≤·∫¥«ç√Ç·∫§·∫¨·∫¶·∫®·∫™√Ñ«û»¶«†·∫†»Ä√Ä·∫¢»ÇƒÄƒÑ√Ö«∫·∏Ä»∫√É‚±Ø·¥Ä]/g, 'A');
      s = s.replace(/[Íú≤]/g, 'AA');
      s = s.replace(/[√Ü«º«¢·¥Å]/g, 'AE');
      s = s.replace(/[Íú¥]/g, 'AO');
      s = s.replace(/[Íú∂]/g, 'AU');
      s = s.replace(/[Íú∏Íú∫]/g, 'AV');
      s = s.replace(/[Íúº]/g, 'AY');
      s = s.replace(/[·∏Ç·∏Ñ∆Å·∏Ü…É∆Ç ô·¥É–ë]/g, 'B');
      s = s.replace(/[ƒÜƒå√á·∏àƒàƒä∆á»ªÍúæ·¥Ñ]/g, 'C');
      s = s.replace(/[ƒé·∏ê·∏í·∏ä·∏å∆ä·∏é«≤«Öƒê√ê∆ãÍùπ·¥Ö–î]/g, 'D');
      s = s.replace(/[«±«Ñ]/g, 'DZ');
      s = s.replace(/[√âƒîƒö»®·∏ú√ä·∫æ·ªÜ·ªÄ·ªÇ·ªÑ·∏ò√ãƒñ·∫∏»Ñ√à·∫∫»Üƒí·∏ñ·∏îƒò…Ü·∫º·∏ö∆ê∆é·¥á‚±ª–ï–≠]/g, 'E');
      s = s.replace(/[Íù™]/g, 'ET');
      s = s.replace(/[·∏û∆ëÍùªÍú∞–§]/g, 'F');
      s = s.replace(/[«¥ƒû«¶ƒ¢ƒúƒ†∆ì·∏†«§ÍùΩ…¢ õ–ì“ê]/g, 'G');
      s = s.replace(/[·∏™»û·∏®ƒ§‚±ß·∏¶·∏¢·∏§ƒ¶ ú–•]/g, 'H');
      s = s.replace(/[√çƒ¨«è√é√è·∏Æƒ∞·ªä»à√å·ªà»äƒ™ƒÆ∆óƒ®·∏¨–Ü…™–ô–´–ò]/g, 'I');
      s = s.replace(/[ÍûÇ≈î≈ò≈ñ·πò·πö·πú»ê»í·πû…å‚±§ Å Ä·¥ô·¥ö–†]/g, 'R');
      s = s.replace(/[ÍûÑ≈ö·π§≈†·π¶≈û≈ú»ò·π†·π¢·π®Íú±–°]/g, 'S');
      s = s.replace(/[ÍûÜ≈§≈¢·π∞»ö»æ·π™·π¨∆¨·πÆ∆Æ≈¶·¥õ–¢]/g, 'T');
      s = s.replace(/[Íù¨]/g, 'IS');
      s = s.replace(/[ƒ¥…à·¥ä]/g, 'J');
      s = s.replace(/[·∏∞«®ƒ∂‚±©ÍùÇ·∏≤∆ò·∏¥ÍùÄÍùÑ·¥ã–ö]/g, 'K');
      s = s.replace(/[ƒπ»ΩƒΩƒª·∏º·∏∂·∏∏‚±†Íùà·∏∫ƒø‚±¢«à≈ÅÍûÄ ü·¥å–õ]/g, 'L');
      s = s.replace(/[«á]/g, 'LJ');
      s = s.replace(/[·∏æ·πÄ·πÇ‚±Æ∆ú·¥ç–ú]/g, 'M');
      s = s.replace(/[≈É≈á≈Ö·πä·πÑ·πÜ«∏∆ù·πà»†«ã√ë…¥·¥é–ù]/g, 'N');
      s = s.replace(/[«ä]/g, 'NJ');
      s = s.replace(/[√ì≈é«ë√î·ªê·ªò·ªí·ªî·ªñ√ñ»™»Æ»∞·ªå≈ê»å√í·ªé∆†·ªö·ª¢·ªú·ªû·ª†»éÍùäÍùå≈å·πí·πê∆ü«™«¨√ò«æ√ï·πå·πé»¨∆Ü·¥è·¥ê–û]/g, 'O');
      s = s.replace(/[∆¢]/g, 'OI');
      s = s.replace(/[Íùé]/g, 'OO');
      s = s.replace(/[»¢·¥ï]/g, 'OU');
      s = s.replace(/[·πî·πñÍùí∆§Íùî‚±£Íùê·¥ò–ü]/g, 'P');
      s = s.replace(/[ÍùòÍùñ]/g, 'Q');
      s = s.replace(/[√ü]/g, 'ss');
      s = s.replace(/[…ÖÍùû·πæ∆≤·πº·¥†–í]/g, 'V');
      s = s.replace(/[Íú®]/g, 'TZ');
      s = s.replace(/[√ö≈¨«ì√õ·π∂√ú«ó«ô«õ«ï·π≤·ª§≈∞»î√ô·ª¶∆Ø·ª®·ª∞·ª™·ª¨·ªÆ»ñ≈™·π∫≈≤≈Æ≈®·π∏·π¥·¥ú–£]/g, 'U');
      s = s.replace(/[Íù†]/g, 'VY');
      s = s.replace(/[·∫Ç≈¥·∫Ñ·∫Ü·∫à·∫Ä‚±≤·¥°]/g, 'W');
      s = s.replace(/[·∫å·∫ä]/g, 'X');
      s = s.replace(/[√ù≈∂≈∏·∫é·ª¥·ª≤∆≥·ª∂·ªæ»≤…é·ª∏ è]/g, 'Y');
      s = s.replace(/[–á]/g, 'YI');
      s = s.replace(/[≈π≈Ω·∫ê‚±´≈ª·∫í»§·∫î∆µ·¥¢–ó]/g, 'Z');
      s = s.replace(/[√û]/g, 'TH');
      s = s.replace(/[ƒ≤]/g, 'IJ');
      s = s.replace(/[≈í…∂]/g, 'OE');
      s = s.replace(/[√°ƒÉ·∫Ø·∫∑·∫±·∫≥·∫µ«é√¢·∫•·∫≠·∫ß·∫©·∫´√§«ü»ß«°·∫°»Å√†·∫£»ÉƒÅƒÖ·∂è·∫ö√•«ª·∏Å‚±•√£…ê‚Çê–ê–∞]/g, 'a');
      s = s.replace(/[Íú≥]/g, 'aa');
      s = s.replace(/[√¶«Ω«£·¥Ç]/g, 'ae');
      s = s.replace(/[Íúµ]/g, 'ao');
      s = s.replace(/[Íú∑]/g, 'au');
      s = s.replace(/[ÍúπÍúª]/g, 'av');
      s = s.replace(/[ÍúΩ]/g, 'ay');
      s = s.replace(/[·∏É·∏Ö…ì·∏á·µ¨·∂Ä∆Ä∆É–±]/g, 'b');
      s = s.replace(/[…µ√≥≈è«í√¥·ªë·ªô·ªì·ªï·ªó√∂»´»Ø»±·ªç≈ë»ç√≤·ªè∆°·ªõ·ª£·ªù·ªü·ª°»èÍùãÍùç‚±∫≈ç·πì·πë«´«≠√∏«ø√µ·πç·πè»≠…î·∂ó·¥ë·¥ì‚Çí–æ]/g, 'o');
      s = s.replace(/[ƒáƒç√ß·∏âƒâ…ïƒã∆à»º‚ÜÑÍúø]/g, 'c');
      s = s.replace(/[ƒè·∏ë·∏ì»°·∏ã·∏ç…ó·∂ë·∏è·µ≠·∂Åƒë…ñ∆å√∞Íù∫–¥]/g, 'd');
      s = s.replace(/[ƒ±√≠ƒ≠«ê√Æ√Ø·∏Ø·ªã»â√¨·ªâ»ãƒ´ƒØ·∂ñ…®ƒ©·∏≠—ñ·¥â·µ¢–π—ã–∏]/g, 'i');
      s = s.replace(/[»∑…ü Ñ«∞ƒµ ù…â‚±º]/g, 'j');
      s = s.replace(/[«≥«Ü]/g, 'dz');
      s = s.replace(/[√©ƒïƒõ»©·∏ù√™·∫ø·ªá·ªÅ·ªÉ·ªÖ·∏ô√´ƒó·∫π»Ö√®·∫ª»áƒì·∏ó·∏ï‚±∏ƒô·∂í…á·∫Ω·∏õ…õ·∂ì…ò«ù‚Çë–µ—ç]/g, 'e');
      s = s.replace(/[Íù´]/g, 'et');
      s = s.replace(/[·∏ü∆í·µÆ·∂ÇÍùº—Ñ]/g, 'f');
      s = s.replace(/[«µƒü«ßƒ£ƒùƒ°…†·∏°·∂É«•·µπ…°·µ∑–≥“ë]/g, 'g');
      s = s.replace(/[·∏´»ü·∏©ƒ•‚±®·∏ß·∏£·∏•…¶·∫ñƒß…• Æ Ø—Ö]/g, 'h');
      s = s.replace(/[∆ï]/g, 'hv');
      s = s.replace(/[ÍûÉ≈ï≈ô≈ó·πô·πõ·πù»ë…æ·µ≥»ì·πü…º·µ≤·∂â…ç…Ω…ø…π…ª…∫‚±π·µ£—Ä]/g, 'r');
      s = s.replace(/[ÍûÖ≈ø·∫ú·∫õ·∫ù≈õ·π•≈°·πß≈ü≈ù»ô·π°·π£·π© Ç·µ¥·∂ä»ø—Å]/g, 's');
      s = s.replace(/[Íûá≈•≈£·π±»õ»∂·∫ó‚±¶·π´·π≠∆≠·πØ·µµ∆´ à≈ß á—Ç]/g, 't');
      s = s.replace(/[Íù≠]/g, 'is');
      s = s.replace(/[·∏±«©ƒ∑‚±™ÍùÉ·∏≥∆ô·∏µ·∂ÑÍùÅÍùÖ û–∫]/g, 'k');
      s = s.replace(/[ƒ∫∆ö…¨ƒæƒº·∏Ω»¥·∏∑·∏π‚±°Íùâ·∏ª≈Ä…´·∂Ö…≠≈ÇÍûÅ–ª]/g, 'l');
      s = s.replace(/[«â]/g, 'lj');
      s = s.replace(/[·∏ø·πÅ·πÉ…±·µØ·∂Ü…Ø…∞–º]/g, 'm');
      s = s.replace(/[≈Ñ≈à≈Ü·πã»µ·πÖ·πá«π…≤·πâ∆û·µ∞·∂á…≥√±–Ω]/g, 'n');
      s = s.replace(/[«å]/g, 'nj');
      s = s.replace(/[∆£]/g, 'oi');
      s = s.replace(/[Íùè]/g, 'oo');
      s = s.replace(/[»£]/g, 'ou');
      s = s.replace(/[·πï·πóÍùì∆•·µ±·∂àÍùï·µΩÍùë–ø]/g, 'p');
      s = s.replace(/[Íùô †…ãÍùó]/g, 'q');
      s = s.replace(/[·¥ù√∫≈≠«î√ª·π∑√º«ò«ö«ú«ñ·π≥·ª•≈±»ï√π·ªß∆∞·ª©·ª±·ª´·ª≠·ªØ»ó≈´·πª≈≥·∂ô≈Ø≈©·ππ·πµ·µ§—É]/g, 'u');
      s = s.replace(/[·µ∫√æ]/g, 'th');
      s = s.replace(/[·¥î≈ì]/g, 'oe');
      s = s.replace(/[ å‚±¥Íùü·πø ã·∂å‚±±·πΩ·µ•–≤]/g, 'v');
      s = s.replace(/[ ç·∫É≈µ·∫Ö·∫á·∫â·∫Å‚±≥·∫ò]/g, 'w');
      s = s.replace(/[ é√Ω≈∑√ø·∫è·ªµ·ª≥∆¥·ª∑·ªø»≥·∫ô…è·ªπ]/g, 'y');
      s = s.replace(/[Íú©]/g, 'tz');
      s = s.replace(/[·µ´]/g, 'ue');
      s = s.replace(/[Íù∏]/g, 'um');
      s = s.replace(/[Íù°]/g, 'vy');
      s = s.replace(/[·∫ç·∫ã·∂ç‚Çì]/g, 'x');
      s = s.replace(/[—ó]/g, 'yi');
      s = s.replace(/[≈∫≈æ·∫ë ë‚±¨≈º·∫ì»•·∫ï·µ∂·∂é ê∆∂…Ä–∑]/g, 'z');
      s = s.replace(/[Ô¨Ä]/g, 'ff');
      s = s.replace(/[Ô¨É]/g, 'ffi');
      s = s.replace(/[Ô¨Ñ]/g, 'ffl');
      s = s.replace(/[Ô¨Å]/g, 'fi');
      s = s.replace(/[Ô¨Ç]/g, 'fl');
      s = s.replace(/[ƒ≥]/g, 'ij');
      s = s.replace(/[Ô¨Ü]/g, 'st');
      s = s.replace(/[–Å]/g, 'YO');
      s = s.replace(/[–¶]/g, 'TS');
      s = s.replace(/[–®]/g, 'SH');
      s = s.replace(/[–©]/g, 'SCH');
      s = s.replace(/[–™—ä–¨—å]/g, '\'');
      s = s.replace(/[—ë]/g, 'yo');
      s = s.replace(/[—Ü]/g, 'ts');
      s = s.replace(/[—à]/g, 'sh');
      s = s.replace(/[—â]/g, 'sch');
      s = s.replace(/[–ñ]/g, 'ZH');
      s = s.replace(/[–∂]/g, 'zh');
      s = s.replace(/[–Ø]/g, 'Ya');
      s = s.replace(/[–ß]/g, 'CH');
      s = s.replace(/[–Æ]/g, 'YU');
      s = s.replace(/[—è]/g, 'ya');
      s = s.replace(/[—á]/g, 'ch');
      s = s.replace(/[—é]/g, 'yu');
      return s;
    }

    function titleizeHumanName(s, minOccurence = 10, occurenceThreshold = 0.8) {
      let debug = false;
      let pattern = /(?:(?<pre>\p{Ll}+)[ ]+)?(?<name>[\p{Lu}A-Z]\p{Ll}+(?:[ ]+\p{Lu}\p{Ll}+)?)(?:[ ]+(?<post>\p{Ll}+))?/gu;
      let counts = {};
      let match;
      let titleize = s => s.replace(/(?<=^|[^\p{L}])\p{L}/gu, s => s.toUpperCase());
      let c = 0;
      while ((match = pattern.exec(s))) {
        if (++c < 10) debug && console.log({ match });
        let { pre, name, post } = match.groups;
        if (!counts[name]) counts[name] = { total: 0, pre: {}, post: {} };
        counts[name].total += 1;
        if (pre) {
          if (!counts[name].pre[pre]) counts[name].pre[pre] = 0;
          counts[name].pre[pre] += 1;
        }
        if (post) {
          if (!counts[name].post[post]) counts[name].post[post] = 0;
          counts[name].post[post] += 1;
        }
      }
      debug && console.dir(counts);
      analyze: for (let [name, { total, pre, post }] of Object.entries(counts)) {
        if (total < minOccurence) {
          debug && console.debug(name, 'is too few .. IGNORE', { total });
          continue analyze;
        }
        for (let [prefix, prefixCount] of Object.entries(pre)) {
          if (prefixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(prefix), name, { total, prefixCount });
            s = s.replace(new RegExp(prefix + '\\s+' + name, 'gu'), titleize);
            continue analyze;
          }
        }
        for (let [postfix, postfixCount] of Object.entries(post)) {
          if (postfixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(postfix), name, { total, postfixCount });
            s = s.replace(new RegExp(name + '\\s+' + postfix, 'gu'), titleize);
            continue analyze;
          }
        }
      }
      return s;
    }

    function debug(...args) {
      // return;
      if (args.length == 1) {
        console.table(Object.values(args[0])[0]);
      } else {
        console.info(...args);
      }
    }

    function getColorScheme() {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
      return 'light';
    }

    function buildRegex(patterns, placeholders, flags) {
      patterns = patterns.filter(Boolean).map((p, i) => `(?<Case${i+1}>${p.source || p})`).join('|');
      let counts = Object.fromEntries(Object.keys(placeholders).map(k => [k, 0]));
      for(let i = 1; i <= 10; i++) {
        for(let [p, r] of Object.entries(placeholders)) {
          patterns = patterns.replaceAll(`{${p}}`, () => `(?<${p}${++counts[p]}>${r.source || r})`);
        }
      }
      return new RegExp(patterns, flags);
    }

    function simpleCache({ key, getValue, getHash, fallbackValue }) {
      try {
        let cache = globalThis.__simpleCache || (globalThis.__simpleCache = {});
        let hash = getHash();
        if (!(key in cache) || cache[key].hash != hash) {
          cache[key] = { value: getValue(), hash };
        }
        return cache[key].value;
      } catch {
        return fallbackValue;
      }
    }

    function titleCase(s) {
      return s.toLowerCase().replace(/(?<=^|[^\p{L}])./gu, c => c.toUpperCase());
    }

    function memoize(f) {
      let memoized = _.memoize(f, (...args) => JSON.stringify(args));
      globalThis[f.name] = memoized;
      return memoized;
    }

    function getCase(word) {
      if (word == word.toUpperCase()) return 'upper';
      if (word == word.toLowerCase()) return 'lower';
      if (word[0] == word[0].toUpperCase()) return 'title';
    }

    function toCase(word, _case) {
      if (_case == 'upper') return word.toUpperCase();
      if (_case == 'lower') return word.toLowerCase();
      if (_case == 'title') return titleCase(word);
      return word;
    }

    memoize(function useCase(src, dst) {
      if (getCase(src) == 'lower' && getCase(dst) == 'lower') return titleCase(dst);
      let srcWords = src.split(' ');
      let dstWords = dst.split(' ');
      if (srcWords.length == dstWords.length) {
        let cases = srcWords.map((srcWord, i) => {
          if (getCase(srcWord) != getCase(dstWords[i])) return getCase(dstWords[i]);
        });
        return function applyCase(s) {
          return s.split(' ').map((word, i) => toCase(dstWords[i], cases[i] || getCase(word))).join(' ');
        }
      }
      return dst;
    });

    memoize(function hashCode(str) {
      let hash = 0;
      if (str.length === 0) return hash;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
        hash = hash & hash;
      }
      return hash;
    });
  </script>
</body>
</html>
