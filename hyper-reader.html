<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📖</text></svg>">
  <title>Text Reader</title>
  <style>
    @font-face {
      font-family: Reader1;
      src: local('LMRoman12-Regular'), url('https://mirror.kku.ac.th/CTAN/fonts/lm/fonts/opentype/public/lm/lmroman12-regular.otf') format('opentype');
    }
    @font-face {
      font-family: Reader;
      font-weight: 400;
      src: local('WorkSans-Regular');
    }
    @font-face {
      font-family: Reader;
      font-weight: 500;
      src: local('WorkSans-Medium');
    }

    /** reset **/
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      border: 0;
      outline: 0;
      transform-origin: 50% 50%;
    }
    p {
      margin: 1em 0;
    }
    hr {
      border: 0;
      height: 1px;
      background: rgba(0, 0, 0, .2);
    }
    a,
    a:any-link {
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-skip-ink: none;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    small {
      font-size: 0.875em;
    }

    /** rose pine **/
    :root {
      --rp-main-base: #191724;
      --rp-main-surface: #1f1d2e;
      --rp-main-overlay: #26233a;
      --rp-main-muted: #6e6a86;
      --rp-main-subtle: #908caa;
      --rp-main-text: #e0def4;
      --rp-main-love: #eb6f92;
      --rp-main-gold: #f6c177;
      --rp-main-rose: #ebbcba;
      --rp-main-pine: #31748f;
      --rp-main-foam: #9ccfd8;
      --rp-main-iris: #c4a7e7;
      --rp-main-highlight-low: #21202e;
      --rp-main-highlight-low-alpha: #6e6a861a;
      --rp-main-highlight-med: #403d52;
      --rp-main-highlight-med-alpha: #6e6a8633;
      --rp-main-highlight-high: #524f67;
      --rp-main-highlight-high-alpha: #6e6a8666;
      --rp-moon-base: #232136;
      --rp-moon-surface: #2a273f;
      --rp-moon-overlay: #393552;
      --rp-moon-muted: #6e6a86;
      --rp-moon-subtle: #908caa;
      --rp-moon-text: #e0def4;
      --rp-moon-love: #eb6f92;
      --rp-moon-gold: #f6c177;
      --rp-moon-rose: #ea9a97;
      --rp-moon-pine: #3e8fb0;
      --rp-moon-foam: #9ccfd8;
      --rp-moon-iris: #c4a7e7;
      --rp-moon-highlight-low: #2a283e;
      --rp-moon-highlight-low-alpha: #817c9c14;
      --rp-moon-highlight-med: #44415a;
      --rp-moon-highlight-med-alpha: #817c9c26;
      --rp-moon-highlight-high: #56526e;
      --rp-moon-highlight-high-alpha: #817c9c4d;
      --rp-dawn-base: #faf4ed;
      --rp-dawn-surface: #fffaf3;
      --rp-dawn-overlay: #f2e9e1;
      --rp-dawn-muted: #9893a5;
      --rp-dawn-subtle: #797593;
      --rp-dawn-text: #575279;
      --rp-dawn-love: #b4637a;
      --rp-dawn-gold: #ea9d34;
      --rp-dawn-rose: #d7827e;
      --rp-dawn-pine: #286983;
      --rp-dawn-foam: #56949f;
      --rp-dawn-iris: #907aa9;
      --rp-dawn-highlight-low: #f4ede8;
      --rp-dawn-highlight-low-alpha: #6e6a860d;
      --rp-dawn-highlight-med: #dfdad9;
      --rp-dawn-highlight-med-alpha: #6e6a8614;
      --rp-dawn-highlight-high: #cecacd;
      --rp-dawn-highlight-high-alpha: #6e6a8626;
    }

    /** variables **/
    :root {
      --nav-width: 300px;
      --aside-width: 60px;
      --gap: 1rem;
      --paper-padding: calc(var(--gap) * 3);
      cursor: default;
    }
    .settings .colors button.white {
      --body-font-color: rgb(27, 27, 27);
      --body-background-color: rgb(230, 230, 230);
      --paper-background-color: rgb(255, 255, 255);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(65, 110, 210);
      --horizontal-line-color: rgb(220, 220, 220);
    }
    :root[data-color\:light=white] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    :root[data-color\:dark=white] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(27, 27, 27);
        --body-background-color: rgb(230, 230, 230);
        --paper-background-color: rgb(255, 255, 255);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(65, 110, 210);
        --horizontal-line-color: rgb(220, 220, 220);
      }
    }
    .settings .colors button.sepia {
      --body-font-color: rgb(79, 50, 28);
      --body-background-color: rgb(225, 216, 200);
      --paper-background-color: rgb(248, 241, 227);
      /*--paper-shadow-color: rgba(0, 0, 0, .2); */
      --link-color: rgb(209, 150, 0);
      --horizontal-line-color: rgb(230, 218, 201);
    }
    :root[data-color\:light=sepia] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    :root[data-color\:dark=sepia] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(79, 50, 28);
        --body-background-color: rgb(225, 216, 200);
        --paper-background-color: rgb(248, 241, 227);
        /*--paper-shadow-color: rgba(0, 0, 0, .2); */
        --link-color: rgb(209, 150, 0);
        --horizontal-line-color: rgb(230, 218, 201);
      }
    }
    .settings .colors button.gray {
      --body-font-color: rgba(255, 255, 255, 0.78);
      --body-background-color: rgb(50, 50, 51);
      --paper-background-color: rgb(74, 74, 77);
      /*--paper-shadow-color: rgba(0, 0, 0, .24); */
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(111, 111, 111);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=gray] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=gray] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgba(255, 255, 255, 0.78);
        --body-background-color: rgb(50, 50, 51);
        --paper-background-color: rgb(74, 74, 77);
        /*--paper-shadow-color: rgba(0, 0, 0, .24); */
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(111, 111, 111);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.night {
      --body-font-color: rgb(176, 176, 176);
      --body-background-color: rgb(0, 0, 0);
      --paper-background-color: rgb(18, 18, 18);
      --paper-outline-color: #272727;
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(62, 62, 62);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=night] {
      @media (prefers-color-scheme:light) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=night] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: rgb(176, 176, 176);
        --body-background-color: rgb(0, 0, 0);
        --paper-background-color: rgb(18, 18, 18);
        --paper-outline-color: #272727;
        --link-color: rgb(90, 200, 250);
        --horizontal-line-color: rgb(62, 62, 62);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine {
      --body-font-color: var(--rp-main-subtle);
      --body-background-color: var(--rp-main-surface);
      --paper-background-color: var(--rp-main-base);
      --paper-outline-color: var(--rp-main-highlight-med-alpha);
      --link-color: var(--rp-main-pine);
      --horizontal-line-color: var(--rp-main-highlight-high-alpha);
      --selection-bg: var(--rp-main-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-main-subtle);
        --body-background-color: var(--rp-main-surface);
        --paper-background-color: var(--rp-main-base);
        --paper-outline-color: var(--rp-main-highlight-med-alpha);
        --link-color: var(--rp-main-pine);
        --horizontal-line-color: var(--rp-main-highlight-high-alpha);
        --selection-bg: var(--rp-main-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-moon {
      --body-font-color: var(--rp-moon-subtle);
      --body-background-color: var(--rp-moon-surface);
      --paper-background-color: var(--rp-moon-base);
      --paper-outline-color: var(--rp-moon-highlight-med-alpha);
      --link-color: var(--rp-moon-rose);
      --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
      --selection-bg: var(--rp-moon-highlight-med);
      --body-font-smoothing: antialiased;
    }
    :root[data-color\:light=rose-pine-moon] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    :root[data-color\:dark=rose-pine-moon] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-moon-subtle);
        --body-background-color: var(--rp-moon-surface);
        --paper-background-color: var(--rp-moon-base);
        --paper-outline-color: var(--rp-moon-highlight-med-alpha);
        --link-color: var(--rp-moon-rose);
        --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
        --selection-bg: var(--rp-moon-highlight-med);
        --body-font-smoothing: antialiased;
      }
    }
    .settings .colors button.rose-pine-dawn {
      --body-font-color: var(--rp-dawn-text);
      --body-background-color: var(--rp-dawn-base);
      --paper-background-color: var(--rp-dawn-overlay);
      --paper-outline-color: var(--rp-dawn-highlight-med);
      --link-color: var(--rp-dawn-love);
      --horizontal-line-color: var(--rp-dawn-highlight-high);
      --selection-bg: var(--rp-dawn-highlight-med);
    }
    :root[data-color\:light=rose-pine-dawn] {
      @media (prefers-color-scheme:light) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }
    :root[data-color\:dark=rose-pine-dawn] {
      @media (prefers-color-scheme:dark) {
        --body-font-color: var(--rp-dawn-text);
        --body-background-color: var(--rp-dawn-base);
        --paper-background-color: var(--rp-dawn-overlay);
        --paper-outline-color: var(--rp-dawn-highlight-med);
        --link-color: var(--rp-dawn-love);
        --horizontal-line-color: var(--rp-dawn-highlight-high);
        --selection-bg: var(--rp-dawn-highlight-med);
      }
    }

    :root,
    :root[data-paper-size=sm] { --paper-width: 90ex; }
    :root[data-paper-size=md] { --paper-width: 120ex; }
    :root[data-paper-size=lg] { --paper-width: 160ex; }
    :root[data-paper-size=xl] { --paper-width: 100%; }

    *::selection {
      background-color: var(--selection-bg);
    }

    /** layout **/
    body {
      display: grid;
      grid-template-columns: minmax(var(--nav-width), 1fr) minmax(auto, calc(var(--paper-width) + 2*var(--paper-padding))) minmax(var(--aside-width), 1fr);
    }

    /** global **/
    html,
    body {
      font: 16pt/1.4 Reader;
      color: var(--body-font-color);
      background: var(--body-background-color);
      font-variant-numeric: oldstyle-nums tabular-nums slashed-zero;
      -webkit-font-smoothing: var(--body-font-smoothing, normal);
    }
    a {
      color: var(--link-color);
    }

    @property --scroll-progress {
      syntax: '<percentage>';
      initial-value: 100%;
      inherits: false;
    }
    @keyframes scrollProgress {
      0% {
        --scroll-progress: 0%;
      }
      100% {
        --scroll-progress: 100%;
      }
    }

    /** nav **/
    nav {
      height: 100vh;
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: sticky;
      top: 0;
      padding: calc(var(--gap) * 0.75);
      font-size: 0.875rem;
      line-height: 1.2;
      ol {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.5em;
        align-items: start;
        li {
          /**/
          max-width: 100%;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          /**/
          padding-top: 0.1ex;
          padding-bottom: 0.1ex;
          padding-left: calc(var(--gap) * 0.25);
          padding-right: calc(var(--gap) * 0.25);
          &.active {
            background: var(--body-font-color);
            outline: calc(var(--gap) * 0.15) solid var(--body-font-color);
            border-radius: 0.5ex;
            color: var(--body-background-color);
            a {
              pointer-events: none;
              color: inherit;
            }
          }
          a {
            color: var(--body-font-color);
            &:hover {
              color: var(--link-color);
            }
          }
          &:first-child a {
            font-weight: bold;
          }
        }
      }
    }

    /** aside **/
    aside {
      position: sticky;
      top: 0;
      height: 100vh;
    }
    aside a,
    aside button {
      appearance: none;
      background: var(--paper-background-color);
      color: var(--body-font-color);
      outline: 1px solid var(--horizontal-line-color);
      width: 100%;
      min-width: 25px;
      aspect-ratio: 1;
      display: grid;
      place-content: center;
      border-radius: 50%;
      cursor: pointer;
    }
    aside > div {
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      padding-left: var(--gap);
      padding-right: var(--gap);
      display: flex;
      flex-direction: column;
      row-gap: calc(var(--gap) * .5);
      width: var(--aside-width);
    }
    aside > div + div {
      position: relative;
    }
    aside > div + div::before {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate3d(-50%, 0, 0);
      content: '';
      display: block;
      width: calc(var(--gap) * 2);
      height: 1px;
      background: var(--horizontal-line-color);
      opacity: 0.5;
    }
    aside .colors button {
      &::before {
        content: var(--checkmark);
        font-size: .7em;
      }
      @media (prefers-color-scheme:light) {
        &.checked\:light {
          --checkmark: '✔';
        }
      }
      @media (prefers-color-scheme:dark) {
        &.checked\:dark {
          --checkmark: '✔';
        }
      }
    }
    aside a.close {
      position: relative;
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::before,
      &::after {
        content: '';
        display: block;
        width: 50%;
        height: 1px;
        transform: translate3d(-50%, -50%, 0) rotateZ(var(--rotate, 45deg));
        position: absolute;
        top: 50%;
        left: 50%;
        background: currentColor;
      }
      &::after {
        --rotate: -45deg;
      }

      outline: 0;
      background: radial-gradient(closest-side, var(--paper-background-color) 79%, transparent 80% 100%), conic-gradient(var(--link-color) var(--scroll-progress, 0%), var(--horizontal-line-color) 0);
      animation: scrollProgress auto linear;
      animation-timeline: scroll();
    }
    aside button.refresh {
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
      &::after {
        content: '↻';
        font-size: 1rem;
        position: relative;
        top: -1px;
      }
    }
    aside .paper-size button {
      border-radius: 0.75ex;
      outline-width: 0;
      &.selected {
        font-weight: bold;
      }
    }
    aside button.zen {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: 'ℤ';
      }
    }
    aside button.names-editor {
      border-radius: 0.75ex;
      outline-width: 0;
      &::after {
        content: 'ℕ';
      }
    }

    /** main **/
    main {
      /**
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      /**/
      display: flex;
      background: var(--paper-background-color);
      padding: 1rem 3rem;
      outline: 1px solid var(--paper-outline-color, transparent);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color, transparent);
      article {
        flex: 1;
        text-indent: 3ch;
        max-width: var(--paper-width, 90ex);
        margin: 0 auto;
        p:first-child {
          line-height: 1.2;
          font-size: 1.5rem;
          font-weight: bold;
        }
        hr {
          background: var(--horizontal-line-color);
        }

        ::highlight(name) {
          color: var(--link-color);
        }
      }
    }

    /** table **/
    .table {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      row-gap: var(--gap);
      column-gap: calc(var(--gap) * 2);
      padding: 0 var(--gap) var(--gap);
      background: var(--paper-background-color);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color);
      outline: 1px solid var(--paper-outline-color);
      line-height: 1.2;
      align-self: stretch;
      align-content: start;
    }
    .table .name {
      font-weight: bold;
    }
    .table .th {
      white-space: nowrap;
      padding: calc(var(--gap)/2) 0;
      position: sticky;
      top: 0;
      background: var(--paper-background-color);
    }
    .table .th::before {
      content: '';
      display: block;
      border-bottom: 1px solid var(--horizontal-line-color);
      width: calc(100% + 1ex);
      height: calc(2ex + 2px);
      box-shadow: 0 calc(1ex - 5px) 1.4ex -1ex rgba(0, 0, 0, .5);
      position: absolute;
      bottom: -1px;
      left: calc(-1ex / 2);
    }
    .table .th span {
      display: inline-block;
      position: relative;
    }
    .table .th span::after {
      position: absolute;
      bottom: calc(1ex/4);
      right: -1.8ex;
      color: var(--body-font-color);
    }
    .table .th[data-sort=asc] span::after { content: '↑'; }
    .table .th[data-sort=desc] span::after { content: '↓'; }
    .table .desc { display: block; }
    .table .delete { color: inherit; }
    .table .delete:hover { color: var(--link-color); }

    /** disable scroll when mouse is not over **/
    /**
    nav,
    main {
      height: 100%;
      overflow-y: hidden;
    }
    nav:hover,
    main:hover {
      overflow-y: auto;
    }
    /**/

    /** zen mode **/
    [data-zen=true] nav {
      opacity: 0;
      transition: opacity .15s ease-in-out;
      &:hover {
        opacity: 1;
      }
    }

    /** command palette **/
    #command-palette[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      max-height: 70%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      padding: 0.7ex;

      form {
        display: contents;

        input {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
        }
      }

      ul {
        list-style: none;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overscroll-behavior-y: contain;
        position: relative;
        margin-top: 0.7ex;
        gap: 1px;

        li {
          a {
            display: block;
            padding: 0.5ex 1.3ex;
            border-radius: 0.8ex;
            color: var(--body-font-color);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }

          &:hover,
          &.selected {
            a {
              background: var(--paper-background-color);
            }
          }

          ::highlight(match) {
            background: yellow;
          }
        }
      }
    }

    /** names editor **/
    #names-editor[open] {
      --width: calc(var(--paper-width) - 80px);
      width: var(--width);
      height: 80%;
      position: fixed;
      top: 10%;
      left: calc((100% - var(--width)) / 2);
      border-radius: 1.5ex;
      overflow: hidden;
      box-shadow: 0 10px 20px rgba(0,0,0,.2);
      border: 1px solid var(--horizontal-line-color);
      background: var(--body-background-color);
      display: flex;
      flex-direction: column;
      gap: 0.7ex;
      padding: 0.7ex;

      form {
        display: contents;

        textarea {
          background: var(--paper-background-color);
          font-size: inherit;
          padding: 1ex 1.3ex;
          border: 1px solid var(--paper-outline-color);
          border-radius: 0.8ex;
          color: var(--body-font-color);
          flex: 1;
        }

        button {
          appearance: none;
          background: transparent;
          /**
          &:hover,
          &:focus,
          &:active {
            background: var(--paper-background-color);
          }
          /**/
          color: var(--body-font-color);
          width: 100%;
          min-width: 25px;
          display: grid;
          place-content: center;
          border-radius: 0.8ex;
          cursor: pointer;
          font-size: inherit;
          line-height: 1.8;
        }
      }
    }

    .text-left { text-align: left; }
    .text-right { text-align: right; }
    .text-center { text-align: center; }
    .indent-none { text-indent: 0; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, text, app } from 'https://cdn.jsdelivr.net/npm/hyperapp/+esm';
    import { openDB } from 'https://cdn.jsdelivr.net/npm/idb/+esm';
    import { generateColor as stc } from 'https://cdn.jsdelivr.net/npm/@marko19907/string-to-color/+esm'
    import _ from 'https://cdn.jsdelivr.net/npm/lodash-es/+esm'

    class HashRouter extends EventTarget {
      parse(hash) {
        return [...(new URLSearchParams(hash)).entries()].reduce((route, [k, v]) => (route[k] = v, route), {});
      }
      get(key) {
        return new URLSearchParams(location.hash.slice(1)).get(key);
      }
      current() {
        return this.parse(location.hash.slice(1));
      }
      route(route) {
        let hash = new URLSearchParams(Object.entries(route).filter(([k, v]) => v !== '' && v != null)).toString();
        if (hash) hash = '#' + hash;
        return hash;
      }
      push(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.pushState(null, null, url);
        }
      }
      replace(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.replaceState(null, null, url);
        }
      }
    }

    let InitDbDone = (state, { db }) => [
      { ...state, db },
      (dispatch) => {
        window.db = db;
        dispatch(LoadSettings);
        dispatch(LoadProgress);
        dispatch(LoadRecentBooks);
        dispatch(LoadRecentBook);
      }
    ];
    let InitDb = (state) => [
      state,
      async (dispatch) => {
        let db = await openDB('text-reader', 23, {
          upgrade(db, oldVersion, newVersion, transaction, events) {
            console.log('upgrade db', { oldVersion, newVersion, transaction, events });
            let schemas = {
              files: {},
              fileContents: {},
              settings: {},
              progress: {},
              books: {},
              chapters: {},
              names: {},
            };
            for (let [store, keyOptions] of Object.entries(schemas)) {
              if (!db.objectStoreNames.contains(store)) {
                db.createObjectStore(store, keyOptions);
              }
            }
            //for(let store of db.objectStoreNames) {
            //  if (!(store in schemas)) {
            //    console.warn('Delete store', store);
            //    db.deleteObjectStore(store);
            //  }
            //}
          },
          blocked: console.log,
          blocking: console.log,
          terminated: console.log,
        });

        dispatch(InitDbDone, { db });
      }
    ];

    let InitTheme = (state) => [
      state,
      (dispatch) => {
        let colors = { 'color:dark': 'night', 'color:light': 'white' };
        dispatch(ApplySettings, colors);
      }
    ];

    let InitRouter = (state) => [
      state,
      (dispatch) => {
        addEventListener('hashchange', (event) => {
          let from = state.router.parse(new URL(event.oldURL).hash.slice(1));
          let to = state.router.parse(new URL(event.newURL).hash.slice(1));
          if (!to.book) {
            dispatch(ShowRecentBooks);
          } else {
            dispatch(OpenBook, { bookId: to.book, chapterId: to.chapter });
          }
        });
      }
    ];

    let InitKeyboardNavigator = (dispatch) => {
      let onKeyDown = (event) => {
        let formElements = ['INPUT', 'TEXTAREA', 'SELECT', 'OPTION'];
        if(formElements.includes(event.target.tagName)) return;

        switch(event.key) {
          case 'ArrowRight': dispatch(OpenNextChapter, +1); break;
          case 'ArrowLeft': dispatch(OpenNextChapter, -1); break;
          case 'Backspace': dispatch(ShowRecentBooks); break;
          default: break;
        }
      };
      addEventListener('keydown', onKeyDown);
      return () => removeEventListener('keydown', onKeyDown);
    };

    let InitCommandPalette = async (dispatch) => {
      onKey('Cmd+K', ToggleCommandPalette)(dispatch);
      onKey('Escape', [ToggleCommandPalette, { open: false }])(dispatch);

      await nextTick();
      let dialog = document.querySelector('#command-palette');
      onKey('ArrowUp', SelectPrevCommand, { target: dialog })(dispatch);
      onKey('ArrowDown', SelectNextCommand, { target: dialog })(dispatch);
    };

    let ToggleCommandPalette = (state, options) => {
      let open = options?.open != null ? !!options.open : !state.commandPalette.open;
      return [
        {
          ...state,
          commandPalette: {
            ...state.commandPalette,
            open,
          }
        },
        async (dispatch) => {
          if(open) {
            await nextTick();
            document.querySelector('#command-palette input').select();
            dispatch(HighlightMatches);
          }
        }
      ];
    };

    let SelectCommand = (state, index) => [
      {
        ...state,
        commandPalette: {
          ...state.commandPalette,
          selectedIndex: index,
        }
      },
      async () => {
        await nextTick();

        //scroll selected command into view
        let ul = document.querySelector('#command-palette ul');
        if (!ul) return;
        let li = ul.querySelector('li.selected');
        if (li.offsetTop < ul.scrollTop) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop });
        } else if (ul.scrollTop + ul.clientHeight < li.offsetTop + li.clientHeight) {
          ul.scroll({ behavior: 'instant', top: li.offsetTop + li.clientHeight - ul.clientHeight });
        }
      }
    ];

    let SelectNextCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex + 1];
    let SelectPrevCommand = (state) => [SelectCommand, state.commandPalette.selectedIndex - 1];

    let SetCommandQuery = (state, q) => ({
      ...state,
      commandPalette: {
        ...state.commandPalette,
        q: q.trim().toLowerCase(),
      },
    });

    let ExecuteSelectedCommand = state => state;
    let HighlightMatches = (state) => [
      state,
      async () => {
        await nextTick();

        let ranges = [];
        let q = state.commandPalette.q;
        document.querySelectorAll('#command-palette a').forEach(el => {
          let text = el.firstChild;
          let match = latinize(text.textContent).toLowerCase();
          if(match.includes(q)) {
            let start = match.indexOf(q);
            let end = start + q.length;
            let range = new Range();
            range.setStart(text, start);
            range.setEnd(text, end);
            ranges.push(range);
          }
        });
        let hl = new Highlight(...ranges);
        CSS.highlights.set('match', hl);
      }
    ];

    let MultipleActions = (state, actions) => [
      state,
      async (dispatch) => {
        for(let action of actions) {
          await nextTick();
          dispatch(...[].concat(action));
        }
      }
    ];

    let nextTick = async () => {
      await new Promise(resolve => requestAnimationFrame(resolve));
      await new Promise(resolve => requestAnimationFrame(resolve));
    };

    let onKey = (key, action, options) => (dispatch) => {
      let el = options?.target || window;
      let onKeyDown = (event) => {
        let opts = key.toLowerCase().split('+').reduce((opts, k) => {
          switch(k) {
            case 'ctrl':
            case 'shift':
            case 'alt':
              opts[k + 'Key'] = true;
              break;
            case 'cmd':
            case 'win':
            case 'super':
              opts.metaKey = true;
              break;
            default:
              opts.key = k;
          }
          return opts;
        }, {});
        if(event.key.toLowerCase() == opts.key.toLowerCase() && ['metaKey', 'ctrlKey', 'shiftKey', 'altKey'].every(f => Boolean(event[f]) == Boolean(opts[f]))) {
          event.preventDefault();
          dispatch(action);
        }
      };
      el.addEventListener('keydown', onKeyDown);
      return () => el.removeEventListener('keydown', onKeyDown);
    };

    let LoadSettings = (state) => [
      state,
      async (dispatch) => {
        let settings = {};
        let cursor = await state.db.transaction('settings').store.openCursor();
        while (cursor) {
          settings[cursor.key] = cursor.value;
          cursor = await cursor.continue();
        }
        dispatch(ApplySettings, settings);
      }
    ];
    let ApplySettings = (state, settings) => [
      { ...state, settings: { ...state.settings, ...settings } },
      () => {
        for (let [key, value] of Object.entries(settings)) {
          document.documentElement.dataset[key] = (value ?? '');
        }
      }
    ];
    let SaveSettings = (state, settings) => [
      state,
      async (dispatch) => {
        dispatch(ApplySettings, settings);

        let tx = state.db.transaction('settings', 'readwrite');
        await Promise.all([
          ...Object.entries(settings).map(([key, value]) => {
            document.documentElement.dataset[key] = (value || '');
            return tx.store.put(value, key);
          }),
          tx.done,
        ]);
      }
    ];

    let LoadRecentBooksDone = (state, { files }) => ({ ...state, files });
    let LoadRecentBooks = (state) => [
      state,
      async (dispatch) => {
        let files = await state.db.getAll('files');
        files.sort((a, z) => a.name.localeCompare(z.name, 'vi-VN', { sensitivity: 'accent' }));
        dispatch(LoadRecentBooksDone, { files });
      }
    ];

    let LoadProgressDone = (state, { progress }) => ({ ...state, progress });
    let LoadProgress = (state) => [state, async (dispatch) => {
      let progress = {};
      let cursor = await state.db.transaction('progress').store.openCursor();
      while (cursor) {
        progress[cursor.key] = cursor.value;
        cursor = await cursor.continue();
      }
      dispatch(LoadProgressDone, { progress });
    }];

    let LoadRecentBook = (state) => [
      state,
      (dispatch) => {
        let bookId = state.router.get('book');
        let chapterId = state.router.get('chapter');
        if (bookId) {
          dispatch(OpenBook, { bookId, chapterId })
        }
      }
    ];

    let OpenBookDone = (state, { book, chapter }) => [
      { ...state, book, chapter },
      (dispatch) => {
        if (state.book?.id == book.id)
          state.router.replace({ book: book.id, chapter: chapter.id });
        else
          state.router.push({ book: book.id, chapter: chapter.id });

        document.title = [...new Set([book.name, chapter.title])].join(' | ');

        requestAnimationFrame(() => {
          scroll(0, 0);

          //scroll bookmark into view
          let bookmark = document.querySelector('nav .active');
          let nav = document.querySelector('nav');
          let bookmarkRect = bookmark.getBoundingClientRect();
          let isOutOfView = bookmarkRect.top < 0 || nav.clientHeight < bookmarkRect.bottom;
          if (isOutOfView) bookmark.scrollIntoView({ block: 'center' });
        });
      }
    ];
    let OpenBook = (state, { bookId, chapterId, migrate = true, retry = true }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [book, chapter] = await Promise.all([
          state.db.get('books', bookId),
          state.db.get('chapters', bookId + '/' + chapterId),
        ]);
        if (!book) {
          console.info('Book not found:', { book, chapter });
          if (migrate) dispatch(RefreshBook, { bookId, onSuccess: [OpenBook, { bookId, chapterId, migrate: false, retry }] });
          return
        }
        if (!chapter) {
          console.info('Chapter not found:', { bookId, chapterId });
          if (retry) {
            chapterId = book.chapters[0].id;
            dispatch(OpenBook, { bookId, chapterId, retry: false });
          }
          return;
        }

        let chapters = [...book.chapters];
        let chapterIndex = chapters.findIndex(c => c.id == chapter.id);
        if (chapterIndex < 0) chapterIndex = 0;
        chapters[chapterIndex] = chapter;

        dispatch(LoadNames, { bookId: book.id });
        dispatch(OpenBookDone, { book, chapter });
        dispatch(ToggleCommandPalette, { open: false });
        clearTimeout(window.saveProgressTimer);
        window.saveProgressTimer = setTimeout(() => {
          dispatch(SaveProgress, { book, chapter });
        }, 10000);
      }
    ];

    let ToggleNamesEditor = (state, { open }) => ({ ...state, namesEditor: { ...state.namesEditor, open } });
    let SetNames = (state, names) => ({ ...state, namesEditor: { ...state.namesEditor, names } });
    let SaveNames = (state, { bookId, names }) => [state, async (dispatch) => {
      await state.db.put('names', names, bookId);
    }];
    let LoadNames = (state, { bookId }) => [state, async (dispatch) => {
      let names = await state.db.get('names', bookId);
      dispatch(SetNames, names);
      dispatch(HighlightNames);
    }];
    memoize(function correctNames(content, names) {
      if(!names) return content;
      names = names.split('\n');
      // add short name automatically
      for(let name of names) {
        if(name.match(/->|→/)) continue;
        name = name.split(/\s/);
        if(name.length == 3 || name.length == 4) names.push(name.at(-2) + ' ' + name.at(-1));
      }
      for(let name of names) {
        name = name.trim();
        if (!name) continue;
        let [from, to] = name.split(/->|→/).map(n => n?.trim());
        if(to != undefined) {
          to = useCase(from, to);
        } else {
          from = name;
          to = titleCase(name);
        }
        if(from) {
          let fromRegex = new RegExp(`(?<=^|[^\\p{L}])${from}(?=[^\\p{L}]|$)`, 'gui');
          content = content.replaceAll(fromRegex, to);
        }
      }
      return content;
    });
    let HighlightNames = (state) => [state, async () => {
      await nextTick();

      CSS.highlights.clear();

      // names from editor
      let knowNames = [];
      if(state.namesEditor.names) {
        let names = (state.namesEditor.names || '').split('\n');
        // add short name automatically
        for(let name of names) {
          if(name.match(/->|→/)) continue;
          name = name.split(/\s/);
          if(name.length == 3 || name.length == 4) names.push(name.at(-2) + ' ' + name.at(-1));
        }
        for(let name of names) {
          name = name.trim();
          if (!name) continue;
          let [from, to] = name.split(/->|→/).map(n => n?.trim());
          if(to == undefined) {
            from = name;
            to = titleCase(name);
          }
          if(to && getCase(to) != 'lower') {
            knowNames.push(to);
          }
        }
      }

      // collect names
      let nameRegex = buildRegex([
        /{NameBegin}{Word}(\s{Word}){1,3}/,
        /{wb}a {Word}(?!{Word})/,
        /{NameBegin}{Word} (thúc|di|ca( ca)?|tỷ( tỷ)?|tổng|lang|nô|bá bá|bá phụ|bá mẫu|đại tỷ|đại ca){wb}/,
        /(tiểu|lão) {Word}(?!{wb}{Word})/,
        knowNames.join('|'),
      ], {
        'wb': /$|(?<=[^\p{L}])|(?=[^\p{L}])/,
        'Upper': /\p{Lu}/,
        'Lower': /\p{Ll}/,
        'Word': /{wb}{Upper}{Lower}*{wb}/,
        'NameBegin': /(?<!^|[.:"'!?()[\]] ?|{Word} )/,
      }, 'gu');
      let names = new Set();
      document.querySelectorAll('article p, nav a').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          for(let match of el.textContent.matchAll(nameRegex)) {
            let name = match[0];
            names.add(name);
            name = name.split(/\s/);
            if(name.length == 3 || name.length == 4) names.add(name.at(-2) + ' ' + name.at(-1));
          }
        });
      });
      console.log({names})

      // create ranges;
      nameRegex = buildRegex([
        '{wb}(' + [...names].join('|') + '){wb}',
      ], {
        'wb': /^|$|(?<=[^\p{L}])|(?=[^\p{L}])/,
      }, 'gui');
      console.log('nameRegex:', nameRegex);
      let ranges = {};
      document.querySelectorAll('article p, nav a').forEach(el => {
        el.childNodes.forEach(el => {
          if (el.nodeType != Node.TEXT_NODE) return;

          for(let match of el.textContent.matchAll(nameRegex)) {
            let range = new Range();
            range.setStart(el, match.index);
            range.setEnd(el, match.index + match[0].length);
            let nameId = match[0].toLowerCase();
            if(!ranges[nameId]) ranges[nameId] = [];
            ranges[nameId].push(range);
          }
        });
      });

      // merge sub ranges
      let nameIds = Object.keys(ranges).sort((a, z) => z.length - a.length);
      console.debug(Object.keys(ranges));
      for(let nameId in ranges) {
        let fullNameId = nameIds.find(id => id.endsWith(' ' + nameId));
        if(fullNameId) {
          ranges[fullNameId].push(...ranges[nameId]);
          delete ranges[nameId];
        }
      }
      console.debug(Object.keys(ranges));
      console.debug((ranges));

      for(let nameId in ranges) {
        let color = stc(nameId);
        let styleId = slug(nameId);
        CSS.highlights.set(styleId, new Highlight(...ranges[nameId]));
        let styleEl = document.head.querySelector(`style[name="hl-${styleId}"]`);
        if(!styleEl) {
          styleEl = document.createElement('style');
          styleEl.setAttribute('name', `hl-${styleId}`);
          styleEl.textContent = `::highlight(${styleId}) { text-decoration: underline 5px solid ${color} !important; text-underline-offset: 6px; }`;
          document.head.appendChild(styleEl);
        }
      }
    }];

    let OpenNextChapter = (state, indexDelta = 1) => [
      state,
      (dispatch) => {
        let chapterIndex = state.book.chapters.findIndex(c => c.id == state.chapter.id);
        let nextChapter = state.book.chapters[chapterIndex + indexDelta];
        if (nextChapter) {
          dispatch(OpenBook, { bookId: state.book.id, chapterId: nextChapter.id });
        }
      }
    ];

    let SaveProgressDone = (state, { book, progress }) => ({ ...state, progress: { ...state.progress, [book.id]: progress } });
    let SaveProgress = (state, { book, chapter }) => {
      return [
        state,
        async (dispatch) => {
          let progress = (await state.db.get('progress', book.id) || {});
          progress.chapterId = chapter.id;
          progress.chapterIndex = book.chapters.findIndex(c => c.id == chapter.id) + (book.chapters[0].id ? 1 : 0);
          progress.chapterCount = (book.chapters[0].id ? book.chapters.length : book.chapters.length - 1);
          progress.updatedAt = new Date().toISOString();
          await state.db.put('progress', progress, book.id);
          dispatch(SaveProgressDone, { book, progress });
        }
      ];
    };

    let InitDropzone = (state) => [
      state,
      (dispatch) => {
        addEventListener('dragenter', event => { event.preventDefault(); });
        addEventListener('dragover', event => { event.preventDefault(); });
        addEventListener('drop', event => {
          event.preventDefault();
          let files = [...event.dataTransfer.files].filter(file => file.type == 'text/plain');
          dispatch(StoreFiles, { files });
        });
      }
    ];

    let StoreFilesDone = (state, { files }) => [
      state,
      async (dispatch) => {
        //refresh recent books in state
        dispatch(LoadRecentBooks);

        let filesOpenInNewTab = files;
        let fileOpenInCurrentTab = null;
        if(state.book) {
          //if this book is already open, open other files in new tabs
          fileOpenInCurrentTab = files.find(file => (Book(file).id == state.book.id));
          filesOpenInNewTab = files.filter(file => (file != fileOpenInCurrentTab));
        } else {
          //if no book is open, open the first file in current tab, other files in new tabs
          [fileOpenInCurrentTab, ...filesOpenInNewTab] = files;
        }

        if(fileOpenInCurrentTab) {
          let book = Book(fileOpenInCurrentTab);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          state.router.push({ book: book.id, chapterId });
          dispatch(OpenBook, { bookId: book.id, chapterId });
        }
        for(let { file } of filesOpenInNewTab) {
          let book = Book(file);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          window.open(`#book=${book.id}&chapter=${chapterId}`, '_blank');
        }
      }
    ];
    let StoreFiles = (state, { files: localFiles, fileContents }) => [
      state,
      async (dispatch) =>  {
        let readFile = (localFile) => new Promise(resolve => {
          let reader = new FileReader();
          reader.addEventListener('load', event => {
            let file = {
              name: localFile.name,
              size: localFile.size,
            };
            let fileContent = event.target.result;
            resolve({ file, fileContent });
          });
          reader.readAsText(localFile);
        });

        let files = [];
        for (let localFile of localFiles) {
          files.push(await readFile(localFile));
        }

        dispatch(StoreBooks, { files, onSuccess: [StoreFilesDone, { files }] });
        /**
        for (let i = 0; i < localFiles.length; i++) {
          let reader = new FileReader();
          reader.addEventListener('load', async event => {
            fileContents[i] = event.target.result;
            files[i] = {
              name: localFiles[i].name,
              size: localFiles[i].size,
            };

            let book = Book(files[i]);
            let existingFile = await state.db.get('files', book.id);
            if (existingFile?.size != files[i].size) {
              book = Book(files[i], fileContents[i]);
              dispatch(SaveProgress, { book, chapter: book.chapters[0] });
              updated[i] = true;
            }

            let tx = state.db.transaction(['files', 'fileContents'], 'readwrite');
            await Promise.all([
              tx.objectStore('files').put(files[i], book.id),
              tx.objectStore('fileContents').put(fileContents[i], book.id),
              tx.done,
            ]);

            dispatch(StoreBook, { bookId: book.id });
            storedCount++;

            if (storedCount == localFiles.length) {

            }
          });
          reader.readAsText(localFiles[i]);
        }
        /**/
      },
    ];

    let StoreBooks = (state, { files, onSuccess }) => [
      state,
      async (dispatch) => {
        let chapterKeys = await state.db.getAllKeys('chapters');

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          ...files.flatMap(({ file, fileContent }) => {
            console.log('new Book');
            let book = Book(file, fileContent);
            return [
              tx.objectStore('files').put(file, book.id),
              tx.objectStore('fileContents').put(fileContent, book.id),
              tx.objectStore('books').put(book.toJSON(), book.id),
              ...chapterKeys.filter(k => k.startsWith(book.id + '/')).map(k => tx.objectStore('chapters').delete(k)),
              ...book.chapters.map(c => tx.objectStore('chapters').put(c.toJSON(), book.id + '/' + c.id)),
            ];
          }),
          tx.done,
        ]);

        if (onSuccess) dispatch(...onSuccess);
      }
    ];

    let RefreshBook = (state, { bookId, onSuccess }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [file, fileContent] = await Promise.all([
          state.db.get('files', bookId),
          state.db.get('fileContents', bookId),
        ]);
        if (!file || !fileContent) {
          console.info('File not found:', { bookId, file, fileContent });
          return;
        }

        if (!onSuccess) onSuccess = [OpenBook, { bookId, chapterId: state.chapter.id }];

        dispatch(StoreBooks, {
          files: [{ file, fileContent }],
          onSuccess,
        });
      }
    ];

    let DeleteBookDone = (state, { bookId }) => ({ ...state, files: state.files.filter(file => Book(file).id != bookId) });
    let DeleteBook = (state, { bookId }) => [
      state,
      async (dispatch) => {
        let chapterKeys = (await state.db.getAllKeys('chapters')).filter(k => k.startsWith(bookId + '/'));

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          tx.objectStore('files').delete(bookId),
          tx.objectStore('fileContents').delete(bookId),
          tx.objectStore('books').delete(bookId),
          ...chapterKeys.map(k => tx.objectStore('chapters').delete(k)),
          tx.done,
        ]);

        dispatch(DeleteBookDone, { bookId });
      }
    ];

    let ShowRecentBooks = (state) => {
      if (!state.book) return state;
      return [
        { ...state, book: null, chapter: null },
        (dispatch) => {
          clearTimeout(window.saveProgressTimer);
          state.router.push({});
          document.title = 'Text Reader';
          requestAnimationFrame(() => {
            scroll(0, 0);
          });
          dispatch(ToggleCommandPalette, { open: false });
        }
      ];
    };

    let sizeFormatter = new Intl.NumberFormat(undefined, { notation: 'compact', style: 'unit', unit: 'byte', unitDisplay: 'narrow' });
    let formatSize = sizeFormatter.format.bind(sizeFormatter);

    let dateFormatter = new Intl.RelativeTimeFormat();
    let formatDate = (iso) => {
      if(!iso) return;
      let diff = (Date.now () - new Date(iso)) / 1000;
      for (let [unit, seconds] of Object.entries({
        months: 30 * 24 * 60 * 60,
        days: 24 * 60 * 60,
        hours: 60 * 60,
        minutes: 60,
        seconds: 0,
      })) {
        if (diff >= seconds) return dateFormatter.format(-Math.round(diff / (seconds || 1)), unit);
      }
    };

    app({
      init: [
        {
          router: new HashRouter(),
          db: null,
          files: [],
          book: null,
          chapter: null,
          progress: {},
          settings: {
            sort: {
              field: 'updatedAt',
              direction: 'desc'
            }
          },
          commandPalette: {
            open: false,
            q: '',
            selectedIndex: 0,
          },
          namesEditor: {
            open: false,
            names: '',
            form: {
              names: '',
            },
          },
        },
        (dispatch) => {
          dispatch(InitRouter);
          dispatch(InitTheme);
          dispatch(InitDb);
          dispatch(InitDropzone);
        }
      ],
      dispatch: (dispatch) => {
        return (action, payload) => {
          if (!action) return;

          if (typeof action == 'function' && action.name.match(/^[A-Z]/)) {
            let log = [action.name];
            if (payload !== undefined) log.push(payload);
            console.warn(...log);
          }

          dispatch(action, payload);
        };
      },
      subscriptions: (state) => [
        [InitKeyboardNavigator],
        [InitCommandPalette],
      ],
      node: document.body,
      view: ({ router, files, book, chapter, progress, settings, commandPalette, namesEditor }) => {
        let fixNames = text => correctNames(text, namesEditor.names);
        let cachedCommands = window.cachedCommands = (window.cachedCommands || new Map());
        let commands = [], selectedCommand, commandKey;
        if(!book) {
          commands = simpleCache({
            key: 'commands/books',
            fallbackValue: [],
            getHash() { return files.length; },
            getValue() {
              return files.map((file, index) => {
                let book = Book(file);
                let { chapterId } = (progress[book.id] || {});
                return {
                  label: book.name,
                  action: OpenBook,
                  payload: { bookId: book.id, chapterId },
                  term: latinize(book.name).toLowerCase(),
                };
              });
            },
          });
        } else {
          commands = simpleCache({
            key: 'commands/books/' + book.id,
            fallbackValue: [],
            getHash() {
              let file = files.find(f => Book(f).id == book.id);
              return file.size;
            },
            getValue() {
              return book.chapters.map(chapter => ({
                label: fixNames(chapter.title),
                action: OpenBook,
                payload: { bookId: book.id, chapterId: chapter.id },
                term: latinize(chapter.title).toLowerCase(),
              }));
            },
          });
        }
        commands = commands.filter(cmd => cmd.term.includes(commandPalette.q)) ?? [];
        selectedCommand = commands[(commandPalette.selectedIndex + commands.length) % commands.length];
        return (
          h('body', {}, [
            h('nav', {}, [
              (book?.chapters?.length > 0) && (
                h('ol', { start: 0 }, [
                  ...book.chapters.map(c => (
                    h('li', { class: { active: c.id == chapter.id } }, [
                      h('a', {
                        href: router.route({ book: book.id, chapter: c.id }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId: c.id }];
                        },
                        title: fixNames(c.title),
                      }, [
                        text(fixNames(c.title))
                      ])
                    ])
                  ))
                ])
              )
            ]),
            !book && (
              h('div', { class: 'table' }, [
                h('a', {
                  class: 'th text-left',
                  'data-sort': settings.sort.field == 'name' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'name', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('File'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'size' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'size', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Size'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'chapterCount' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'chapterCount', direction = 'asc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Chapters'))),
                h('a', {
                  class: 'th text-right',
                  'data-sort': settings.sort.field == 'updatedAt' && settings.sort.direction,
                  href: '#',
                  onclick: (_, event) => {
                    event.preventDefault();
                    let field = 'updatedAt', direction = 'desc';
                    if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                    return [SaveSettings, { sort: { field, direction } }];
                  }
                }, h('span', {}, text('Date'))),
                h('span', { class: 'th' }, h('span', {})),
                ...files.sort((a, z) => {
                  let { field, direction } = settings.sort;
                  let A = Book(a), Z = Book(z);
                  let result;
                  if (field == 'name') {
                    result = A.name.localeCompare(Z.name, 'vi-VN', { sensitivity: 'accent' });
                  } else if (field == 'size') {
                    result = a[field] - z[field];
                  } else if (field == 'updatedAt') {
                    a = new Date(progress[A.id]?.[field] || 0);
                    z = new Date(progress[Z.id]?.[field] || 0);
                    result = a - z;
                  } else if (field == 'chapterCount') {
                    result = (progress[A.id]?.[field] || 1) - (progress[Z.id]?.[field] || 1);
                  }
                  if ((direction == 'desc') && (result != 0)) result = -result;
                  return result;
                }).flatMap(file => {
                  let book = Book(file);
                  let { chapterId, chapterIndex, chapterCount, updatedAt } = (progress[book.id] || {});
                  return [
                    h('div', { class: 'td' }, [
                      h('a', {
                        class: 'name',
                        href: router.route({ book: book.id, chapter: chapterId }),
                        onclick: (_, event) => {
                          event.preventDefault();
                          return [OpenBook, { bookId: book.id, chapterId }];
                        }
                      }, [
                        text(book.name)
                      ]),
                      book.description && (
                        h('small', { class: 'desc' }, text(book.description))
                      )
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatSize(file.size)))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(!chapterCount ? '-' : `${chapterIndex}/${chapterCount}`))
                    ]),
                    h('div', { class: 'td text-right' }, [
                      h('small', {}, text(formatDate(updatedAt) || '-'))
                    ]),
                    h('div', { class: 'td' }, [
                      h('a', { class: 'delete', onclick: [DeleteBook, { bookId: book.id }] }, [
                        h('small', {}, text('delete'))
                      ])
                    ])
                  ]
                })
              ])
            ),
            chapter && (
              h('main', {}, [
                h('article', {}, [
                  ...fixNames(chapter.content).split(/\n|<\/?\w+>/gi).map(line => {
                    if (/^[-]+$/.test(line)) return h('hr', {});
                    if (/^[^\p{L}\p{N}"]+$/u.test(line)) return h('p', { class: 'text-center indent-none' }, text(line));
                    let content = [], m;
                    while ((m = /https?:\/\/\S+/.exec(line))) {
                      if (m.index > 0) content.push(text(line.slice(0, m.index)));
                      content.push(h('a', { href: m[0], target: '_blank' }, [text(m[0])]));
                      line = line.slice(m.index + m[0].length);
                    }
                    if (line) content.push(text(line));
                    // if (/^"/.test(line)) return h('p', {}, h('em', {}, text(line)));
                    return h('p', {}, content);
                  })
                ])
              ])
            ),
            h('aside', { class: 'settings' }, [
              chapter && (
                h('div', {}, [
                  h('a', {
                    class: 'close',
                    href: router.route({}),
                    onclick: (_, event) => {
                      event.preventDefault();
                      return [ShowRecentBooks];
                    },
                    title: 'Back to bookshelf',
                  })
                ])
              ),
              h('div', { class: 'colors' }, ['white', 'sepia', 'gray', 'night', 'rose-pine', 'rose-pine-moon', 'rose-pine-dawn'].map(color => (
                h('button', {
                  class: [color, { 'checked:light': settings['color:light'] == color, 'checked:dark': settings['color:dark'] == color }],
                  onclick: () => [SaveSettings, { [`color:${getColorScheme()}`]: color }],
                  title: `Theme: ${color}`,
                })
              ))),
              h('div', { class: 'paper-size' }, ['sm', 'md', 'lg', 'xl'].map(size => (
                h('button', {
                  class: ['size', size, { selected: settings.paperSize == size }],
                  onclick: [SaveSettings, { paperSize: size }],
                  title: `Page size: ${size}`,
                }, text(size))
              ))),
              chapter && (
                h('div', {}, [
                  h('button', {
                    class: 'refresh',
                    onclick: [RefreshBook, { bookId: book.id, chapterId: chapter.id }],
                    title: 'Refresh book',
                  }),
                  h('button', {
                    class: 'zen',
                    onclick: [SaveSettings, { zen: !settings.zen }],
                    title: 'Toggle Zen Mode',
                  }),
                  h('button', {
                    class: 'names-editor',
                    onclick: [ToggleNamesEditor, { open: true }],
                    title: 'Edit names',
                  }),
                ])
              )
            ]),
            h('dialog', { id: 'command-palette', open: commandPalette.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [selectedCommand.action, selectedCommand.payload],
                    [ToggleCommandPalette, { open: false }],
                  ]];
                }
              }, [
                h('input', {
                  oninput: (_, event) => [MultipleActions, [
                    [SetCommandQuery, event.target.value],
                    [SelectCommand, 0],
                    [HighlightMatches],
                  ]],
                }),
                h('input', { type: 'submit', hidden: true }),
              ]),
              commands.length > 0 && h('ul', {}, [
                ...commands.map((command, index) => (
                  h('li', {
                    class: { selected: command == selectedCommand }
                  },
                    h('a', {
                      href: router.route({ book: command.payload.bookId, chapter: command.payload.chapterId }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [MultipleActions, [
                          [SelectCommand, index],
                          [command.action, command.payload],
                          [ToggleCommandPalette, { open: false }],
                        ]]
                      },
                      title: command.label,
                    },[
                      text(command.label),
                    ])
                  )
                ))
              ])
            ]),
            h('dialog', { id: 'names-editor', open: namesEditor.open }, [
              h('form', {
                onsubmit: (_, event) => {
                  event.preventDefault();
                  return [MultipleActions, [
                    [ToggleNamesEditor, { open: false }],
                    [SaveNames, { bookId: book.id, names: namesEditor.names }],
                    [HighlightNames],
                  ]];
                }
              }, [
                h('textarea', {
                  value: namesEditor.names,
                  oninput: (_, event) => [SetNames, event.target.value],
                  onkeydown: (_, event) => {
                    if (event.key == 'Escape') {
                      return [ToggleNamesEditor, { open: false }];
                    } else if (event.key == 'Enter' && event.metaKey) {
                      return [MultipleActions, [
                        [ToggleNamesEditor, { open: false }],
                        [SaveNames, { bookId: book.id, names: namesEditor.names }],
                        [HighlightNames],
                      ]];
                    }
                  },
                }),
                h('button', { type: 'submit' }, [text('Save')]),
              ])
            ])
          ])
        );
      }
    });

    function Book(file, fileContent, chapters) {
      let id, name, description;
      if (file?.name) {
        name = /(?<name>^[^(]*).*?\.txt/.exec(file.name.normalize()).groups.name.trim();
        description = /(?<description>\(.*)\.txt/.exec(file?.name.normalize())?.groups?.description?.trim();
        id = slug(name);
      }
      if (fileContent) {
        fileContent = normalizeFileContent(fileContent);
        // fileContent = titleizeHumanName(fileContent);
        chapters = extractChapters(name, fileContent, { name });
      }
      return {
        id,
        name,
        description,
        chapters,
        toJSON() {
          return {
            id,
            name,
            description,
            chapters: chapters.map(c => {
              c = c.toJSON();
              delete c.content;
              return c;
            }),
          }
        }
      };
    }

    function normalizeFileContent(text) {
      text = text.normalize();
      text = text.replace(/[\r\n]+/g, '\n');
      text = text.replace(/\t+/g, '\n');
      text = text.replace(/(?<=\S) {2,}(?=\p{Lu})/gu, '\n');
      text = text.replace(/(.+)/g, (s) => s.trim());
      text = text.replace(/^'([^']+)'$/gm, '"$1"');
      text = text.replace(/(\d)\s*(\.)\s*(\d)/gm, '$1$2$3');
      text = text.replace(/\s+([.,;:?!\]】)])/gm, '$1');
      text = text.replace(/([([【])\s+/gm, '$1');
      text = text.replace(/([:—]{2,})/gm, c => c.slice(0, 1));
      text = text.replace(/(:)[^\s\w]+\s*/gm, '$1 ');
      text = text.replace(/^\s*"\s+|\s+"\s*$/gm, '"');
      //"QQ Group 712797052"
      text = text.replace(/\s?"?QQ Group \d+"?/gu, '');
      //tìm sách a "Cuộc đời này không phụ diên đuôi tình" cá nhân cải biên
      text = text.replaceAll('  tìm sách a "Cuộc đời này không phụ diên đuôi tình" cá nhân cải biên', '');
      text = text.replace(/\b(?<protocol>https?:)(?:\/\/)? (?<path>(?:\w+)(?:\. \w+)+(?:\/(?:(?:\. )?[\w\/])+)?)/gm, (...args) => {
        let { protocol, path } = args.pop();
        path = path.replace(/\s/g, '');
        if (protocol) return protocol + '//' + path;
        return path;
      });
      text = text.replaceAll('cha mẹ vợ', 'mẹ vợ');
      return text;
    }

    let printed = true;
    function Chapter(_, { chapters, filename, text }) {
      return {
        _,
        merged: 1,
        get title() {
          let originalTitle = _.title || _.titleShort;
          let title, titleBook, titleChap, phienNgoai, halfPre, halfPost;
          titleBook = this.book;
          if (/phiên ngoại/iu.test(_.text) && !/phiên ngoại/iu.test(originalTitle)) phienNgoai = 'Phiên ngoại';
          if (this.chapter != null) titleChap = this.chapType + ' ' + this.chapter;
          if (this.half && !originalTitle?.includes('(' + this.half + ')')) {
            if (_.halfType) halfPre = this.half + ':';
            else halfPost = '(' + this.half + ')';
          }
          title = [titleBook, phienNgoai, titleChap].filter(Boolean).join(' ');
          title = [title, (originalTitle || '').replace(/./, c => c.toUpperCase())].filter(Boolean).join(': ');
          title = [halfPre, title, halfPost].filter(Boolean).join(' ');
          if (!title) title = this.chapType + ' ' + (this.i + 1);
          if (!printed) {
            printed = true;
            if (title.includes('26')) {
              console.warn('diz', this);
            }
          }
          return title;
        },
        get i() {
          return chapters.indexOf(this);
        },
        get startIndex() {
          // return text.lastIndexOf('\n', _.index);
          return _.index;
        },
        get endIndex() {
          if (this.i == chapters.length-1) return text.length;
          return chapters[this.i + 1].startIndex;
        },
        get id() {
          return slug(this.title) + '-' + this.i;
        },
        get content() {
          return text.slice(this.startIndex, this.endIndex).trim();
        },
        get chapter() {
          return _.chapNum || _.chapText;
        },
        get chapNo() {
          if (this.chapter) return Number(this.chapter)
        },
        get chapType() {
          return _.chapType || 'Chương'
        },
        get length() {
          return this.endIndex - this.startIndex;
        },
        get half() {
          return [_.halfType, _.halfNum || _.halfText].filter(Boolean).join(' ');
        },
        get halfNo() {
          if (_.halfNum) return Number(_.halfNum);
        },
        get halfType() {
          return _.halfType;
        },
        get bookType() {
          if (_.bookType) return _.bookType.toLowerCase().replace(/^./, c => c.toUpperCase());
        },
        get bookNo() {
          if (_.bookNum) return Number(_.bookNum);
          if (_.bookText) return Number(_.bookText);
        },
        get book() {
          if(_.bookNum || _.bookText) {
            return [_.bookType || 'Quyển', Number(_.bookNum) || Number(_.bookText)].filter(Boolean).join(' ');
          }
        },
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            content: this.content,
          }
        }
      };
    }

    function extractChapters(filename, text, { name }) {
      let NUMERIC = '(\\d{1,4}(\\.\\d{1,2})*)';
      let NUMERIC_DECIMAL = '(\\d{1,4}(\\.\\d{1,2})+)';
      let NUMERIC_WORDS = '(mười( (một|hai|ba|bốn|lăm|sáu|bảy|tám|chín))?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( (mốt|hai|ba|bốn|lăm|sáu|bảy|tám|chín))?|một|hai|ba|bốn|năm|sáu|bảy|tám|chín)|(((thập|bách|thiên|vạn) )?(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập))+|[MDCLXVI]+';
      let patterns = [
        /*
        【xanh biếc lữ du tiên】 bộ 2 tự chương
        【xanh biếc lữ du tiên】 bộ 2 thứ 01 chương
        Xanh Biếc lữ du tiên bộ 2 thứ 09 chương
        【xanh biếc lữ du tiên bộ 2】 thứ 10 chương Đông hải tiên các (1)
        Xanh Biếc lữ du tiên bộ 2 thứ 13 chương Nữ Đế dâm tâm
        【xanh biếc lữ du tiên】 Chương 8:
        【Chương 8: Tông môn dâm loạn (nhất)】
        【xanh biếc lữ du tiên】 Chương 6:
        【Chương 6: Hoàng thành long ảnh】
        Thứ 02 chương: Hong Kong
        Thứ 1 chương đại nghịch bất đạo ái đồ, nhưng lại hy vọng đem sư tôn dạy dỗ vì song tu chuyên dụng ấu thê!
        Thứ 10 chương, võ diễm hòa không rõ thân phận nam nhân thông đồng cùng với trần san cùng ca ca trần vừa loạn luân địt bi chuyện xưa
        【mẹ thành gia bên trong bảo mẫu con dâu】(15) hoàn
        Nhị, thay đổi
        【bạn gái đệ đệ】3
        "Bạn gái đệ đệ" 11
        Thượng (2)
        Chính Văn Chương 07: Chỉnh quân
        Nhất, lời dẫn tưởng nói ngắn gọn, nhưng không biết từ đâu nói lên.
        Thứ 34 chương mẫu thượng công lược (3.11) An Nặc tiến bệnh viện
        — Chương 2: (dịch nóng thể)—
        2020 năm tháng 1 6 ngày
        Hạ bộ — chị em yêu nhau (lục hi hòa lục nếu)
        【mẹ con】(nhị -- yêu nói hết)
        (nhị -- yêu nói hết)
        ch. 1
        Hồi 1: Ngây thơ diện mạo Khuynh Thành vận giao mui xe thị lão Ông phủ ấu tử từ huệ thục hiền Hongkong
        Thứ 41-48 chương
        */
        //Chương 23:
        //Phiên ngoại Chương 18:
        '^(Phiên Ngoại )?CHAP_TYPE CHAP_NUM:$',
        //Chương 1: Tân niên đặc biệt thiên (thượng)
        //Phiên Ngoại Chương 8: Treo đầu dê bán thịt chó
        //...đã ngủ say. Chương 59: mẹ phát hiện chân tướng
        //Hồi 2: · phẫn vũ nữ khinh thân dụ địch tù, nhu vú to thát tử loạn tâm trí
        '(^|(?<=\\W ))(Phiên Ngoại )?CHAP_TYPE CHAP_NUM([^\\p{L}\\p{N}]+TITLE)?$',
        //Ngũ
        //Hai mươi mốt
        '^CHAP_TEXT$',
        // (1)
        '^\\(CHAP_NUM\\)$',
        //8.1
        '^CHAP_NUM$',
        // (tứ)
        // (mười một)
        '^\\(CHAP_TEXT\\)$',
        //Thứ 7 chương mẫu thượng công lược (1.7) tiểu ma nữ phục vụ
        // '^Thứ BOOK_NUM chương ' + name + ' \\(CHAP_NUM\\)([: ]TITLE)?',
        //Thứ 31 chương
        //Tập thứ nhất thứ 01 chương thất đọa vách núi đen
        '^(BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT) )?Thứ CHAP_NUM CHAP_TYPE([: ]TITLE)?',
        //[thứ 1 chương]
        '^\\[thứ CHAP_NUM CHAP_TYPE\\]',
        //Bảy năm vợ chồng gần ba năm cùng hai cái đơn nam đệ tử chuyện xưa (5)
        '^' + name + ' \\(CHAP_NUM\\)',
        //2019-7-19 mười lăm
        '^DATE CHAP_TEXT',
        //Mười hai, nửa năm sau cuộc sống vẫn đang tiếp tục. Phố xá như trước thái bình.
        '^CHAP_TEXT[,] TITLE$',
        //Quyển thứ hai Chương 11: Mỹ mẫu cầu xin
        //Tập 6 Chương 110: Nhân thay mới trang
        '^BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT) CHAP_TYPE CHAP_NUM: TITLE',
        //Lời dẫn
        '^(?<title>CHAP_TYPE (cuối|kết)|tự chương|Lời dẫn)$',
        //(Chương 20: hèn chó diễn phượng (che giấu thiên 3)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE',
        //Phiên Ngoại hai mươi lăm chương
        '^(Phiên Ngoại )CHAP_TEXT CHAP_TYPE',
        //【 đọa phụ 】 Chương 2:: Khuất nhục phu nhân
        '^【NAME】 CHAP_TYPE CHAP_NUM: TITLE',
        //【xanh biếc lữ du tiên】 bộ 2 thứ 08 chương
        '^【NAME】 bộ BOOK_NUM thứ CHAP_NUM CHAP_TYPE',
        //Xanh biếc lữ du tiên bộ 2 Chương 8: Sơ ngộ bích du
        '^NAME bộ BOOK_NUM CHAP_TYPE CHAP_NUM: TITLE',
        //【bạn gái đệ đệ】9
        '^【NAME】CHAP_NUM([: ]TITLE)?',
        //【các huynh đệ loạn luân thịnh yến】(tam)
        //【không chỉ tình yêu】(1)
        //【không chỉ tình yêu】(18) hoàn
        '^【NAME】\\((CHAP_TEXT|CHAP_NUM)\\)( TITLE)?',
        //【của ta giang hồ】(thứ 2 chương)
        '^【NAME】\\(thứ CHAP_NUM CHAP_TYPE\\)',
        //【không chỉ tình yêu】(phiên ngoại) cảnh phỉ mẹ con kích tình thượng kính
        '^【NAME】(phiên ngoại) TITLE',
        //【phiên ngoại thiên chi Diệp Minh Hi tự bạch】(1)
        '【(?=.*?phiên ngoại)(?<title>.*?)】\\(CHAP_NUM\\)',
        //【không chỉ tình yêu】(phiên ngoại) cảnh phỉ mẹ con kích tình thượng kính
        '^【NAME】\\(phiên ngoại\\) TITLE',
        //Người nhà quần áo Chương 1: Mẹ dị thường
        '^NAME CHAP_TYPE CHAP_NUM: TITLE',
        //Nón xanh mặc ta mang (nhất) kinh vi thiên nhân
        '^NAME \\(CHAP_TEXT\\) TITLE',
        //(bản cũ) dâm loạn gia đình thứ 01 chương: Sau khi tan lớp ba ba âu yếm
        'NAME thứ CHAP_NUM CHAP_TYPE: TITLE',
        //(16) A Kiện nói: Nàng... Nàng là ta... Muội muội
        '^\\(CHAP_NUM\\) TITLE',
        //..."Ân, ta đều nghe ngươi!" (13)
        '(?<=\\W) \\(CHAP_NUM\\)$',
        //(14) nghiêm hạo tại sofa phía trên thích không thể tự thoát ra được, nhất tinh mặc xong đồ ngủ, sau đó tiếp lấy đem nghiêm hạo ôm đến chân của mình phía trên, nhẹ nhàng âu yếm.
        '\\(CHAP_NUM\\)',
        //"2" hào môn bí mật
        '^"\\s*CHAP_NUM\\s*"( TITLE)?',
        //"13 chương kết"
        '^"CHAP_NUM TITLE"$',
        //Tập thứ hai thứ 36 chương con tin uy hiếp
        '^Tập thứ BOOK_TEXT thứ CHAP_NUM CHAP_TYPE TITLE$',
        //22)
        '^CHAP_NUM\\)$',
        //2,
        '^CHAP_NUM,$',
        //Tự mẫu một ngày (hạ)
        '^(?<!.*CHAP_TYPE.*TITLE) \\(HALF_TEXT\\)$',
        //Thứ 1002 chương lữ mộng đẹp cảnh nhã nhàn bá mẫu (nhị)
        '^Thứ CHAP_NUM CHAP_TYPE TITLE',
        //Đệ nhất bộ tứ đại mỹ nữ chi đẹp nhất thị trưởng dương ngưng băng (thượng)
        '^Đệ (BOOK_NUM|BOOK_TEXT) BOOK_TYPE TITLE \\(HALF_TEXT\\)',
        //Bộ 2 tứ đại mỹ nữ chi kim bài chủ trì dương ninh làm (hạ)
        '^BOOK_TYPE BOOK_NUM TITLE \\(HALF_TEXT\\)',
        //(Chương 20: hèn chó diễn phượng (che giấu thiên 2)
        '^\\(CHAP_TYPE CHAP_NUM: TITLE HALF_TEXT\\)',
        //Đệ 1 chương: (Mẹ Mamako)
        //Đệ 8 chương, đẩy ngược phản bị địt.
        '^(Đệ|thứ) CHAP_NUM CHAP_TYPE[,:]? TITLE',
        //Quyển thứ hai thiết giáp phong vân
        '^BOOK_TYPE( thứ)? (BOOK_NUM|BOOK_TEXT)( BOOK_TITLE)?$',
        //Thứ 4 cuốn đế đô bi ca
        '^Thứ BOOK_NUM BOOK_TYPE BOOK_TITLE',
        //1.1 nhân vật chính kêu mũ
        '^CHAP_NUM_DECIMAL TITLE$',
        //(4.25)G con mẹ nó du học sinh
        '^\\(CHAP_NUM\\) ?TITLE$',
        //Chương mười:
        '^CHAP_TYPE CHAP_TEXT:$',
        //Chương ba mươi lăm lại rình coi
        '^CHAP_TYPE CHAP_TEXT TITLE$',
        //Ba mươi tám chương Tuyết Nhi tân hôn
        '^CHAP_TEXT CHAP_TYPE TITLE$',
        //Bốn mươi chương
        '^CHAP_TEXT CHAP_TYPE$',
        //(tam) mấy ngày kế tiếp, mẹ ngược lại không hướng đến Lý Tư oa trong nhà chạy, mỗi ngày tại trong nhà nấu cơm mang đứa nhỏ, tâm tình thượng cũng không tệ.
        '^\\(CHAP_TEXT\\)',
        //(còn tiếp) mười ba (thượng) đã xảy ra chuyện — ba chữ này bình thường là chỉ phát sinh không tốt sự tình, chuyện tốt nhi cũng không có khả năng dùng này ba tự, hơn nữa có thể lớn có thể nhỏ, nhỏ đến tại ban thượng nghịch ngợm gây sự đùa giỡn bạn học gái bị lão sư đã biết, lớn đến hai quốc gia phát sinh chiến tranh, đều có thể kêu đã xảy ra chuyện.
        '^\\(còn tiếp\\) CHAP_TEXT \\(HALF_TEXT\\)',
        //Mười ba (hạ) theo lớn mập gia trong nhà đi ra ta liền hướng đến gia đuổi, thậm chí sợ thời gian đuổi không kịp đi nhanh chạy, kỳ thật ta là không quá nguyện ý hướng đến chỗ đó nghĩ, nội tâm thậm chí có một chút kháng cự cái ý nghĩ này, nhưng nếu như hiện thực chính là như vậy đâu.
        '^CHAP_TEXT \\(HALF_TEXT\\)',
        //(còn tiếp) mười bảy đã trải qua nhiều như vậy ly kỳ sự tình, ta cho rằng chính mình đã là người lớn, tính là cùng đại nhân có chút chênh lệch, cũng không có khả năng khác biệt quá xa.
        '^\\(còn tiếp\\) CHAP_TEXT',
        //(còn tiếp)(mười một) "Tiểu Chí tiểu Lôi rời giường ăn cơm."
        '^\\(còn tiếp\\)\\(CHAP_TEXT\\)',
        //Mười bốn "Tiểu Chí như thế nào còn không có rời giường, ngươi không gọi hắn ăn điểm tâm a."
        //'^CHAP_TEXT',
        //【Chương 1:
        '^【CHAP_TYPE CHAP_NUM: TITLE',
        //22.
        '^CHAP_NUM\\.$',
        //Đại phụng gõ mõ cầm canh nhân chi xanh miết #1 tác giả: Hố ni
        '^NAME #CHAP_NUM',
        //(hạ)
        '^\\(HALF_TEXT\\)$',
        //"Bạn gái đệ đệ" 11
        '^"NAME" CHAP_NUM$',
        //Thứ 1 tiết tay nghề tiểu tử & Uzumaki Naruto
        '^(Đệ|thứ) HALF_NUM HALF_TYPE TITLE$',
        //Tiết thứ hai Hyuga Hinata
        //Tiết thứ năm: Naruto cực khổ ngày
        '^HALF_TYPE thứ HALF_TEXT[:]? TITLE$',
        //Thứ bảy tiết trăm hào Tiểu Anh! Một câu bạch cấp
        //Thứ sáu tiết: Hinata cực khổ ngày
        //Đệ thập nhất tiết Sasuke xanh biếc nô thuộc tính chuyện lớn hấp thụ ánh sáng!
        '^(Đệ|thứ) HALF_TEXT HALF_TYPE[:]? TITLE$',
        //【hào hiệp xanh biếc truyện II】
        '^【NAME BOOK_TEXT】$',
        //【chương kết, (Lã phàm thị giác)】
        '^【CHAP_TYPE CHAP_TEXT, \\(TITLE',
        //【chương kết】
        '^【CHAP_TYPE CHAP_TEXT】$',
        //Kiều thê chuyện xưa (nhất)
        '^NAME \\(CHAP_TEXT\\)$',
        //《 kiều thê chuyện xưa 》2
        '^《 NAME 》CHAP_NUM$',
        //#3 Chương 3: Dưới ánh trăng chinh phục
        '^#\\d+ Chương CHAP_NUM: TITLE',
        //Nón xanh chiến thần người ở rể (Chương 5: phối đồ bản)
        '^NAME \\(Chương CHAP_NUM: TITLE\\)',
        //Phục 63 chương
        '^Phục CHAP_NUM chương',
        //Lão bà Tuyết Nhi đổi thê trải qua (thập tam)
        '^NAME \\(CHAP_TEXT\\)TITLE',
        //— mẹ vú to người vợ khuê mật 84 cùng mẹ cùng nữ nhi
        '^[^\\p{L}]* NAME CHAP_NUM TITLE',
        //【30, khúc cuối】
        '^【CHAP_NUM, TITLE】$',
        //【hai mươi bảy ba người hạnh phúc (thượng)】
        '^【CHAP_TEXT,? TITLE \\(HALF_TEXT\\)】$',
        //【hai mươi sáu tái kiến tinh không】
        //【hai mươi chín, ba người hạnh phúc】
        '^【CHAP_TEXT,? TITLE】$',
        //Hai mươi tư du hí triển
        '^CHAP_TEXT TITLE_SHORT$',
        //Thứ 1 cuốn 1, bị phiêu rồi hả?
        '^thứ BOOK_NUM BOOK_TYPE CHAP_NUM, TITLE$',
        //● thứ 1 chương ●
        //
        //Võ tràng lõa thể luyện kiếm, thôi miên tự an ủi ●
        '^● thứ CHAP_NUM CHAP_TYPE ●$\\n+TITLE●',
        //kể ra một cái chẳng phải thuần khiết trưởng thành chuyện xưa Chương 3: Thiếu nữ bắt gian nhật ký
        '(?<=\\s\\p{Ll}+\\s)CHAP_TYPE CHAP_NUM',
        //"Bí mật nhạc viên" (Chương 7: Hôn nửa năm sau)
        '"NAME" \\(CHAP_TYPE CHAP_NUM: TITLE\\)',
        //Thứ 01 thiên: Tuyệt sắc gia tộc chi cưỡng dâm (trung)
        'Thứ CHAP_NUM CHAP_TYPE: TITLE \\(HALF_TEXT\\)',
        //Tiếp theo viết thứ 8 chương sơ phong mùi thơm
        'Tiếp theo viết thứ CHAP_NUM CHAP_TYPE TITLE',
        //Thứ hai nói
        '^Thứ CHAP_TEXT nói$',
        //001 ta và thê tử viên viện
        '^CHAP_NUM TITLE',
      ];
      let matches = [];
      for (let pattern of patterns) {
        let source = pattern
          .replace('NAME', '(?<name>' + [...new Set([name, name.replace('hệ liệt', '').trim()])].join('|') + ')')
          .replace('DATE', '\\d+-\\d+-\\d+')
          .replace('SEP', '[ :]')
          .replace('TITLE_SHORT', '(?<titleShort>[^\n】]{1,50}\\.*)')
          .replace('TITLE', '(?<title>[^\n】]+\\.*)')
          .replace('BOOK_TITLE', '(?<bookTitle>[^\n】]+\\.*)')
          .replace('BOOK_TYPE', '(?<bookType>(quyển|tập|bộ|cuốn))')
          .replace('BOOK_NUM', `(?<bookNum>${NUMERIC})`)
          .replace('BOOK_TEXT', `(?<bookText>${NUMERIC_WORDS})`)
          .replace('HALF_TYPE', `(?<halfType>(tiết))`)
          .replace('HALF_NUM', `(?<halfNum>${NUMERIC})`)
          .replace('HALF_TEXT', `(?<halfText>(?<=\\()(thượng|trung|hạ|${NUMERIC_WORDS})(?=\\))|(?<=thứ )${NUMERIC_WORDS})`)
          .replace('CHAP_TYPE', '(?<chapType>(chương|hồi|thiên))')
          .replace('CHAP_NUM_DECIMAL', `(?<chapNum>${NUMERIC_DECIMAL})`)
          .replace('CHAP_NUM', `(?<chapNum>${NUMERIC})`)
          .replace('CHAP_TEXT', `(?<chapText>cuối|kết|${NUMERIC_WORDS})`);
        let regex = new RegExp(source, 'gimu');
        let result = [...text.matchAll(regex)];
        console.debug({ pattern, regex, result });
        matches.push(...result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] })));
      }
      matches.forEach(m => {
        for (let f of ['chapText', 'bookText', 'halfText']) {
          if (m[f]) {
            if (/^[MDCLXVI]+$/i.test(m[f])) {
              let val = {
                I: 1,
                V: 5,
                X: 10,
                L: 50,
                C: 100,
                D: 500,
                M: 1000,
              };
              let totalValue = 0;
              let value = 0;
              let prev = 0;
              for (let c of m[f]) {
                let current = val[c];
                if (current > prev) {
                  // Undo the addition that was done, turn it into subtraction
                  totalValue -= 2 * value;
                }
                if (current != prev) { // Different symbol?
                  value = 0; // reset the sum for the new symbol
                }
                value += current; // keep adding same symbols
                totalValue += current;
                prev = current;
              }
              m[f] = totalValue;
            } else {
              let c = m[f].toLowerCase();
              let vn = {
                'mươi$|(?<=.)(thập|bách|thiên|vạn)$': 0,
                'mươi': '',
                '(mười|thập)(?=.+)|m[ộố]t|nhất': 1,
                'hai|nhị': 2,
                'ba|tam': 3,
                'bốn|tứ': 4,
                '[nl]ăm|ngũ': 5,
                'sáu|lục': 6,
                'bảy|thất': 7,
                'tám|bát': 8,
                'chín|cửu': 9,
                'mười|thập': 10,
              };
              Object.entries(vn).forEach(([w, i]) => {
                w = new RegExp(w, 'gimu');
                c = c.replace(w, i);
              });
              c = c.replace(/\s/g, '');
              c = Number.parseInt(c);
              if (!Number.isNaN(c)) m[f] = Number.parseInt(c);
            }
          }
        }
        for (let f of ['chapNum', 'bookNum']) {
          if (m[f]) {
            m[f] = m[f].split('.').map(Number).join('.');
          }
        }
      });
      matches.sort((a, z) => a.index - z.index);
      debug({ matches });

      if (matches.length < 2) {
        let paragraphsPerChapter = 60;
        let pattern = '(.*\n){1,' + paragraphsPerChapter + '}';
        let regex = new RegExp(pattern, 'gimu')
        let result = [...text.matchAll(regex)];
        matches = result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] }));
      }

      let chapters = [];
      matches.forEach(m => {
        chapters.push(Chapter(m, { chapters, filename, text }));
      });

      dedupeChapters(chapters);
      lockContinuous(chapters);
      mergeShortChapters(chapters, 1000);
      cleanupChapters(chapters);
      addPrologue(chapters, filename, text);

      return chapters;
    }

    function mergeBehind(chapters, i, reason) {
      // chapters[i].endIndex = chapters[i+1].endIndex;
      let [ch, ci] = [chapters[i-1], chapters[i]];
      let c;
      if (!ch.chapNo && ci.chapNo) c = ci;
      else if (ch.chapNo == ci.chapNo) {
        if (!ch._.title && ci._.title) c = ci;
      }
      //console.log('merge', [ch._.text, ci._.text], 'because', reason, c == ci, { ch, ci });
      if (c) {
        Object.assign(ch._, {
          title: c._.title,
          chapNo: c._.chapNo,
          chapText: c._.chapText,
          bookNo: c._.bookNo,
          bookText: c._.bookText,
          bookType: c._.bookType,
          halfNo: c._.halfNo,
          halfText: c._.halfText,
          halfType: c._.halfType,
        });
      }
      chapters.splice(i, 1);
      //console.log('  ->', [ch._.text])
      ch.merged++;
    }

    function dedupeChapters(chapters) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let h = i-1;
        let [ch, ci] = [chapters[h], chapters[i]];
        let shouldMerge = false;
        if (ch.startIndex == ci.startIndex) shouldMerge = true;
        if (ch.chapNo != null && ch.chapNo == ci.chapNo && ch.half == ci.half) shouldMerge = true;
        if (shouldMerge) {
          // console.log('dedupe', [ch.title, ci.title]);
          mergeBehind(chapters, i, 'dedupe');
        }
      }
    }

    function lockContinuous(chapters, lookupRange = 5) {
      //look behind
      for(let i = 1; i < chapters.length; i++) {
        let ci = chapters[i];
        if(!ci.chapNo) continue;
        console.group('Look behind', ci.chapNo);
        console.log(ci.chapNo, ci.title);
        for(let h = i - 1; h >= 0 && h >= i - lookupRange; h--) {
          let ch = chapters[h];
          let shouldLock = false;
          if(ch.chapNo + 1 == ci.chapNo) shouldLock = true;
          else if((ch.chapNo == ci.chapNo) && ch.halfNo && (ch.halfNo + 1 == ci.halfNo)) shouldLock = true;
          if(shouldLock) {
            console.info('Lock', { ch: ch.title, ci: ci.title });
            ch.locked = true;
            ci.locked = true;
            break;
          }
        }
        console.groupEnd();
      }
      //look ahead
      for(let i = chapters.length - 2; i >= 0; i--) {
        let ci = chapters[i];
        if(!ci.chapNo) continue;
        if(ci.locked) continue;
        console.group('Look ahead', ci.chapNo);
        console.log(ci.chapNo, ci.title);
        for(let j = i + 1; j < chapters.length && j < i + lookupRange; j++) {
          let cj = chapters[j];
          let shouldLock = false;
          if(ci.chapNo + 1 == cj.chapNo) shouldLock = true;
          else if((ci.chapNo == cj.chapNo) && ci.halfNo && (ci.halfNo + 1 == cj.halfNo)) shouldLock = true;
          if(shouldLock) {
            console.info('Lock', { ci: ci.title, cj: cj.title });
            ci.locked = true;
            cj.locked = true;
            break;
          }
        }
        console.groupEnd();
      }
    }

    function cleanupChapters(chapters) {
      let phienNgoai = c => /phiên ngoại/iu.test(c._.title);

      // debug({chapters})
      let i = 1;
      while (i < chapters.length - 1) {
        let [ch, ci, cj] = [chapters[i-1], chapters[i], chapters[i+1]];
        let shouldMerge = false;
        //ci is not continuity of ch
        if (ch.chapNo != null && ci.chapNo != null && (ch.chapNo + 1 != ci.chapNo)) {
          // console.log('phien ngoai', [ch._.title, ci._.title]);
          if (phienNgoai(ch) != phienNgoai(ci) || ch.half != ci.half) {
            i++;
            continue;
          }
          if (!cj && !/phiên ngoại/iu.test(ci._.title)) {
            //ci is the last chapter, can merge
            shouldMerge = true;
          } else {
            //find continuity of ch
            for (let j = i + 1; j <= i + 3 && j < chapters.length; j++) {
              cj = chapters[j];
              // console.log(ch.chapNo, cj.chapNo);
              if (cj.chapNo != null && (ch.chapNo + 1 == cj.chapNo)) {
                shouldMerge = true;
                break;
              }
            }
          }
        }
        if (shouldMerge) {
          //console.debug('cleanupChapters', ch.chapNo, '<-', ci.chapNo, cj?.chapNo);
          mergeBehind(chapters, i, 'cleanup');
        } else {
          i++;
        }
      }
    }

    function mergeShortChapters(chapters, minLength = 2_000) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let [h, j] = [i-1, i+1];
        let [ch, ci, cj] = [chapters[h], chapters[i], chapters[j]];
        if ((ci.length / ci.merged) < minLength) {
          if(ci.locked) continue;
          console.group('merge');
          console.warn(ci.id);
          let fields = [];
          if (ci.bookNo) fields.push('bookNo');
          if (ci.chapter != null) fields.push('chapter');
          if (ci.half) fields.push('half');
          if (fields.every(f => ch[f] == ci[f])) {
            console.log(chapters, i, 'short and dupe of prev');
            mergeBehind(chapters, i, 'short and dupe of prev');
          } else if (cj && fields.every(f => cj[f] == ci[f])) {
            console.log(chapters, j, 'short and dupe of next');
            mergeBehind(chapters, j, 'short and dupe of next');
          } else if (fields.length == 0 || (fields.length == 1 && fields[0] == 'chapter')) {
            if (ci._.name && cj) {
              console.log(chapters, j, 'short with name');
              mergeBehind(chapters, j, 'short with name');
            } else {
              console.log('short', { ch: ch.title, ci: ci.title, cj: cj.title });
              mergeBehind(chapters, i, 'short');
            }
          }
          console.groupEnd();
        }
      }
    }

    function mergeShortChapters1(chapters, minLength = 2e3) {
      let isShort = chapter => ((chapter.endIndex - chapter.startIndex) <= minLength);
      let isLong = chapter => !isShort(chapter);
      //delete all first short chapters, they belongs to prologue
      let firstLongChapterIndex = chapters.findIndex(isLong);
      chapters.splice(0, firstLongChapterIndex);
      //merge short chapters to next long chapter
      let short;
      while((short = chapters.find(isShort))) {
        let shortIndex = chapters.indexOf(short);
        let long = chapters.find((chapter, index) => isLong(chapter) && index >= shortIndex);
        let longIndex = chapters.indexOf(long);
        if (long) {
          short.endIndex = long.endIndex;
          chapters.splice(shortIndex, longIndex - shortIndex);
        } else {
          //merge last short chapters to previous long chapter
          long = chapters[shortIndex - 1];
          if (long) {
            long.endIndex = text.length;
            chapters.length = shortIndex;
          }
          break;
        }
      }
    }

    function addPrologue(chapters, filename, text) {
      //extract prologue
      let prologue = text.slice(0, chapters[0]?.startIndex ?? -1).trim();
      if(prologue) {
        chapters.unshift(Chapter({
          title: filename,
          index: 0,
        }, { chapters, filename, text }));
      }
    }

    function extractChapters1(filename, text, { name }) {
      let debug = true;
      debug && console.log({ name });
      //let chapterPattern = /^\s*\[?\s*(?:chapter)?\s*:?\s*Thứ\s+\w+(\s*-\s*\d+)?\s+chương\b.*|\bChương\s+\d+\s*:?.*|^(?:\d+\s*\.?\s*)+$|^\s*\d+\s+Chương\s*:?\s*|^【.*?】\([\d-]+\)$|^【.*?】\s*bộ(\s+\d+)+$|^\d+[.!].*|^\s*\d+(\s*-\s*\d+)?\s*$|^[-]+$/gimu;
      let certainPatterns = [
        /^chương \d+$/,
        /^chương \d+:/,
        /^— ?chương \d+:.*? ?—/,
        /^chương (cuối|kết)/,
        /^tự chương/,
        /^Lời dẫn/,
        /^bộ \d+:? chương \d+/, // bộ 01: chương 05:
        /^thứ \d+ bộ thứ \d+ chương/, // thứ 01 bộ thứ 02 chương
        /^\d+([\.\s]+\d+)*$/,
        /thứ \d+ chương/,
        /^\(\d+\)/,
        /^Hồi \d+/,
        new RegExp('^【' + name + '】\\d+$'),
        new RegExp('^"' + name + '" \\d+$'),
        /^ch\. \d+/,
        /^ ?\[? ?(?:chapter)? ?:? ?Thứ \w+( ?- ?\d+)? chương/,
        /^ ?\d+ Chương ?:? ?/,
        /^【.*?】\([\d-]+\)$/,
        /^【.*?】 ?bộ( \d+)+$/,
        /^\d+[.!].*/,
        /^ ?\d+( ?- ?\d+)? ?$/,
        /quyển (thứ )?(\d+|(một|hai|ba|bốn|năm|sáu|bảy|tám|chín|(mười( một)?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( mốt)?)( (hai|ba|bốn|lăm|sáu|bảy|tám|chín))?)) chương \d.*/,
        /(phiên ngoại|chính văn) chương \d+:/,
        /phiên ngoại .* chương/,
        /^(thượng|trung|hạ) \(\d+\)$/,
        /^(thượng|trung|hạ) bộ/,
      ];
      let loosePatterns = [
        new RegExp('^【' + name + '】.*$'),
        new RegExp('^"' + name + '".*$'),
        new RegExp('^' + name + ' [\\(\\.:\\d]'),
        /^.*\((thượng|trung|hạ)\):?$/, // phản kích (thượng)
        /^([(]?)(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập|(mười) (một|hai|ba|bốn|năm|sáu|bảy|tám|chín|mươi))(?=[,:)])([^.]*)$/,
        /^(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập).*/,
        /^\[.*\]$/,
        /^[-—* ]+$/,
      ];
      let matches;
      for (let patterns of [certainPatterns, loosePatterns]) {
        let regex = new RegExp('(?:' + patterns.map(p => '(?:' + p.source + ')').join('|') + ').*', 'gimu');
        matches = [...regex[Symbol.matchAll](text)];
        debug && console.log({ regex, matches })
        if (matches.length > 0) break;
      }
      let chapters = matches.map((match, i) => {
        let startIndex = text.lastIndexOf('\n', match.index);
        if (startIndex == -1) startIndex = 0;
        let endIndex = text.length;
        if (matches[i+1]) endIndex = text.lastIndexOf('\n', matches[i+1].index);
        let title = match[0].trim();
        if (/^[-—]+$/.test(title)) title = `-Chương ${i+1}-`;
        title = title.replace(new RegExp('^【(' + name + ')】\s*', 'i'), '');
        title = title.replace(new RegExp('^"(' + name + ')"\s*', 'i'), '');
        title = title.replace(new RegExp('^(' + name + ')\s*', 'i'), '');
        return {
          title,
          startIndex,
          endIndex,
        }
      });

      return mergeChapters(chapters, filename, text);
    }

    function slug(s) {
      s = latinize(s);
      s = s.replace(/\W+/g, '-');
      s = s.replace(/^-+|-+$/g, '');
      s = s.toLowerCase();
      return s;
    }

    function latinize(s) {
      s = s.replace(/[ÁĂẮẶẰẲẴǍÂẤẬẦẨẪÄǞȦǠẠȀÀẢȂĀĄÅǺḀȺÃⱯᴀ]/g, 'A');
      s = s.replace(/[Ꜳ]/g, 'AA');
      s = s.replace(/[ÆǼǢᴁ]/g, 'AE');
      s = s.replace(/[Ꜵ]/g, 'AO');
      s = s.replace(/[Ꜷ]/g, 'AU');
      s = s.replace(/[ꜸꜺ]/g, 'AV');
      s = s.replace(/[Ꜽ]/g, 'AY');
      s = s.replace(/[ḂḄƁḆɃƂʙᴃБ]/g, 'B');
      s = s.replace(/[ĆČÇḈĈĊƇȻꜾᴄ]/g, 'C');
      s = s.replace(/[ĎḐḒḊḌƊḎǲǅĐÐƋꝹᴅД]/g, 'D');
      s = s.replace(/[ǱǄ]/g, 'DZ');
      s = s.replace(/[ÉĔĚȨḜÊẾỆỀỂỄḘËĖẸȄÈẺȆĒḖḔĘɆẼḚƐƎᴇⱻЕЭ]/g, 'E');
      s = s.replace(/[Ꝫ]/g, 'ET');
      s = s.replace(/[ḞƑꝻꜰФ]/g, 'F');
      s = s.replace(/[ǴĞǦĢĜĠƓḠǤꝽɢʛГҐ]/g, 'G');
      s = s.replace(/[ḪȞḨĤⱧḦḢḤĦʜХ]/g, 'H');
      s = s.replace(/[ÍĬǏÎÏḮİỊȈÌỈȊĪĮƗĨḬІɪЙЫИ]/g, 'I');
      s = s.replace(/[ꞂŔŘŖṘṚṜȐȒṞɌⱤʁʀᴙᴚР]/g, 'R');
      s = s.replace(/[ꞄŚṤŠṦŞŜȘṠṢṨꜱС]/g, 'S');
      s = s.replace(/[ꞆŤŢṰȚȾṪṬƬṮƮŦᴛТ]/g, 'T');
      s = s.replace(/[Ꝭ]/g, 'IS');
      s = s.replace(/[ĴɈᴊ]/g, 'J');
      s = s.replace(/[ḰǨĶⱩꝂḲƘḴꝀꝄᴋК]/g, 'K');
      s = s.replace(/[ĹȽĽĻḼḶḸⱠꝈḺĿⱢǈŁꞀʟᴌЛ]/g, 'L');
      s = s.replace(/[Ǉ]/g, 'LJ');
      s = s.replace(/[ḾṀṂⱮƜᴍМ]/g, 'M');
      s = s.replace(/[ŃŇŅṊṄṆǸƝṈȠǋÑɴᴎН]/g, 'N');
      s = s.replace(/[Ǌ]/g, 'NJ');
      s = s.replace(/[ÓŎǑÔỐỘỒỔỖÖȪȮȰỌŐȌÒỎƠỚỢỜỞỠȎꝊꝌŌṒṐƟǪǬØǾÕṌṎȬƆᴏᴐО]/g, 'O');
      s = s.replace(/[Ƣ]/g, 'OI');
      s = s.replace(/[Ꝏ]/g, 'OO');
      s = s.replace(/[Ȣᴕ]/g, 'OU');
      s = s.replace(/[ṔṖꝒƤꝔⱣꝐᴘП]/g, 'P');
      s = s.replace(/[ꝘꝖ]/g, 'Q');
      s = s.replace(/[ß]/g, 'ss');
      s = s.replace(/[ɅꝞṾƲṼᴠВ]/g, 'V');
      s = s.replace(/[Ꜩ]/g, 'TZ');
      s = s.replace(/[ÚŬǓÛṶÜǗǙǛǕṲỤŰȔÙỦƯỨỰỪỬỮȖŪṺŲŮŨṸṴᴜУ]/g, 'U');
      s = s.replace(/[Ꝡ]/g, 'VY');
      s = s.replace(/[ẂŴẄẆẈẀⱲᴡ]/g, 'W');
      s = s.replace(/[ẌẊ]/g, 'X');
      s = s.replace(/[ÝŶŸẎỴỲƳỶỾȲɎỸʏ]/g, 'Y');
      s = s.replace(/[Ї]/g, 'YI');
      s = s.replace(/[ŹŽẐⱫŻẒȤẔƵᴢЗ]/g, 'Z');
      s = s.replace(/[Þ]/g, 'TH');
      s = s.replace(/[Ĳ]/g, 'IJ');
      s = s.replace(/[Œɶ]/g, 'OE');
      s = s.replace(/[áăắặằẳẵǎâấậầẩẫäǟȧǡạȁàảȃāąᶏẚåǻḁⱥãɐₐАа]/g, 'a');
      s = s.replace(/[ꜳ]/g, 'aa');
      s = s.replace(/[æǽǣᴂ]/g, 'ae');
      s = s.replace(/[ꜵ]/g, 'ao');
      s = s.replace(/[ꜷ]/g, 'au');
      s = s.replace(/[ꜹꜻ]/g, 'av');
      s = s.replace(/[ꜽ]/g, 'ay');
      s = s.replace(/[ḃḅɓḇᵬᶀƀƃб]/g, 'b');
      s = s.replace(/[ɵóŏǒôốộồổỗöȫȯȱọőȍòỏơớợờởỡȏꝋꝍⱺōṓṑǫǭøǿõṍṏȭɔᶗᴑᴓₒо]/g, 'o');
      s = s.replace(/[ćčçḉĉɕċƈȼↄꜿ]/g, 'c');
      s = s.replace(/[ďḑḓȡḋḍɗᶑḏᵭᶁđɖƌðꝺд]/g, 'd');
      s = s.replace(/[ıíĭǐîïḯịȉìỉȋīįᶖɨĩḭіᴉᵢйыи]/g, 'i');
      s = s.replace(/[ȷɟʄǰĵʝɉⱼ]/g, 'j');
      s = s.replace(/[ǳǆ]/g, 'dz');
      s = s.replace(/[éĕěȩḝêếệềểễḙëėẹȅèẻȇēḗḕⱸęᶒɇẽḛɛᶓɘǝₑеэ]/g, 'e');
      s = s.replace(/[ꝫ]/g, 'et');
      s = s.replace(/[ḟƒᵮᶂꝼф]/g, 'f');
      s = s.replace(/[ǵğǧģĝġɠḡᶃǥᵹɡᵷгґ]/g, 'g');
      s = s.replace(/[ḫȟḩĥⱨḧḣḥɦẖħɥʮʯх]/g, 'h');
      s = s.replace(/[ƕ]/g, 'hv');
      s = s.replace(/[ꞃŕřŗṙṛṝȑɾᵳȓṟɼᵲᶉɍɽɿɹɻɺⱹᵣр]/g, 'r');
      s = s.replace(/[ꞅſẜẛẝśṥšṧşŝșṡṣṩʂᵴᶊȿс]/g, 's');
      s = s.replace(/[ꞇťţṱțȶẗⱦṫṭƭṯᵵƫʈŧʇт]/g, 't');
      s = s.replace(/[ꝭ]/g, 'is');
      s = s.replace(/[ḱǩķⱪꝃḳƙḵᶄꝁꝅʞк]/g, 'k');
      s = s.replace(/[ĺƚɬľļḽȴḷḹⱡꝉḻŀɫᶅɭłꞁл]/g, 'l');
      s = s.replace(/[ǉ]/g, 'lj');
      s = s.replace(/[ḿṁṃɱᵯᶆɯɰм]/g, 'm');
      s = s.replace(/[ńňņṋȵṅṇǹɲṉƞᵰᶇɳñн]/g, 'n');
      s = s.replace(/[ǌ]/g, 'nj');
      s = s.replace(/[ƣ]/g, 'oi');
      s = s.replace(/[ꝏ]/g, 'oo');
      s = s.replace(/[ȣ]/g, 'ou');
      s = s.replace(/[ṕṗꝓƥᵱᶈꝕᵽꝑп]/g, 'p');
      s = s.replace(/[ꝙʠɋꝗ]/g, 'q');
      s = s.replace(/[ᴝúŭǔûṷüǘǚǜǖṳụűȕùủưứựừửữȗūṻųᶙůũṹṵᵤу]/g, 'u');
      s = s.replace(/[ᵺþ]/g, 'th');
      s = s.replace(/[ᴔœ]/g, 'oe');
      s = s.replace(/[ʌⱴꝟṿʋᶌⱱṽᵥв]/g, 'v');
      s = s.replace(/[ʍẃŵẅẇẉẁⱳẘ]/g, 'w');
      s = s.replace(/[ʎýŷÿẏỵỳƴỷỿȳẙɏỹ]/g, 'y');
      s = s.replace(/[ꜩ]/g, 'tz');
      s = s.replace(/[ᵫ]/g, 'ue');
      s = s.replace(/[ꝸ]/g, 'um');
      s = s.replace(/[ꝡ]/g, 'vy');
      s = s.replace(/[ẍẋᶍₓ]/g, 'x');
      s = s.replace(/[ї]/g, 'yi');
      s = s.replace(/[źžẑʑⱬżẓȥẕᵶᶎʐƶɀз]/g, 'z');
      s = s.replace(/[ﬀ]/g, 'ff');
      s = s.replace(/[ﬃ]/g, 'ffi');
      s = s.replace(/[ﬄ]/g, 'ffl');
      s = s.replace(/[ﬁ]/g, 'fi');
      s = s.replace(/[ﬂ]/g, 'fl');
      s = s.replace(/[ĳ]/g, 'ij');
      s = s.replace(/[ﬆ]/g, 'st');
      s = s.replace(/[Ё]/g, 'YO');
      s = s.replace(/[Ц]/g, 'TS');
      s = s.replace(/[Ш]/g, 'SH');
      s = s.replace(/[Щ]/g, 'SCH');
      s = s.replace(/[ЪъЬь]/g, '\'');
      s = s.replace(/[ё]/g, 'yo');
      s = s.replace(/[ц]/g, 'ts');
      s = s.replace(/[ш]/g, 'sh');
      s = s.replace(/[щ]/g, 'sch');
      s = s.replace(/[Ж]/g, 'ZH');
      s = s.replace(/[ж]/g, 'zh');
      s = s.replace(/[Я]/g, 'Ya');
      s = s.replace(/[Ч]/g, 'CH');
      s = s.replace(/[Ю]/g, 'YU');
      s = s.replace(/[я]/g, 'ya');
      s = s.replace(/[ч]/g, 'ch');
      s = s.replace(/[ю]/g, 'yu');
      return s;
    }

    function titleizeHumanName(s, minOccurence = 10, occurenceThreshold = 0.8) {
      let debug = false;
      let pattern = /(?:(?<pre>\p{Ll}+)[ ]+)?(?<name>[\p{Lu}A-Z]\p{Ll}+(?:[ ]+\p{Lu}\p{Ll}+)?)(?:[ ]+(?<post>\p{Ll}+))?/gu;
      let counts = {};
      let match;
      let titleize = s => s.replace(/(?<=^|[^\p{L}])\p{L}/gu, s => s.toUpperCase());
      let c = 0;
      while ((match = pattern.exec(s))) {
        if (++c < 10) debug && console.log({ match });
        let { pre, name, post } = match.groups;
        if (!counts[name]) counts[name] = { total: 0, pre: {}, post: {} };
        counts[name].total += 1;
        if (pre) {
          if (!counts[name].pre[pre]) counts[name].pre[pre] = 0;
          counts[name].pre[pre] += 1;
        }
        if (post) {
          if (!counts[name].post[post]) counts[name].post[post] = 0;
          counts[name].post[post] += 1;
        }
      }
      debug && console.dir(counts);
      analyze: for (let [name, { total, pre, post }] of Object.entries(counts)) {
        if (total < minOccurence) {
          debug && console.debug(name, 'is too few .. IGNORE', { total });
          continue analyze;
        }
        for (let [prefix, prefixCount] of Object.entries(pre)) {
          if (prefixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(prefix), name, { total, prefixCount });
            s = s.replace(new RegExp(prefix + '\\s+' + name, 'gu'), titleize);
            continue analyze;
          }
        }
        for (let [postfix, postfixCount] of Object.entries(post)) {
          if (postfixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(postfix), name, { total, postfixCount });
            s = s.replace(new RegExp(name + '\\s+' + postfix, 'gu'), titleize);
            continue analyze;
          }
        }
      }
      return s;
    }

    function debug(...args) {
      // return;
      if (args.length == 1) {
        console.table(Object.values(args[0])[0]);
      } else {
        console.info(...args);
      }
    }

    function getColorScheme() {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
      return 'light';
    }

    function buildRegex(patterns, placeholders, flags) {
      patterns = patterns.filter(Boolean).map((p, i) => `(?<Case${i+1}>${p.source || p})`).join('|');
      let counts = Object.fromEntries(Object.keys(placeholders).map(k => [k, 0]));
      for(let i = 1; i <= 10; i++) {
        for(let [p, r] of Object.entries(placeholders)) {
          patterns = patterns.replaceAll(`{${p}}`, () => `(?<${p}${++counts[p]}>${r.source || r})`);
        }
      }
      return new RegExp(patterns, flags);
    }

    function simpleCache({ key, getValue, getHash, fallbackValue }) {
      try {
        let cache = globalThis.__simpleCache || (globalThis.__simpleCache = {});
        let hash = getHash();
        if (!(key in cache) || cache[key].hash != hash) {
          cache[key] = { value: getValue(), hash };
        }
        return cache[key].value;
      } catch {
        return fallbackValue;
      }
    }

    function titleCase(s) {
      return s.toLowerCase().replace(/(?<=^|[^\p{L}])./gu, c => c.toUpperCase());
    }

    function memoize(f) {
      let memoized = _.memoize(f, (...args) => JSON.stringify(args));
      globalThis[f.name] = memoized;
      return memoized;
    }

    function getCase(word) {
      if (word == word.toUpperCase()) return 'upper';
      if (word == word.toLowerCase()) return 'lower';
      if (word[0] == word[0].toUpperCase()) return 'title';
    }

    function toCase(word, _case) {
      if (_case == 'upper') return word.toUpperCase();
      if (_case == 'lower') return word.toLowerCase();
      if (_case == 'title') return titleCase(word);
      return word;
    }

    memoize(function useCase(src, dst) {
      if (getCase(src) == 'lower' && getCase(dst) == 'lower') return titleCase(dst);
      let srcWords = src.split(' ');
      let dstWords = dst.split(' ');
      if (srcWords.length == dstWords.length) {
        let cases = srcWords.map((srcWord, i) => {
          if (getCase(srcWord) != getCase(dstWords[i])) return getCase(dstWords[i]);
        });
        return function applyCase(s) {
          return s.split(' ').map((word, i) => toCase(dstWords[i], cases[i] || getCase(word))).join(' ');
        }
      }
      return dst;
    });
  </script>
</body>
</html>
