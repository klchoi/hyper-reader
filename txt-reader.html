<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📖</text></svg>">
  <title>Text Reader</title>
  <style>
    @font-face {
      font-family: Reader1;
      src: local('LMRoman12-Regular'), url('https://mirror.kku.ac.th/CTAN/fonts/lm/fonts/opentype/public/lm/lmroman12-regular.otf') format('opentype');
    }
    @font-face {
      font-family: Reader;
      font-weight: 400;
      src: local('WorkSans-Regular');
    }
    @font-face {
      font-family: Reader;
      font-weight: 500;
      src: local('WorkSans-Medium');
    }

    /** reset **/
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      border: 0;
      outline: 0;
      transform-origin: 50% 50%;
    }
    p {
      margin: 1em 0;
    }
    hr {
      border: 0;
      height: 1px;
      background: rgba(0, 0, 0, .2);
    }
    a,
    a:any-link {
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-skip-ink: none;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    small {
      font-size: 0.875em;
    }
    
    /** rose pine **/
    :root {
      --rp-main-base: #191724;
      --rp-main-surface: #1f1d2e;
      --rp-main-overlay: #26233a;
      --rp-main-muted: #6e6a86;
      --rp-main-subtle: #908caa;
      --rp-main-text: #e0def4;
      --rp-main-love: #eb6f92;
      --rp-main-gold: #f6c177;
      --rp-main-rose: #ebbcba;
      --rp-main-pine: #31748f;
      --rp-main-foam: #9ccfd8;
      --rp-main-iris: #c4a7e7;
      --rp-main-highlight-low: #21202e;
      --rp-main-highlight-low-alpha: #6e6a861a;
      --rp-main-highlight-med: #403d52;
      --rp-main-highlight-med-alpha: #6e6a8633;
      --rp-main-highlight-high: #524f67;
      --rp-main-highlight-high-alpha: #6e6a8666;
      --rp-moon-base: #232136;
      --rp-moon-surface: #2a273f;
      --rp-moon-overlay: #393552;
      --rp-moon-muted: #6e6a86;
      --rp-moon-subtle: #908caa;
      --rp-moon-text: #e0def4;
      --rp-moon-love: #eb6f92;
      --rp-moon-gold: #f6c177;
      --rp-moon-rose: #ea9a97;
      --rp-moon-pine: #3e8fb0;
      --rp-moon-foam: #9ccfd8;
      --rp-moon-iris: #c4a7e7;
      --rp-moon-highlight-low: #2a283e;
      --rp-moon-highlight-low-alpha: #817c9c14;
      --rp-moon-highlight-med: #44415a;
      --rp-moon-highlight-med-alpha: #817c9c26;
      --rp-moon-highlight-high: #56526e;
      --rp-moon-highlight-high-alpha: #817c9c4d;
      --rp-dawn-base: #faf4ed;
      --rp-dawn-surface: #fffaf3;
      --rp-dawn-overlay: #f2e9e1;
      --rp-dawn-muted: #9893a5;
      --rp-dawn-subtle: #797593;
      --rp-dawn-text: #575279;
      --rp-dawn-love: #b4637a;
      --rp-dawn-gold: #ea9d34;
      --rp-dawn-rose: #d7827e;
      --rp-dawn-pine: #286983;
      --rp-dawn-foam: #56949f;
      --rp-dawn-iris: #907aa9;
      --rp-dawn-highlight-low: #f4ede8;
      --rp-dawn-highlight-low-alpha: #6e6a860d;
      --rp-dawn-highlight-med: #dfdad9;
      --rp-dawn-highlight-med-alpha: #6e6a8614;
      --rp-dawn-highlight-high: #cecacd;
      --rp-dawn-highlight-high-alpha: #6e6a8626;
    }

    /** variables **/
    :root {
      --nav-width: 300px;
      --aside-width: 60px;
      --gap: 1rem;
      cursor: default;
    }
    .settings .colors button.white,
    :root[data-color=white] {
      --body-font-color: rgb(27, 27, 27);
      --body-background-color: rgb(230, 230, 230);
      --paper-background-color: rgb(255, 255, 255);
      --paper-shadow-color: rgba(0, 0, 0, .2);
      --link-color: rgb(65, 110, 210);
      --horizontal-line-color: rgb(220, 220, 220);
    }
    .settings .colors button.sepia,
    :root[data-color=sepia] {
      --body-font-color: rgb(79, 50, 28);
      --body-background-color: rgb(225, 216, 200);
      --paper-background-color: rgb(248, 241, 227);
      --paper-shadow-color: rgba(0, 0, 0, .2);
      --link-color: rgb(209, 150, 0);
      --horizontal-line-color: rgb(230, 218, 201);
    }
    .settings .colors button.gray,
    :root[data-color=gray] {
      --body-font-color: rgba(255, 255, 255, 0.78);
      --body-background-color: rgb(50, 50, 51);
      --paper-background-color: rgb(74, 74, 77);
      --paper-shadow-color: rgba(0, 0, 0, .24);
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(111, 111, 111);
    }
    .settings .colors button.night,
    :root[data-color=night] {
      --body-font-color: rgb(176, 176, 176);
      --body-background-color: rgb(0, 0, 0);
      --paper-background-color: rgb(18, 18, 18);
      --paper-outline-color: #272727;
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(62, 62, 62);
    }
    .settings .colors button.rose-pine,
    :root[data-color=rose-pine] {
      --body-font-color: var(--rp-main-subtle);
      --body-background-color: var(--rp-main-surface);
      --paper-background-color: var(--rp-main-base);
      --paper-outline-color: var(--rp-main-highlight-med-alpha);
      --link-color: var(--rp-main-pine);
      --horizontal-line-color: var(--rp-main-highlight-high-alpha);
    }
    .settings .colors button.rose-pine-moon,
    :root[data-color=rose-pine-moon] {
      --body-font-color: var(--rp-moon-subtle);
      --body-background-color: var(--rp-moon-surface);
      --paper-background-color: var(--rp-moon-base);
      --paper-outline-color: var(--rp-moon-highlight-med-alpha);
      --link-color: var(--rp-moon-rose);
      --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
    }
    .settings .colors button.rose-pine-dawn,
    :root[data-color=rose-pine-dawn] {
      --body-font-color: var(--rp-dawn-text);
      --body-background-color: var(--rp-dawn-base);
      --paper-background-color: var(--rp-dawn-overlay);
      --paper-outline-color: var(--rp-dawn-highlight-med);
      --link-color: var(--rp-dawn-love);
      --horizontal-line-color: var(--rp-dawn-highlight-high);
    }

    /** layout **/
    body { display: flex; }
    body > * { flex: 1 }
    nav { flex: 0 0 var(--nav-width); }
    aside { flex: 0 0 var(--aside-width); }

    /** global **/
    html,
    body {
      font: 16pt/1.4 Reader;
      color: var(--body-font-color);
      background: var(--body-background-color);
      font-variant-numeric: oldstyle-nums tabular-nums slashed-zero;
    }
    a {
      color: var(--link-color);
    }

    /** nav **/
    nav {
      height: 100vh;
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: sticky;
      top: 0;
      padding: calc(var(--gap) * 0.75);
      font-size: 0.875rem;
      line-height: 1.2;
    }
    nav ol {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      align-items: start;
    }
    nav li {
      /**/
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /**/
      padding-top: 0.1ex;
      padding-bottom: 0.1ex;
      padding-left: calc(var(--gap) * 0.25);
      padding-right: calc(var(--gap) * 0.25);
    }
    nav li.active {
      background: var(--body-font-color);
      outline: calc(var(--gap) * 0.15) solid var(--body-font-color);
      border-radius: 0.5ex;
    }
    nav li.active a {
      pointer-events: none;
      color: var(--body-background-color);
    }
    nav a {
      color: var(--body-font-color);
    }
    nav a:hover {
      color: var(--link-color);
    }
    nav li:first-child a {
      font-weight: bold;
    }

    /** aside **/
    aside {
      position: sticky;
      top: 0;
      height: 100vh;
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      padding-left: var(--gap);
      padding-right: var(--gap);
      display: flex;
      flex-direction: column;
      row-gap: var(--gap);
    }
    aside a,
    aside button {
      appearance: none;
      background: var(--paper-background-color);
      color: var(--body-font-color);
      outline: 1px solid var(--horizontal-line-color);
      width: 100%;
      min-width: 25px;
      aspect-ratio: 1;
      display: grid;
      place-content: center;
      border-radius: 50%;
    }
    aside .colors {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: calc(var(--gap) * .75);
    }
    aside .colors button.checked::before {
      content: '✔';
      font-size: .7rem;
    }
    aside a.close {
      position: relative;
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
    }
    aside a.close::before,
    aside a.close::after {
      content: '';
      display: block;
      width: 50%;
      height: 1px;
      transform: translate3d(-50%, -50%, 0) rotateZ(var(--rotate, 45deg));
      position: absolute;
      top: 50%;
      left: 50%;
      background: currentColor;
    }
    aside a.close::after {
      --rotate: -45deg;
    }
    aside button.refresh {
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
    }
    aside button.refresh::after {
      content: '↻';
      font-size: 1rem;
      position: relative;
      top: -1px;
    }

    /** main **/
    main {
      /**
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      /**/
      display: flex;
    }
    main article {
      flex: 1;
      background: var(--paper-background-color);
      padding: 1rem 3rem;
      outline: 1px solid var(--paper-outline-color, transparent);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color, transparent);
      text-indent: 3ch;
    }
    main article p:first-child {
      line-height: 1.2;
      font-size: 1.5rem;
      font-weight: bold;
    }
    main article hr {
      background: var(--horizontal-line-color);
    }

    /** table **/
    .table {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      row-gap: var(--gap);
      column-gap: calc(var(--gap) * 2);
      padding: 0 var(--gap) var(--gap);
      background: var(--paper-background-color);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color);
      outline: 1px solid var(--paper-outline-color);
      line-height: 1.2;
      align-self: stretch;
      align-content: start;
    }
    .table .name {
      font-weight: bold;
    }
    .table .th {
      white-space: nowrap;
      padding: calc(var(--gap)/2) 0;
      position: sticky;
      top: 0;
      background: var(--paper-background-color);
    }
    .table .th::before {
      content: '';
      display: block;
      border-bottom: 1px solid var(--horizontal-line-color);
      width: calc(100% + 1ex);
      height: calc(2ex + 2px);
      box-shadow: 0 calc(1ex - 5px) 1.4ex -1ex rgba(0, 0, 0, .5);
      position: absolute;
      bottom: -1px;
      left: calc(-1ex / 2);
    }
    .table .th span {
      display: inline-block;
      position: relative;
    }
    .table .th span::after {
      position: absolute;
      bottom: calc(1ex/4);
      right: -1.8ex;
      color: var(--body-font-color);
    }
    .table .th[data-sort=asc] span::after { content: '↑'; }
    .table .th[data-sort=desc] span::after { content: '↓'; }
    .table .text-left { text-align: left; }
    .table .text-right { text-align: right; }
    .table .desc { display: block; }
    .table .delete { color: inherit; }
    .table .delete:hover { color: var(--link-color); }

    /** disable scroll when mouse is not over **/
    /**
    nav,
    main {
      height: 100%;
      overflow-y: hidden;
    }
    nav:hover,
    main:hover {
      overflow-y: auto;
    }
    /**/
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, text, app } from 'https://cdn.jsdelivr.net/npm/hyperapp/+esm';
    import { openDB } from 'https://cdn.jsdelivr.net/npm/idb/+esm';

    class HashRouter extends EventTarget {
      parse(hash) {
        return [...(new URLSearchParams(hash)).entries()].reduce((route, [k, v]) => (route[k] = v, route), {});
      }
      get(key) {
        return new URLSearchParams(location.hash.slice(1)).get(key);
      }
      current() {
        return this.parse(location.hash.slice(1));
      }
      route(route) {
        let hash = new URLSearchParams(Object.entries(route).filter(([k, v]) => v !== '' && v != null)).toString();
        if (hash) hash = '#' + hash;
        return hash;
      }
      push(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.pushState(null, null, url);
        }
      }
      replace(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.replaceState(null, null, url);
        }
      }
    }

    let InitDbDone = (state, { db }) => [
      { ...state, db },
      (dispatch) => {
        window.db = db;
        dispatch(LoadSettings);
        dispatch(LoadProgress);
        dispatch(LoadRecentBooks);
        dispatch(LoadRecentBook);
      }
    ];
    let InitDb = (state) => [
      state,
      async (dispatch) => {
        let db = await openDB('text-reader', 22, {
          upgrade(db, oldVersion, newVersion, transaction) {
            let schemas = {
              files: {},
              fileContents: {},
              settings: {},
              progress: {},
              books: {},
              chapters: {},
            };
            for (let [store, keyOptions] of Object.entries(schemas)) {
              if (!db.objectStoreNames.contains(store)) {
                db.createObjectStore(store, keyOptions);
              }
            }
            //for(let store of db.objectStoreNames) {
            //  if (!(store in schemas)) {
            //    console.warn('Delete store', store);
            //    db.deleteObjectStore(store);
            //  }
            //}
          },
          blocked: console.log,
          blocking: console.log,
          terminated: console.log,
        });

        dispatch(InitDbDone, { db });
      }
    ];

    let InitTheme = (state) => [
      state,
      (dispatch) => {
        let color = 'white';
        if (matchMedia('(prefers-color-scheme: dark)').matches) color = 'night';
        dispatch(ApplySettings, { color });
      }
    ];

    let InitRouter = (state) => [
      state,
      (dispatch) => {
        addEventListener('hashchange', (event) => {
          let from = state.router.parse(new URL(event.oldURL).hash.slice(1));
          let to = state.router.parse(new URL(event.newURL).hash.slice(1));
          if (!to.book) {
            dispatch(ShowRecentBooks);
          } else {
            dispatch(OpenBook, { bookId: to.book, chapterId: to.chapter });
          }
        });
      }
    ];

    let InitKeyboardNavigator = (state) => [
      state,
      (dispatch) => {
        addEventListener('keydown', (event) => {
          switch(event.key) {
            case 'ArrowRight': dispatch(OpenNextChapter, +1); break;
            case 'ArrowLeft': dispatch(OpenNextChapter, -1); break;
            case 'Backspace': dispatch(ShowRecentBooks); break;
            default: break;
          }
        });
      }
    ];

    let LoadSettings = (state) => [
      state,
      async (dispatch) => {
        let settings = {};
        let cursor = await state.db.transaction('settings').store.openCursor();
        while (cursor) {
          settings[cursor.key] = cursor.value;
          cursor = await cursor.continue();
        }
        dispatch(ApplySettings, settings);
      }
    ];
    let ApplySettings = (state, settings) => [
      { ...state, settings: { ...state.settings, ...settings } },
      () => {
        for (let [key, value] of Object.entries(settings)) {
          document.documentElement.dataset[key] = (value ?? '');
        }
      }
    ];
    let SaveSettings = (state, settings) => [
      state,
      async (dispatch) => {
        dispatch(ApplySettings, settings);

        let tx = state.db.transaction('settings', 'readwrite');
        await Promise.all([
          ...Object.entries(settings).map(([key, value]) => {
            document.documentElement.dataset[key] = (value || '');
            return tx.store.put(value, key);
          }),
          tx.done,
        ]);
      }
    ];

    let LoadRecentBooksDone = (state, { files }) => ({ ...state, files });
    let LoadRecentBooks = (state) => [
      state,
      async (dispatch) => {
        let files = await state.db.getAll('files');
        files.sort((a, z) => a.name.localeCompare(z.name, 'vi-VN', { sensitivity: 'accent' }));
        dispatch(LoadRecentBooksDone, { files });
      }
    ];

    let LoadProgressDone = (state, { progress }) => ({ ...state, progress });
    let LoadProgress = (state) => [state, async (dispatch) => {
      let progress = {};
      let cursor = await state.db.transaction('progress').store.openCursor();
      while (cursor) {
        progress[cursor.key] = cursor.value;
        cursor = await cursor.continue();
      }
      dispatch(LoadProgressDone, { progress });
    }];

    let LoadRecentBook = (state) => [
      state,
      (dispatch) => {
        let bookId = state.router.get('book');
        let chapterId = state.router.get('chapter');
        if (bookId) {
          dispatch(OpenBook, { bookId, chapterId })
        }
      }
    ];

    let OpenBookDone = (state, { book, chapter }) => [
      { ...state, book, chapter },
      (dispatch) => {
        if (state.book?.id == book.id)
          state.router.replace({ book: book.id, chapter: chapter.id });
        else
          state.router.push({ book: book.id, chapter: chapter.id });

        document.title = [...new Set([book.name, chapter.title])].join(' | ');

        requestAnimationFrame(() => {
          scroll(0, 0);

          //scroll bookmark into view
          let bookmark = document.querySelector('nav .active');
          let nav = document.querySelector('nav');
          let bookmarkRect = bookmark.getBoundingClientRect();
          let isOutOfView = bookmarkRect.top < 0 || nav.clientHeight < bookmarkRect.bottom;
          if (isOutOfView) bookmark.scrollIntoView({ block: 'center' });
        });
      }
    ];
    let OpenBook = (state, { bookId, chapterId, migrate = true, retry = true }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [book, chapter] = await Promise.all([
          state.db.get('books', bookId),
          state.db.get('chapters', bookId + '/' + chapterId),
        ]);
        if (!book) {
          console.info('Book not found:', { book, chapter });
          if (migrate) dispatch(RefreshBook, { bookId, onSuccess: [OpenBook, { bookId, chapterId, migrate: false, retry }] });
          return
        }
        if (!chapter) {
          console.info('Chapter not found:', { bookId, chapterId });
          if (retry) {
            chapterId = book.chapters[0].id;
            dispatch(OpenBook, { bookId, chapterId, retry: false });
          }
          return;
        }

        let chapters = [...book.chapters];
        let chapterIndex = chapters.findIndex(c => c.id == chapter.id);
        if (chapterIndex < 0) chapterIndex = 0;
        chapters[chapterIndex] = chapter;

        dispatch(OpenBookDone, { book, chapter });
        dispatch(SaveProgress, { book, chapter });
      }
    ];

    let OpenNextChapter = (state, indexDelta = 1) => [
      state,
      (dispatch) => {
        let chapterIndex = state.book.chapters.findIndex(c => c.id == state.chapter.id);
        let nextChapter = state.book.chapters[chapterIndex + indexDelta];
        if (nextChapter) {
          dispatch(OpenBook, { bookId: state.book.id, chapterId: nextChapter.id });
        }
      }
    ];

    let SaveProgressDone = (state, { book, progress }) => ({ ...state, progress: { ...state.progress, [book.id]: progress } });
    let SaveProgress = (state, { book, chapter }) => {
      return [
        state,
        async (dispatch) => {
          let progress = (await state.db.get('progress', book.id) || {});
          progress.chapterId = chapter.id;
          progress.chapterIndex = book.chapters.indexOf(chapter) + (book.chapters[0].id ? 1 : 0);
          progress.chapterCount = (book.chapters[0].id ? book.chapters.length : book.chapters.length - 1);
          progress.updatedAt = new Date().toISOString();
          await state.db.put('progress', progress, book.id);
          dispatch(SaveProgressDone, { book, progress });
        }
      ];
    };

    let InitDropzone = (state) => [
      state,
      (dispatch) => {
        addEventListener('dragenter', event => { event.preventDefault(); });
        addEventListener('dragover', event => { event.preventDefault(); });
        addEventListener('drop', event => {
          event.preventDefault();
          let files = [...event.dataTransfer.files].filter(file => file.type == 'text/plain');
          dispatch(StoreFiles, { files });
        });
      }
    ];

    let StoreFilesDone = (state, { files }) => [
      state,
      async (dispatch) => {
        //refresh recent books in state
        dispatch(LoadRecentBooks);

        //open if stored only one book
        if (files.length == 1) {
          let { file } = files[0];
          let book = Book(file);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          state.router.push({ book: book.id, chapterId });
          dispatch(OpenBook, { bookId: book.id, chapterId });
        } else {
          state.router.push({});
          dispatch(ShowRecentBooks);
        }
      }
    ];
    let StoreFiles = (state, { files: localFiles, fileContents }) => [
      state,
      async (dispatch) =>  {
        let readFile = (localFile) => new Promise(resolve => {
          let reader = new FileReader();
          reader.addEventListener('load', event => {
            let file = {
              name: localFile.name,
              size: localFile.size,
            };
            let fileContent = event.target.result;
            resolve({ file, fileContent });
          });
          reader.readAsText(localFile);
        });

        let files = [];
        for (let localFile of localFiles) {
          files.push(await readFile(localFile));
        }

        dispatch(StoreBooks, { files, onSuccess: [StoreFilesDone, { files }] });
        /**
        for (let i = 0; i < localFiles.length; i++) {
          let reader = new FileReader();
          reader.addEventListener('load', async event => {
            fileContents[i] = event.target.result;
            files[i] = {
              name: localFiles[i].name,
              size: localFiles[i].size,
            };

            let book = Book(files[i]);
            let existingFile = await state.db.get('files', book.id);
            if (existingFile?.size != files[i].size) {
              book = Book(files[i], fileContents[i]);
              dispatch(SaveProgress, { book, chapter: book.chapters[0] });
              updated[i] = true;
            }

            let tx = state.db.transaction(['files', 'fileContents'], 'readwrite');
            await Promise.all([
              tx.objectStore('files').put(files[i], book.id),
              tx.objectStore('fileContents').put(fileContents[i], book.id),
              tx.done,
            ]);

            dispatch(StoreBook, { bookId: book.id });
            storedCount++;

            if (storedCount == localFiles.length) {
              
            }
          });
          reader.readAsText(localFiles[i]);
        }
        /**/
      },
    ];

    let StoreBooks = (state, { files, onSuccess }) => [
      state,
      async (dispatch) => {
        let chapterKeys = await state.db.getAllKeys('chapters');

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          ...files.flatMap(({ file, fileContent }) => {
            let book = Book(file, fileContent);
            return [
              tx.objectStore('files').put(file, book.id),
              tx.objectStore('fileContents').put(fileContent, book.id),
              tx.objectStore('books').put(book.toJSON(), book.id),
              ...chapterKeys.filter(k => k.startsWith(book.id + '/')).map(k => tx.objectStore('chapters').delete(k)),
              ...book.chapters.map(c => tx.objectStore('chapters').put(c.toJSON(), book.id + '/' + c.id)),
            ];
          }),
          tx.done,
        ]);

        if (onSuccess) dispatch(...onSuccess);
      }
    ];

    let RefreshBook = (state, { bookId, onSuccess }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [file, fileContent] = await Promise.all([
          state.db.get('files', bookId),
          state.db.get('fileContents', bookId),
        ]);
        if (!file || !fileContent) {
          console.info('File not found:', { bookId, file, fileContent });
          return;
        }
        
        if (!onSuccess) onSuccess = [OpenBook, { bookId }];

        dispatch(StoreBooks, {
          files: [{ file, fileContent }],
          onSuccess,
        });
      }
    ];

    let DeleteBookDone = (state, { bookId }) => ({ ...state, files: state.files.filter(file => Book(file).id != bookId) });
    let DeleteBook = (state, { bookId }) => [
      state,
      async (dispatch) => {
        let chapterKeys = (await state.db.getAllKeys('chapters')).filter(k => k.startsWith(bookId + '/'));

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          tx.objectStore('files').delete(bookId),
          tx.objectStore('fileContents').delete(bookId),
          tx.objectStore('books').delete(bookId),
          ...chapterKeys.map(k => tx.objectStore('chapters').delete(k)),
          tx.done,
        ]);

        dispatch(DeleteBookDone, { bookId });
      }
    ];

    let ShowRecentBooks = (state) => {
      if (!state.book) return state;
      return [
        { ...state, book: null, chapter: null },
        () => {
          state.router.push({});
          document.title = 'Text Reader';
          requestAnimationFrame(() => {
            scroll(0, 0);
          });
        }
      ];
    };

    let sizeFormatter = new Intl.NumberFormat(undefined, { notation: 'compact', style: 'unit', unit: 'byte', unitDisplay: 'narrow' });
    let formatSize = sizeFormatter.format.bind(sizeFormatter);

    let dateFormatter = new Intl.RelativeTimeFormat();
    let formatDate = (iso) => {
      if(!iso) return;
      let diff = (Date.now () - new Date(iso)) / 1000;
      for (let [unit, seconds] of Object.entries({
        months: 30 * 24 * 60 * 60,
        days: 24 * 60 * 60,
        hours: 60 * 60,
        minutes: 60,
        seconds: 0,
      })) {
        if (diff >= seconds) return dateFormatter.format(-Math.round(diff / (seconds || 1)), unit);
      }
    };

    app({
      init: [
        {
          router: new HashRouter(),
          db: null,
          files: [],
          book: null,
          chapter: null,
          progress: {},
          settings: {
            sort: {
              field: 'updatedAt',
              direction: 'desc'
            }
          },
        },
        (dispatch) => {
          dispatch(InitRouter);
          dispatch(InitTheme);
          dispatch(InitDb);
          dispatch(InitDropzone);
          dispatch(InitKeyboardNavigator);
        }
      ],
      dispatch: (dispatch) => {
        return (action, payload) => {
          if (typeof action == 'function') {
            let log = [action.name];
            if (payload !== undefined) log.push(payload);
            console.warn(...log);
          } else if (Array.isArray(action)) {
            //console.dir(action[0]);
          }

          dispatch(action, payload);
        };
      },
      node: document.body,
      view: ({ router, files, book, chapter, progress, settings }) => (
        h('body', {}, [
          !book && (
            h('div', { class: 'table' }, [
              h('a', {
                class: 'th text-left',
                'data-sort': settings.sort.field == 'name' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'name', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('File'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'size' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'size', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Size'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'chapterCount' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'chapterCount', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Chapters'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'updatedAt' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'updatedAt', direction = 'desc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Date'))),
              h('span', { class: 'th' }, h('span', {})),
              ...files.sort((a, z) => {
                let { field, direction } = settings.sort;
                let A = Book(a), Z = Book(z);
                let result;
                if (field == 'name') {
                  result = A.name.localeCompare(Z.name, 'vi-VN', { sensitivity: 'accent' });
                } else if (field == 'size') {
                  result = a[field] - z[field];
                } else if (field == 'updatedAt') {
                  a = new Date(progress[A.id]?.[field] || 0);
                  z = new Date(progress[Z.id]?.[field] || 0);
                  result = a - z;
                } else if (field == 'chapterCount') {
                  result = (progress[A.id]?.[field] || 1) - (progress[Z.id]?.[field] || 1);
                }
                if ((direction == 'desc') && (result != 0)) result = -result;
                return result;
              }).flatMap(file => {
                let book = Book(file);
                let { chapterId, chapterIndex, chapterCount, updatedAt } = (progress[book.id] || {});
                return [
                  h('div', { class: 'td' }, [
                    h('a', {
                      class: 'name',
                      href: router.route({ book: book.id, chapter: chapterId }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [OpenBook, { bookId: book.id, chapterId }];
                      }
                    }, [
                      text(book.name)
                    ]),
                    book.description && (
                      h('small', { class: 'desc' }, text(book.description))
                    )
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(formatSize(file.size)))
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(!chapterCount ? '-' : `${chapterIndex}/${chapterCount}`))
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(formatDate(updatedAt) || '-'))
                  ]),
                  h('div', { class: 'td' }, [
                    h('a', { class: 'delete', onclick: [DeleteBook, { bookId: book.id }] }, [
                      h('small', {}, text('delete'))
                    ])
                  ])
                ]
              })
            ])
          ),
          (book?.chapters?.length > 0) && (
            h('nav', {}, [
              h('ol', { start: 0 }, [
                ...book.chapters.map(c => (
                  h('li', { class: { active: c.id == chapter.id } }, [
                    h('a', {
                      href: router.route({ book: book.id, chapter: c.id }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [OpenBook, { bookId: book.id, chapterId: c.id }];
                      },
                      title: c.title,
                    }, [
                      text(c.title)
                    ])
                  ])
                ))
              ])
            ])
          ),
          chapter && (
            h('main', {}, [
              h('article', {}, [
                ...chapter.content.split(/\n|<\/?\w+>/gi).map(line => (
                    /^[-]+$/.test(line)
                      ? h('hr', {})
                      : h('p', {}, text(line))
                  )
                )
              ])
            ])
          ),
          h('aside', { class: 'settings' }, [
            chapter && (
              h('a', {
                class: 'close',
                href: router.route({}),
                onclick: (_, event) => {
                  event.preventDefault();
                  return [ShowRecentBooks];
                }
              })
            ),
            h('div', { class: 'colors' }, ['white', 'sepia', 'gray', 'night', 'rose-pine', 'rose-pine-moon', 'rose-pine-dawn'].map(color => (
              h('button', {
                class: [color, { checked: settings.color == color }],
                onclick: [SaveSettings, { color: color }],
                title: color,
              })
            ))),
            chapter && (
              h('button', { class: 'refresh', onclick: [RefreshBook, { bookId: book.id, chapterId: chapter.id }] })
            )
          ])
        ])
      )
    });

    function Book(file, fileContent, chapters) {
      let id, name, description;
      if (file?.name) {
        name = /(?<name>^[^(]*).*?\.txt/.exec(file.name.normalize()).groups.name.trim();
        description = /(?<description>\(.*)\.txt/.exec(file?.name.normalize())?.groups?.description?.trim();
        id = slug(name);
      }
      if (fileContent) {
        fileContent = normalizeFileContent(fileContent);
        // fileContent = titleizeHumanName(fileContent);
        chapters = extractChapters(name, fileContent, { name });
      }
      return {
        id,
        name,
        description,
        chapters,
        toJSON() {
          return {
            id,
            name,
            description,
            chapters: chapters.map(c => {
              c = c.toJSON();
              delete c.content;
              return c;
            }),
          }
        }
      };
    }

    function normalizeFileContent(text) {
      text = text.normalize();
      text = text.replace(/[^.]*(Sắc Hiện Viện|Sắc Hiệp Viện|Sachiepvien\.net)[^.]*\.?/g, '');
      text = text.replace(/[\r\n]+/g, '\n');
      text = text.replace(/(.+)/g, (s) => s.trim());
      text = text.replace(/^'([^']+)'$/gm, '"$1"');
      text = text.replace(/(\d)\s*(\.)\s*(\d)/gm, '$1$2$3');
      text = text.replace(/\s+([.,;:?!\]】)])/gm, '$1');
      text = text.replace(/([([【])\s+/gm, '$1');
      text = text.replace(/([:—]{2,})/gm, c => c.slice(0, 1));
      text = text.replace(/(:)[^\s\w]+\s*/gm, '$1 ');
      text = text.replace(/^\s*"\s+|\s+"\s*$/gm, '"');
      return text;
    }

    function Chapter(_, { chapters, filename, text }) {
      return {
        _,
        get title() {
          let title, titleBook, titleChap;
          if (_.bookNum) titleBook = 'Bộ ' + _.bookNum;
          else if (_.bookText) titleBook = 'Bộ ' + _.bookText;
          if (_.chapNum) titleChap = 'Chương ' + _.chapNum;
          else if (_.chapText) titleChap = 'Chương ' + _.chapText;
          title = [titleBook, titleChap].filter(Boolean).join(' ');
          title = [title, _.title].filter(Boolean).join(': ');
          if (!title) title = _.text;
          return title;
        },
        get i() {
          return chapters.indexOf(this);
        },
        get startIndex() {
          // return text.lastIndexOf('\n', _.index);
          return _.index;
        },
        get endIndex() {
          if (this.i == chapters.length-1) return text.length;
          return chapters[this.i + 1].startIndex;
        },
        get id() {
          return slug(this.title) + '-' + this.i;
        },
        get content() {
          return text.slice(this.startIndex, this.endIndex).trim();
        },
        get chapter() {
          let num = _.chapNum || _.chapText;
          if (num) return Number(num);
        },
        get length() {
          return this.endIndex - this.startIndex;
        },
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            content: this.content,
          }
        }
      };
    }

    function extractChapters(filename, text, { name }) {
      let NUMERIC = '(\\d{1,3}(\\.\d{1,2})*)';
      let NUMERIC_WORDS = '((một|hai|ba|bốn|năm|sáu|bảy|tám|chín|(mười( một)?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( mốt)?)( (hai|ba|bốn|lăm|sáu|bảy|tám|chín))?))|(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập)';
      let patterns = [
        /*
        【xanh biếc lữ du tiên】 bộ 2 tự chương
        【xanh biếc lữ du tiên】 bộ 2 thứ 01 chương
        Xanh Biếc lữ du tiên bộ 2 thứ 09 chương
        【xanh biếc lữ du tiên bộ 2】 thứ 10 chương Đông hải tiên các (1)
        Xanh Biếc lữ du tiên bộ 2 thứ 13 chương Nữ Đế dâm tâm
        【xanh biếc lữ du tiên】 Chương 8:
        【Chương 8: Tông môn dâm loạn (nhất)】
        【xanh biếc lữ du tiên】 Chương 6:
        【Chương 6: Hoàng thành long ảnh】
        Thứ 02 chương: Hong Kong
        Thứ 1 chương đại nghịch bất đạo ái đồ, nhưng lại hy vọng đem sư tôn dạy dỗ vì song tu chuyên dụng ấu thê!
        Thứ 10 chương, võ diễm hòa không rõ thân phận nam nhân thông đồng cùng với trần san cùng ca ca trần vừa loạn luân địt bi chuyện xưa
        【mẹ thành gia bên trong bảo mẫu con dâu】(15) hoàn
        Nhị, thay đổi
        【bạn gái đệ đệ】3
        "Bạn gái đệ đệ" 11
        Thượng (2)
        Chính Văn Chương 07: Chỉnh quân
        Nhất, lời dẫn tưởng nói ngắn gọn, nhưng không biết từ đâu nói lên.
        Thứ 34 chương mẫu thượng công lược (3.11) An Nặc tiến bệnh viện
        — Chương 2: (dịch nóng thể)—
        2020 năm tháng 1 6 ngày
        Hạ bộ — chị em yêu nhau (lục hi hòa lục nếu)
        【mẹ con】(nhị -- yêu nói hết)
        (nhị -- yêu nói hết)
        ch. 1
        Hồi 1: Ngây thơ diện mạo Khuynh Thành vận giao mui xe thị lão Ông phủ ấu tử từ huệ thục hiền Hongkong
        Thứ 41-48 chương
        */
        //Chương 23:
        //Phiên ngoại Chương 18:
        '^(Phiên Ngoại )?Chương CHAP_NUM:$',
        //Chương 1: Tân niên đặc biệt thiên (thượng)
        //Phiên Ngoại Chương 8: Treo đầu dê bán thịt chó
        '^(Phiên Ngoại )?Chương CHAP_NUM([: ]TITLE)?$',
        //Ngũ
        //Hai mươi mốt
        '^CHAP_TEXT$',
        // (1)
        '^\\(CHAP_NUM\\)$',
        //8.1
        '^CHAP_NUM$',
        // (tứ)
        // (mười một)
        '^\\(CHAP_TEXT\\)$',
        //【bạn gái đệ đệ】9
        '^【' + name + '】CHAP_NUM([: ]TITLE)?',
        //Thứ 7 chương mẫu thượng công lược (1.7) tiểu ma nữ phục vụ
        // '^Thứ BOOK_NUM chương ' + name + ' \\(CHAP_NUM\\)([: ]TITLE)?',
        //Thứ 31 chương
        '^Thứ CHAP_NUM chương([: ]TITLE)?',
        //Bảy năm vợ chồng gần ba năm cùng hai cái đơn nam đệ tử chuyện xưa (5)
        '^' + name + ' \\(CHAP_NUM\\)',
        //2019-7-19 mười lăm
        '^DATE CHAP_TEXT',
        //Mười hai, nửa năm sau cuộc sống vẫn đang tiếp tục. Phố xá như trước thái bình.
        '^CHAP_TEXT[,] TITLE$',
        //Quyển thứ hai Chương 11: Mỹ mẫu cầu xin
        '^Quyển( thứ)? (BOOK_NUM|BOOK_TEXT) Chương CHAP_NUM: TITLE',
        //Lời dẫn
        '^(chương (cuối|kết)|tự chương|Lời dẫn)$',
        //【xanh biếc lữ du tiên】 bộ 2 thứ 08 chương
        '^【' + name + '】 bộ BOOK_NUM thứ CHAP_NUM chương',
        //Xanh biếc lữ du tiên bộ 2 Chương 8: Sơ ngộ bích du
        '^' + name + ' bộ BOOK_NUM Chương CHAP_NUM: TITLE',
        //(Chương 20: hèn chó diễn phượng (che giấu thiên 3)
        '^\\(Chương CHAP_NUM: TITLE',
        //Phiên Ngoại hai mươi lăm chương
        '^(Phiên Ngoại )CHAP_TEXT chương',
        //【các huynh đệ loạn luân thịnh yến】(tam)
        //【không chỉ tình yêu】(1)
        '^【' + name + '】\\((CHAP_TEXT|CHAP_NUM)\\)',
        //【không chỉ tình yêu】(phiên ngoại) cảnh phỉ mẹ con kích tình thượng kính
        '^【' + name + '】(phiên ngoại) TITLE',
        //"Ân, ta đều nghe ngươi!" (13)
        '(?<=\\W) \\(CHAP_NUM\\)$',
        //(14) nghiêm hạo tại sofa phía trên thích không thể tự thoát ra được, nhất tinh mặc xong đồ ngủ, sau đó tiếp lấy đem nghiêm hạo ôm đến chân của mình phía trên, nhẹ nhàng âu yếm.
        '\\(CHAP_NUM\\)',
        //"2" hào môn bí mật
        '^"\\s*CHAP_NUM\\s*"( TITLE)?',
        //"13 chương kết"
        '^"CHAP_NUM TITLE"$',
        //Người nhà quần áo Chương 1: Mẹ dị thường
        '^' + name + ' Chương CHAP_NUM: TITLE$',
        //Tập thứ hai thứ 36 chương con tin uy hiếp
        '^Tập thứ BOOK_TEXT thứ CHAP_NUM chương TITLE$',
        //22)
        '^CHAP_NUM\\)$',
      ];
      let matches = [];
      for (let pattern of patterns) {
        let source = pattern
          .replace('DATE', '\\d+-\\d+-\\d+')
          .replace('SEP', '[ :]')
          .replace('TITLE', '(?<title>.+)')
          .replace('CHAP_NUM', `(?<chapNum>${NUMERIC})`)
          .replace('CHAP_TEXT', `(?<chapText>${NUMERIC_WORDS})`)
          .replace('BOOK_NUM', `(?<bookNum>${NUMERIC})`)
          .replace('BOOK_TEXT', `(?<bookText>${NUMERIC_WORDS})`);
        let regex = new RegExp(source, 'gimu');
        let result = [...text.matchAll(regex)];
        matches.push(...result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] })));
      }
      matches.forEach(m => {
        for (let f of ['chapText', 'bookText']) {
          if (m[f]) {
            let c = m[f].toLowerCase();
            let vn = {
              'mươi': '',
              'mươi$': 0,
              '(mười|thập)(?=.+)|m[ộố]t|nhất': 1,
              'hai|nhị': 2,
              'ba|tam': 3,
              'bốn|tứ': 4,
              '[nl]ăm|ngũ': 5,
              'sáu|lục': 6,
              'bảy|thất': 7,
              'tám|bát': 8,
              'chín|cửu': 9,
              'mười|thập': 10,
            };
            Object.entries(vn).forEach(([w, i]) => {
              w = new RegExp(w, 'gimu');
              c = c.replace(w, i);
            });
            c = c.replace(/\s/g, '');
            m[f] = Number.parseInt(c);
          }
        }
        for (let f of ['chapNum', 'bookNum']) {
          if (m[f]) {
            m[f] = m[f].split('.').map(Number).join('.');
          }
        }
      });
      matches.sort((a, z) => a.index - z.index);

      let chapters = [];
      matches.forEach(m => {
        chapters.push(Chapter(m, { chapters, filename, text }));
      });

      mergeShortChapters(chapters, 500);
      dedupeChapters(chapters);
      cleanupChapters(chapters);
      addPrologue(chapters, filename, text);

      return chapters;
    }

    function mergeBehind(chapters, i) {
      // chapters[i].endIndex = chapters[i+1].endIndex;
      chapters.splice(i, 1);
    }

    function dedupeChapters(chapters) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let h = i-1;
        let ch = chapters[h];
        let ci = chapters[i];
        if (ch.chapter && ch.chapter == ci.chapter) {
          // console.log('dedupe', ch.title, ci.title);
          mergeBehind(chapters, i);
        }
      }
    }

    function cleanupChapters(chapters) {
      // debug({chapters})
      let i = 1;
      while (i < chapters.length - 1) {
        let [ch, ci, cj] = [chapters[i-1], chapters[i], chapters[i+1]];
        let shouldMerge = false;
        //ci is not continuity of ch
        if (ch.chapter && ci.chapter && (ch.chapter + 1 != ci.chapter)) {
          if (!cj) {
            //ci is the last chapter, can merge
            //TODO: check if ci is [phien ngoai]
            shouldMerge = true;
          } else {
            //find continuity of ch
            for (let j = i + 1; j <= i + 3 && j < chapters.length; j++) {
              cj = chapters[j];
              // console.log(ch.chapter, cj.chapter);
              if (cj.chapter && (ch.chapter + 1 == cj.chapter)) {
                shouldMerge = true;
                break;
              }
            }
          }
        }
        if (shouldMerge) {
          // console.debug('cleanupChapters', ch.chapter, '<-', ci.chapter, cj?.chapter);
          mergeBehind(chapters, i);
        } else {
          i++;
        }
      }
      // for(let i = 1; i < chapters.length; ) {
      //   let [h, j] = [i - 1, i + 1];
      //   //if ci is not continuity of ch
      //   if (ch.chapter && ci.chapter && (ch.chapter + 1) != ci.chapter) {
      //     // ci is the last chapter, can merge
      //     if (!cj) {
      //       console.debug('cleanupChapters', ch.chapter, '<-', ci.chapter);
      //       mergeBehind(chapters, i);
      //     } else {
      //       // cj is the continuity of ch
      //       if (cj.chapter && ch.chapter + 1 == cj.chapter) {
      //       }
      //     }
      //   }
      // }
    }
    
    function mergeShortChapters(chapters, minLength = 2_000) {
      for (let i = chapters.length - 1; i > 0; i--) {
        if (chapters[i].length < minLength) {
          mergeBehind(chapters, i);
        }
      }
    }

    function mergeShortChapters1(chapters, minLength = 2e3) {
      let isShort = chapter => ((chapter.endIndex - chapter.startIndex) <= minLength);
      let isLong = chapter => !isShort(chapter);
      //delete all first short chapters, they belongs to prologue
      let firstLongChapterIndex = chapters.findIndex(isLong);
      chapters.splice(0, firstLongChapterIndex);
      //merge short chapters to next long chapter
      let short;
      while((short = chapters.find(isShort))) {
        let shortIndex = chapters.indexOf(short);
        let long = chapters.find((chapter, index) => isLong(chapter) && index >= shortIndex);
        let longIndex = chapters.indexOf(long);
        if (long) {
          short.endIndex = long.endIndex;
          chapters.splice(shortIndex, longIndex - shortIndex);
        } else {
          //merge last short chapters to previous long chapter
          long = chapters[shortIndex - 1];
          if (long) {
            long.endIndex = text.length;
            chapters.length = shortIndex;
          }
          break;
        }
      }
    }

    function addPrologue(chapters, filename, text) {
      //extract prologue
      let prologue = text.slice(0, chapters[0]?.startIndex ?? -1).trim();
      if(prologue) {
        chapters.unshift(Chapter({
          title: filename,
          index: 0,
        }, { chapters, filename, text }));
      }
    }

    function extractChapters1(filename, text, { name }) {
      let debug = true;
      debug && console.log({ name });
      //let chapterPattern = /^\s*\[?\s*(?:chapter)?\s*:?\s*Thứ\s+\w+(\s*-\s*\d+)?\s+chương\b.*|\bChương\s+\d+\s*:?.*|^(?:\d+\s*\.?\s*)+$|^\s*\d+\s+Chương\s*:?\s*|^【.*?】\([\d-]+\)$|^【.*?】\s*bộ(\s+\d+)+$|^\d+[.!].*|^\s*\d+(\s*-\s*\d+)?\s*$|^[-]+$/gimu;
      let certainPatterns = [
        /^chương \d+$/,
        /^chương \d+:/,
        /^— ?chương \d+:.*? ?—/,
        /^chương (cuối|kết)/,
        /^tự chương/,
        /^Lời dẫn/,
        /^bộ \d+:? chương \d+/, // bộ 01: chương 05:
        /^thứ \d+ bộ thứ \d+ chương/, // thứ 01 bộ thứ 02 chương
        /^\d+([\.\s]+\d+)*$/,
        /thứ \d+ chương/,
        /^\(\d+\)/,
        /^Hồi \d+/,
        new RegExp('^【' + name + '】\\d+$'),
        new RegExp('^"' + name + '" \\d+$'),
        /^ch\. \d+/,
        /^ ?\[? ?(?:chapter)? ?:? ?Thứ \w+( ?- ?\d+)? chương/,
        /^ ?\d+ Chương ?:? ?/,
        /^【.*?】\([\d-]+\)$/,
        /^【.*?】 ?bộ( \d+)+$/,
        /^\d+[.!].*/,
        /^ ?\d+( ?- ?\d+)? ?$/,
        /quyển (thứ )?(\d+|(một|hai|ba|bốn|năm|sáu|bảy|tám|chín|(mười( một)?|(hai|ba|bốn|năm|sáu|bảy|tám|chín) mươi( mốt)?)( (hai|ba|bốn|lăm|sáu|bảy|tám|chín))?)) chương \d.*/,
        /(phiên ngoại|chính văn) chương \d+:/,
        /phiên ngoại .* chương/,
        /^(thượng|trung|hạ) \(\d+\)$/,
        /^(thượng|trung|hạ) bộ/,
      ];
      let loosePatterns = [
        new RegExp('^【' + name + '】.*$'),
        new RegExp('^"' + name + '".*$'),
        new RegExp('^' + name + ' [\\(\\.:\\d]'),
        /^.*\((thượng|trung|hạ)\):?$/, // phản kích (thượng)
        /^([(]?)(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập|(mười) (một|hai|ba|bốn|năm|sáu|bảy|tám|chín|mươi))(?=[,:)])([^.]*)$/,
        /^(nhất|nhị|tam|tứ|ngũ|lục|thất|bát|cửu|thập).*/,
        /^\[.*\]$/,
        /^[-—* ]+$/,
      ];
      let matches;
      for (let patterns of [certainPatterns, loosePatterns]) {
        let regex = new RegExp('(?:' + patterns.map(p => '(?:' + p.source + ')').join('|') + ').*', 'gimu');
        matches = [...regex[Symbol.matchAll](text)];
        debug && console.log({ regex, matches })
        if (matches.length > 0) break;
      }
      let chapters = matches.map((match, i) => {
        let startIndex = text.lastIndexOf('\n', match.index);
        if (startIndex == -1) startIndex = 0;
        let endIndex = text.length;
        if (matches[i+1]) endIndex = text.lastIndexOf('\n', matches[i+1].index);
        let title = match[0].trim();
        if (/^[-—]+$/.test(title)) title = `-Chương ${i+1}-`;
        title = title.replace(new RegExp('^【(' + name + ')】\s*', 'i'), '');
        title = title.replace(new RegExp('^"(' + name + ')"\s*', 'i'), '');
        title = title.replace(new RegExp('^(' + name + ')\s*', 'i'), '');
        return {
          title,
          startIndex,
          endIndex,
        }
      });

      return mergeChapters(chapters, filename, text);
    }

    function slug(s) {
      s = latinize(s);
      s = s.replace(/\W+/g, '-');
      s = s.replace(/^-+|-+$/g, '');
      s = s.toLowerCase();
      return s;
    }

    function latinize(s) {
      s = s.replace(/[ÁĂẮẶẰẲẴǍÂẤẬẦẨẪÄǞȦǠẠȀÀẢȂĀĄÅǺḀȺÃⱯᴀ]/g, 'A');
      s = s.replace(/[Ꜳ]/g, 'AA');
      s = s.replace(/[ÆǼǢᴁ]/g, 'AE');
      s = s.replace(/[Ꜵ]/g, 'AO');
      s = s.replace(/[Ꜷ]/g, 'AU');
      s = s.replace(/[ꜸꜺ]/g, 'AV');
      s = s.replace(/[Ꜽ]/g, 'AY');
      s = s.replace(/[ḂḄƁḆɃƂʙᴃБ]/g, 'B');
      s = s.replace(/[ĆČÇḈĈĊƇȻꜾᴄ]/g, 'C');
      s = s.replace(/[ĎḐḒḊḌƊḎǲǅĐÐƋꝹᴅД]/g, 'D');
      s = s.replace(/[ǱǄ]/g, 'DZ');
      s = s.replace(/[ÉĔĚȨḜÊẾỆỀỂỄḘËĖẸȄÈẺȆĒḖḔĘɆẼḚƐƎᴇⱻЕЭ]/g, 'E');
      s = s.replace(/[Ꝫ]/g, 'ET');
      s = s.replace(/[ḞƑꝻꜰФ]/g, 'F');
      s = s.replace(/[ǴĞǦĢĜĠƓḠǤꝽɢʛГҐ]/g, 'G');
      s = s.replace(/[ḪȞḨĤⱧḦḢḤĦʜХ]/g, 'H');
      s = s.replace(/[ÍĬǏÎÏḮİỊȈÌỈȊĪĮƗĨḬІɪЙЫИ]/g, 'I');
      s = s.replace(/[ꞂŔŘŖṘṚṜȐȒṞɌⱤʁʀᴙᴚР]/g, 'R');
      s = s.replace(/[ꞄŚṤŠṦŞŜȘṠṢṨꜱС]/g, 'S');
      s = s.replace(/[ꞆŤŢṰȚȾṪṬƬṮƮŦᴛТ]/g, 'T');
      s = s.replace(/[Ꝭ]/g, 'IS');
      s = s.replace(/[ĴɈᴊ]/g, 'J');
      s = s.replace(/[ḰǨĶⱩꝂḲƘḴꝀꝄᴋК]/g, 'K');
      s = s.replace(/[ĹȽĽĻḼḶḸⱠꝈḺĿⱢǈŁꞀʟᴌЛ]/g, 'L');
      s = s.replace(/[Ǉ]/g, 'LJ');
      s = s.replace(/[ḾṀṂⱮƜᴍМ]/g, 'M');
      s = s.replace(/[ŃŇŅṊṄṆǸƝṈȠǋÑɴᴎН]/g, 'N');
      s = s.replace(/[Ǌ]/g, 'NJ');
      s = s.replace(/[ÓŎǑÔỐỘỒỔỖÖȪȮȰỌŐȌÒỎƠỚỢỜỞỠȎꝊꝌŌṒṐƟǪǬØǾÕṌṎȬƆᴏᴐО]/g, 'O');
      s = s.replace(/[Ƣ]/g, 'OI');
      s = s.replace(/[Ꝏ]/g, 'OO');
      s = s.replace(/[Ȣᴕ]/g, 'OU');
      s = s.replace(/[ṔṖꝒƤꝔⱣꝐᴘП]/g, 'P');
      s = s.replace(/[ꝘꝖ]/g, 'Q');
      s = s.replace(/[ß]/g, 'ss');
      s = s.replace(/[ɅꝞṾƲṼᴠВ]/g, 'V');
      s = s.replace(/[Ꜩ]/g, 'TZ');
      s = s.replace(/[ÚŬǓÛṶÜǗǙǛǕṲỤŰȔÙỦƯỨỰỪỬỮȖŪṺŲŮŨṸṴᴜУ]/g, 'U');
      s = s.replace(/[Ꝡ]/g, 'VY');
      s = s.replace(/[ẂŴẄẆẈẀⱲᴡ]/g, 'W');
      s = s.replace(/[ẌẊ]/g, 'X');
      s = s.replace(/[ÝŶŸẎỴỲƳỶỾȲɎỸʏ]/g, 'Y');
      s = s.replace(/[Ї]/g, 'YI');
      s = s.replace(/[ŹŽẐⱫŻẒȤẔƵᴢЗ]/g, 'Z');
      s = s.replace(/[Þ]/g, 'TH');
      s = s.replace(/[Ĳ]/g, 'IJ');
      s = s.replace(/[Œɶ]/g, 'OE');
      s = s.replace(/[áăắặằẳẵǎâấậầẩẫäǟȧǡạȁàảȃāąᶏẚåǻḁⱥãɐₐАа]/g, 'a');
      s = s.replace(/[ꜳ]/g, 'aa');
      s = s.replace(/[æǽǣᴂ]/g, 'ae');
      s = s.replace(/[ꜵ]/g, 'ao');
      s = s.replace(/[ꜷ]/g, 'au');
      s = s.replace(/[ꜹꜻ]/g, 'av');
      s = s.replace(/[ꜽ]/g, 'ay');
      s = s.replace(/[ḃḅɓḇᵬᶀƀƃб]/g, 'b');
      s = s.replace(/[ɵóŏǒôốộồổỗöȫȯȱọőȍòỏơớợờởỡȏꝋꝍⱺōṓṑǫǭøǿõṍṏȭɔᶗᴑᴓₒо]/g, 'o');
      s = s.replace(/[ćčçḉĉɕċƈȼↄꜿ]/g, 'c');
      s = s.replace(/[ďḑḓȡḋḍɗᶑḏᵭᶁđɖƌðꝺд]/g, 'd');
      s = s.replace(/[ıíĭǐîïḯịȉìỉȋīįᶖɨĩḭіᴉᵢйыи]/g, 'i');
      s = s.replace(/[ȷɟʄǰĵʝɉⱼ]/g, 'j');
      s = s.replace(/[ǳǆ]/g, 'dz');
      s = s.replace(/[éĕěȩḝêếệềểễḙëėẹȅèẻȇēḗḕⱸęᶒɇẽḛɛᶓɘǝₑеэ]/g, 'e');
      s = s.replace(/[ꝫ]/g, 'et');
      s = s.replace(/[ḟƒᵮᶂꝼф]/g, 'f');
      s = s.replace(/[ǵğǧģĝġɠḡᶃǥᵹɡᵷгґ]/g, 'g');
      s = s.replace(/[ḫȟḩĥⱨḧḣḥɦẖħɥʮʯх]/g, 'h');
      s = s.replace(/[ƕ]/g, 'hv');
      s = s.replace(/[ꞃŕřŗṙṛṝȑɾᵳȓṟɼᵲᶉɍɽɿɹɻɺⱹᵣр]/g, 'r');
      s = s.replace(/[ꞅſẜẛẝśṥšṧşŝșṡṣṩʂᵴᶊȿс]/g, 's');
      s = s.replace(/[ꞇťţṱțȶẗⱦṫṭƭṯᵵƫʈŧʇт]/g, 't');
      s = s.replace(/[ꝭ]/g, 'is');
      s = s.replace(/[ḱǩķⱪꝃḳƙḵᶄꝁꝅʞк]/g, 'k');
      s = s.replace(/[ĺƚɬľļḽȴḷḹⱡꝉḻŀɫᶅɭłꞁл]/g, 'l');
      s = s.replace(/[ǉ]/g, 'lj');
      s = s.replace(/[ḿṁṃɱᵯᶆɯɰм]/g, 'm');
      s = s.replace(/[ńňņṋȵṅṇǹɲṉƞᵰᶇɳñн]/g, 'n');
      s = s.replace(/[ǌ]/g, 'nj');
      s = s.replace(/[ƣ]/g, 'oi');
      s = s.replace(/[ꝏ]/g, 'oo');
      s = s.replace(/[ȣ]/g, 'ou');
      s = s.replace(/[ṕṗꝓƥᵱᶈꝕᵽꝑп]/g, 'p');
      s = s.replace(/[ꝙʠɋꝗ]/g, 'q');
      s = s.replace(/[ᴝúŭǔûṷüǘǚǜǖṳụűȕùủưứựừửữȗūṻųᶙůũṹṵᵤу]/g, 'u');
      s = s.replace(/[ᵺþ]/g, 'th');
      s = s.replace(/[ᴔœ]/g, 'oe');
      s = s.replace(/[ʌⱴꝟṿʋᶌⱱṽᵥв]/g, 'v');
      s = s.replace(/[ʍẃŵẅẇẉẁⱳẘ]/g, 'w');
      s = s.replace(/[ʎýŷÿẏỵỳƴỷỿȳẙɏỹ]/g, 'y');
      s = s.replace(/[ꜩ]/g, 'tz');
      s = s.replace(/[ᵫ]/g, 'ue');
      s = s.replace(/[ꝸ]/g, 'um');
      s = s.replace(/[ꝡ]/g, 'vy');
      s = s.replace(/[ẍẋᶍₓ]/g, 'x');
      s = s.replace(/[ї]/g, 'yi');
      s = s.replace(/[źžẑʑⱬżẓȥẕᵶᶎʐƶɀз]/g, 'z');
      s = s.replace(/[ﬀ]/g, 'ff');
      s = s.replace(/[ﬃ]/g, 'ffi');
      s = s.replace(/[ﬄ]/g, 'ffl');
      s = s.replace(/[ﬁ]/g, 'fi');
      s = s.replace(/[ﬂ]/g, 'fl');
      s = s.replace(/[ĳ]/g, 'ij');
      s = s.replace(/[ﬆ]/g, 'st');
      s = s.replace(/[Ё]/g, 'YO');
      s = s.replace(/[Ц]/g, 'TS');
      s = s.replace(/[Ш]/g, 'SH');
      s = s.replace(/[Щ]/g, 'SCH');
      s = s.replace(/[ЪъЬь]/g, '\'');
      s = s.replace(/[ё]/g, 'yo');
      s = s.replace(/[ц]/g, 'ts');
      s = s.replace(/[ш]/g, 'sh');
      s = s.replace(/[щ]/g, 'sch');
      s = s.replace(/[Ж]/g, 'ZH');
      s = s.replace(/[ж]/g, 'zh');
      s = s.replace(/[Я]/g, 'Ya');
      s = s.replace(/[Ч]/g, 'CH');
      s = s.replace(/[Ю]/g, 'YU');
      s = s.replace(/[я]/g, 'ya');
      s = s.replace(/[ч]/g, 'ch');
      s = s.replace(/[ю]/g, 'yu');
      return s;
    }

    function titleizeHumanName(s, minOccurence = 10, occurenceThreshold = 0.8) {
      let debug = false;
      debug && console.time('titleizeHumanName');
      let pattern = /(?:(?<pre>\p{Ll}+)[ ]+)?(?<name>[\p{Lu}A-Z]\p{Ll}+(?:[ ]+\p{Lu}\p{Ll}+)?)(?:[ ]+(?<post>\p{Ll}+))?/gu;
      let counts = {};
      let match;
      let titleize = s => s.replace(/(?<=^|[^\p{L}])\p{L}/gu, s => s.toUpperCase());
      let c = 0;
      while ((match = pattern.exec(s))) {
        if (++c < 10) debug && console.log({ match });
        let { pre, name, post } = match.groups;
        if (!counts[name]) counts[name] = { total: 0, pre: {}, post: {} };
        counts[name].total += 1;
        if (pre) {
          if (!counts[name].pre[pre]) counts[name].pre[pre] = 0;
          counts[name].pre[pre] += 1;
        }
        if (post) {
          if (!counts[name].post[post]) counts[name].post[post] = 0;
          counts[name].post[post] += 1;
        }
      }
      debug && console.dir(counts);
      analyze: for (let [name, { total, pre, post }] of Object.entries(counts)) {
        if (total < minOccurence) {
          debug && console.debug(name, 'is too few .. IGNORE', { total });
          continue analyze;
        }
        for (let [prefix, prefixCount] of Object.entries(pre)) {
          if (prefixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(prefix), name, { total, prefixCount });
            s = s.replace(new RegExp(prefix + '\\s+' + name, 'gu'), titleize);
            continue analyze;
          }
        }
        for (let [postfix, postfixCount] of Object.entries(post)) {
          if (postfixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(postfix), name, { total, postfixCount });
            s = s.replace(new RegExp(name + '\\s+' + postfix, 'gu'), titleize);
            continue analyze;
          }
        }
      }
      debug && console.timeEnd('titleizeHumanName');
      return s;
    }

    function debug(...args) {
      if (args.length == 1) {
        console.table(Object.values(args[0])[0]);
      } else {
        console.info(...args);
      }
    }
  </script>
</body>
</html>


