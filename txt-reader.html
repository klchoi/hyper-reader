<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìñ</text></svg>">
  <title>Text Reader</title>
  <style>
    @font-face {
      font-family: Reader1;
      src: local('LMRoman12-Regular'), url('https://mirror.kku.ac.th/CTAN/fonts/lm/fonts/opentype/public/lm/lmroman12-regular.otf') format('opentype');
    }
    @font-face {
      font-family: Reader;
      font-weight: 400;
      src: local('WorkSans-Regular');
    }
    @font-face {
      font-family: Reader;
      font-weight: 500;
      src: local('WorkSans-Medium');
    }

    /** reset **/
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      border: 0;
      outline: 0;
      transform-origin: 50% 50%;
    }
    p {
      margin: 1em 0;
    }
    hr {
      border: 0;
      height: 1px;
      background: rgba(0, 0, 0, .2);
    }
    a,
    a:any-link {
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-decoration-skip-ink: none;
      text-underline-offset: 4px;
      cursor: pointer;
    }
    small {
      font-size: 0.875em;
    }
    
    /** rose pine **/
    :root {
      --rp-main-base: #191724;
      --rp-main-surface: #1f1d2e;
      --rp-main-overlay: #26233a;
      --rp-main-muted: #6e6a86;
      --rp-main-subtle: #908caa;
      --rp-main-text: #e0def4;
      --rp-main-love: #eb6f92;
      --rp-main-gold: #f6c177;
      --rp-main-rose: #ebbcba;
      --rp-main-pine: #31748f;
      --rp-main-foam: #9ccfd8;
      --rp-main-iris: #c4a7e7;
      --rp-main-highlight-low: #21202e;
      --rp-main-highlight-low-alpha: #6e6a861a;
      --rp-main-highlight-med: #403d52;
      --rp-main-highlight-med-alpha: #6e6a8633;
      --rp-main-highlight-high: #524f67;
      --rp-main-highlight-high-alpha: #6e6a8666;
      --rp-moon-base: #232136;
      --rp-moon-surface: #2a273f;
      --rp-moon-overlay: #393552;
      --rp-moon-muted: #6e6a86;
      --rp-moon-subtle: #908caa;
      --rp-moon-text: #e0def4;
      --rp-moon-love: #eb6f92;
      --rp-moon-gold: #f6c177;
      --rp-moon-rose: #ea9a97;
      --rp-moon-pine: #3e8fb0;
      --rp-moon-foam: #9ccfd8;
      --rp-moon-iris: #c4a7e7;
      --rp-moon-highlight-low: #2a283e;
      --rp-moon-highlight-low-alpha: #817c9c14;
      --rp-moon-highlight-med: #44415a;
      --rp-moon-highlight-med-alpha: #817c9c26;
      --rp-moon-highlight-high: #56526e;
      --rp-moon-highlight-high-alpha: #817c9c4d;
      --rp-dawn-base: #faf4ed;
      --rp-dawn-surface: #fffaf3;
      --rp-dawn-overlay: #f2e9e1;
      --rp-dawn-muted: #9893a5;
      --rp-dawn-subtle: #797593;
      --rp-dawn-text: #575279;
      --rp-dawn-love: #b4637a;
      --rp-dawn-gold: #ea9d34;
      --rp-dawn-rose: #d7827e;
      --rp-dawn-pine: #286983;
      --rp-dawn-foam: #56949f;
      --rp-dawn-iris: #907aa9;
      --rp-dawn-highlight-low: #f4ede8;
      --rp-dawn-highlight-low-alpha: #6e6a860d;
      --rp-dawn-highlight-med: #dfdad9;
      --rp-dawn-highlight-med-alpha: #6e6a8614;
      --rp-dawn-highlight-high: #cecacd;
      --rp-dawn-highlight-high-alpha: #6e6a8626;
    }

    /** variables **/
    :root {
      --nav-width: 300px;
      --aside-width: 60px;
      --gap: 1rem;
      cursor: default;
    }
    .settings .colors button.white,
    :root[data-color=white] {
      --body-font-color: rgb(27, 27, 27);
      --body-background-color: rgb(230, 230, 230);
      --paper-background-color: rgb(255, 255, 255);
      --paper-shadow-color: rgba(0, 0, 0, .2);
      --link-color: rgb(65, 110, 210);
      --horizontal-line-color: rgb(220, 220, 220);
    }
    .settings .colors button.sepia,
    :root[data-color=sepia] {
      --body-font-color: rgb(79, 50, 28);
      --body-background-color: rgb(225, 216, 200);
      --paper-background-color: rgb(248, 241, 227);
      --paper-shadow-color: rgba(0, 0, 0, .2);
      --link-color: rgb(209, 150, 0);
      --horizontal-line-color: rgb(230, 218, 201);
    }
    .settings .colors button.gray,
    :root[data-color=gray] {
      --body-font-color: rgba(255, 255, 255, 0.78);
      --body-background-color: rgb(50, 50, 51);
      --paper-background-color: rgb(74, 74, 77);
      --paper-shadow-color: rgba(0, 0, 0, .24);
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(111, 111, 111);
    }
    .settings .colors button.night,
    :root[data-color=night] {
      --body-font-color: rgb(176, 176, 176);
      --body-background-color: rgb(0, 0, 0);
      --paper-background-color: rgb(18, 18, 18);
      --paper-outline-color: #272727;
      --link-color: rgb(90, 200, 250);
      --horizontal-line-color: rgb(62, 62, 62);
    }
    .settings .colors button.rose-pine,
    :root[data-color=rose-pine] {
      --body-font-color: var(--rp-main-subtle);
      --body-background-color: var(--rp-main-surface);
      --paper-background-color: var(--rp-main-base);
      --paper-outline-color: var(--rp-main-highlight-med-alpha);
      --link-color: var(--rp-main-pine);
      --horizontal-line-color: var(--rp-main-highlight-high-alpha);
    }
    .settings .colors button.rose-pine-moon,
    :root[data-color=rose-pine-moon] {
      --body-font-color: var(--rp-moon-subtle);
      --body-background-color: var(--rp-moon-surface);
      --paper-background-color: var(--rp-moon-base);
      --paper-outline-color: var(--rp-moon-highlight-med-alpha);
      --link-color: var(--rp-moon-rose);
      --horizontal-line-color: var(--rp-moon-highlight-high-alpha);
    }
    .settings .colors button.rose-pine-dawn,
    :root[data-color=rose-pine-dawn] {
      --body-font-color: var(--rp-dawn-text);
      --body-background-color: var(--rp-dawn-base);
      --paper-background-color: var(--rp-dawn-overlay);
      --paper-outline-color: var(--rp-dawn-highlight-med);
      --link-color: var(--rp-dawn-love);
      --horizontal-line-color: var(--rp-dawn-highlight-high);
    }

    /** layout **/
    body { display: flex; }
    body > * { flex: 1 }
    nav { flex: 0 0 var(--nav-width); }
    aside { flex: 0 0 var(--aside-width); }

    /** global **/
    html,
    body {
      font: 16pt/1.4 Reader;
      color: var(--body-font-color);
      background: var(--body-background-color);
      font-variant-numeric: oldstyle-nums tabular-nums slashed-zero;
    }
    a {
      color: var(--link-color);
    }

    /** nav **/
    nav {
      height: 100vh;
      overflow-y: auto;
      overscroll-behavior-y: contain;
      position: sticky;
      top: 0;
      padding: calc(var(--gap) * 0.75);
      font-size: 0.875rem;
      line-height: 1.2;
    }
    nav ol {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      align-items: start;
    }
    nav li {
      /**/
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /**/
      padding-top: 0.1ex;
      padding-bottom: 0.1ex;
      padding-left: calc(var(--gap) * 0.25);
      padding-right: calc(var(--gap) * 0.25);
    }
    nav li.active {
      background: var(--body-font-color);
      outline: calc(var(--gap) * 0.15) solid var(--body-font-color);
      border-radius: 0.5ex;
    }
    nav li.active a {
      pointer-events: none;
      color: var(--body-background-color);
    }
    nav a {
      color: var(--body-font-color);
    }
    nav a:hover {
      color: var(--link-color);
    }
    nav li:first-child a {
      font-weight: bold;
    }

    /** aside **/
    aside {
      position: sticky;
      top: 0;
      height: 100vh;
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      padding-left: var(--gap);
      padding-right: var(--gap);
      display: flex;
      flex-direction: column;
      row-gap: var(--gap);
    }
    aside a,
    aside button {
      appearance: none;
      background: var(--paper-background-color);
      color: var(--body-font-color);
      outline: 1px solid var(--horizontal-line-color);
      width: 100%;
      min-width: 25px;
      aspect-ratio: 1;
      display: grid;
      place-content: center;
      border-radius: 50%;
    }
    aside .colors {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: calc(var(--gap) * .75);
    }
    aside .colors button.checked::before {
      content: '‚úî';
      font-size: .7rem;
    }
    aside a.close {
      position: relative;
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
    }
    aside a.close::before,
    aside a.close::after {
      content: '';
      display: block;
      width: 50%;
      height: 1px;
      transform: translate3d(-50%, -50%, 0) rotateZ(var(--rotate, 45deg));
      position: absolute;
      top: 50%;
      left: 50%;
      background: currentColor;
    }
    aside a.close::after {
      --rotate: -45deg;
    }
    aside button.refresh {
      box-shadow: 0 3px 6px rgba(0, 0, 0, .2);
    }
    aside button.refresh::after {
      content: '‚Üª';
      font-size: 1rem;
      position: relative;
      top: -1px;
    }

    /** main **/
    main {
      /**
      padding-top: var(--gap);
      padding-bottom: var(--gap);
      /**/
      display: flex;
    }
    main article {
      flex: 1;
      background: var(--paper-background-color);
      padding: 1rem 3rem;
      outline: 1px solid var(--paper-outline-color, transparent);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color, transparent);
      text-indent: 3ch;
    }
    main article p:first-child {
      line-height: 1.2;
      font-size: 1.5rem;
      font-weight: bold;
    }
    main article hr {
      background: var(--horizontal-line-color);
    }

    /** table **/
    .table {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      row-gap: var(--gap);
      column-gap: calc(var(--gap) * 2);
      padding: 0 var(--gap) var(--gap);
      background: var(--paper-background-color);
      box-shadow: 0px 6px 12px 3px var(--paper-shadow-color);
      outline: 1px solid var(--paper-outline-color);
      line-height: 1.2;
      align-self: stretch;
      align-content: start;
    }
    .table .name {
      font-weight: bold;
    }
    .table .th {
      white-space: nowrap;
      padding: calc(var(--gap)/2) 0;
      position: sticky;
      top: 0;
      background: var(--paper-background-color);
    }
    .table .th::before {
      content: '';
      display: block;
      border-bottom: 1px solid var(--horizontal-line-color);
      width: calc(100% + 1ex);
      height: calc(2ex + 2px);
      box-shadow: 0 calc(1ex - 5px) 1.4ex -1ex rgba(0, 0, 0, .5);
      position: absolute;
      bottom: -1px;
      left: calc(-1ex / 2);
    }
    .table .th span {
      display: inline-block;
      position: relative;
    }
    .table .th span::after {
      position: absolute;
      bottom: calc(1ex/4);
      right: -1.8ex;
      color: var(--body-font-color);
    }
    .table .th[data-sort=asc] span::after { content: '‚Üë'; }
    .table .th[data-sort=desc] span::after { content: '‚Üì'; }
    .table .text-left { text-align: left; }
    .table .text-right { text-align: right; }
    .table .desc { display: block; }
    .table .delete { color: inherit; }
    .table .delete:hover { color: var(--link-color); }

    /** disable scroll when mouse is not over **/
    /**
    nav,
    main {
      height: 100%;
      overflow-y: hidden;
    }
    nav:hover,
    main:hover {
      overflow-y: auto;
    }
    /**/
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, text, app } from 'https://cdn.jsdelivr.net/npm/hyperapp/+esm';
    import { openDB } from 'https://cdn.jsdelivr.net/npm/idb/+esm';

    class HashRouter extends EventTarget {
      parse(hash) {
        return [...(new URLSearchParams(hash)).entries()].reduce((route, [k, v]) => (route[k] = v, route), {});
      }
      get(key) {
        return new URLSearchParams(location.hash.slice(1)).get(key);
      }
      current() {
        return this.parse(location.hash.slice(1));
      }
      route(route) {
        let hash = new URLSearchParams(Object.entries(route).filter(([k, v]) => v !== '' && v != null)).toString();
        if (hash) hash = '#' + hash;
        return hash;
      }
      push(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.pushState(null, null, url);
        }
      }
      replace(to) {
        let from = this.current();
        let allKeys = Object.keys({ ...from, ...to });
        let changed = allKeys.some(key => from[key] != to[key]);
        if (changed) {
          let url = new URL(location.href);
          url.hash = this.route(to);
          history.replaceState(null, null, url);
        }
      }
    }

    let InitDbDone = (state, { db }) => [
      { ...state, db },
      (dispatch) => {
        window.db = db;
        dispatch(LoadSettings);
        dispatch(LoadProgress);
        dispatch(LoadRecentBooks);
        dispatch(LoadRecentBook);
      }
    ];
    let InitDb = (state) => [
      state,
      async (dispatch) => {
        let db = await openDB('text-reader', 22, {
          upgrade(db, oldVersion, newVersion, transaction) {
            let schemas = {
              files: {},
              fileContents: {},
              settings: {},
              progress: {},
              books: {},
              chapters: {},
            };
            for (let [store, keyOptions] of Object.entries(schemas)) {
              if (!db.objectStoreNames.contains(store)) {
                db.createObjectStore(store, keyOptions);
              }
            }
            //for(let store of db.objectStoreNames) {
            //  if (!(store in schemas)) {
            //    console.warn('Delete store', store);
            //    db.deleteObjectStore(store);
            //  }
            //}
          },
          blocked: console.log,
          blocking: console.log,
          terminated: console.log,
        });

        dispatch(InitDbDone, { db });
      }
    ];

    let InitTheme = (state) => [
      state,
      (dispatch) => {
        let color = 'white';
        if (matchMedia('(prefers-color-scheme: dark)').matches) color = 'night';
        dispatch(ApplySettings, { color });
      }
    ];

    let InitRouter = (state) => [
      state,
      (dispatch) => {
        addEventListener('hashchange', (event) => {
          let from = state.router.parse(new URL(event.oldURL).hash.slice(1));
          let to = state.router.parse(new URL(event.newURL).hash.slice(1));
          if (!to.book) {
            dispatch(ShowRecentBooks);
          } else {
            dispatch(OpenBook, { bookId: to.book, chapterId: to.chapter });
          }
        });
      }
    ];

    let InitKeyboardNavigator = (state) => [
      state,
      (dispatch) => {
        addEventListener('keydown', (event) => {
          switch(event.key) {
            case 'ArrowRight': dispatch(OpenNextChapter, +1); break;
            case 'ArrowLeft': dispatch(OpenNextChapter, -1); break;
            case 'Backspace': dispatch(ShowRecentBooks); break;
            default: break;
          }
        });
      }
    ];

    let LoadSettings = (state) => [
      state,
      async (dispatch) => {
        let settings = {};
        let cursor = await state.db.transaction('settings').store.openCursor();
        while (cursor) {
          settings[cursor.key] = cursor.value;
          cursor = await cursor.continue();
        }
        dispatch(ApplySettings, settings);
      }
    ];
    let ApplySettings = (state, settings) => [
      { ...state, settings: { ...state.settings, ...settings } },
      () => {
        for (let [key, value] of Object.entries(settings)) {
          document.documentElement.dataset[key] = (value ?? '');
        }
      }
    ];
    let SaveSettings = (state, settings) => [
      state,
      async (dispatch) => {
        dispatch(ApplySettings, settings);

        let tx = state.db.transaction('settings', 'readwrite');
        await Promise.all([
          ...Object.entries(settings).map(([key, value]) => {
            document.documentElement.dataset[key] = (value || '');
            return tx.store.put(value, key);
          }),
          tx.done,
        ]);
      }
    ];

    let LoadRecentBooksDone = (state, { files }) => ({ ...state, files });
    let LoadRecentBooks = (state) => [
      state,
      async (dispatch) => {
        let files = await state.db.getAll('files');
        files.sort((a, z) => a.name.localeCompare(z.name, 'vi-VN', { sensitivity: 'accent' }));
        dispatch(LoadRecentBooksDone, { files });
      }
    ];

    let LoadProgressDone = (state, { progress }) => ({ ...state, progress });
    let LoadProgress = (state) => [state, async (dispatch) => {
      let progress = {};
      let cursor = await state.db.transaction('progress').store.openCursor();
      while (cursor) {
        progress[cursor.key] = cursor.value;
        cursor = await cursor.continue();
      }
      dispatch(LoadProgressDone, { progress });
    }];

    let LoadRecentBook = (state) => [
      state,
      (dispatch) => {
        let bookId = state.router.get('book');
        let chapterId = state.router.get('chapter');
        if (bookId) {
          dispatch(OpenBook, { bookId, chapterId })
        }
      }
    ];

    let OpenBookDone = (state, { book, chapter }) => [
      { ...state, book, chapter },
      (dispatch) => {
        if (state.book?.id == book.id)
          state.router.replace({ book: book.id, chapter: chapter.id });
        else
          state.router.push({ book: book.id, chapter: chapter.id });

        document.title = [...new Set([book.name, chapter.title])].join(' | ');

        requestAnimationFrame(() => {
          scroll(0, 0);

          //scroll bookmark into view
          let bookmark = document.querySelector('nav .active');
          let nav = document.querySelector('nav');
          let bookmarkRect = bookmark.getBoundingClientRect();
          let isOutOfView = bookmarkRect.top < 0 || nav.clientHeight < bookmarkRect.bottom;
          if (isOutOfView) bookmark.scrollIntoView({ block: 'center' });
        });
      }
    ];
    let OpenBook = (state, { bookId, chapterId, migrate = true, retry = true }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [book, chapter] = await Promise.all([
          state.db.get('books', bookId),
          state.db.get('chapters', bookId + '/' + chapterId),
        ]);
        if (!book) {
          console.info('Book not found:', { book, chapter });
          if (migrate) dispatch(RefreshBook, { bookId, onSuccess: [OpenBook, { bookId, chapterId, migrate: false, retry }] });
          return
        }
        if (!chapter) {
          console.info('Chapter not found:', { bookId, chapterId });
          if (retry) {
            chapterId = book.chapters[0].id;
            dispatch(OpenBook, { bookId, chapterId, retry: false });
          }
          return;
        }

        let chapters = [...book.chapters];
        let chapterIndex = chapters.findIndex(c => c.id == chapter.id);
        if (chapterIndex < 0) chapterIndex = 0;
        chapters[chapterIndex] = chapter;

        dispatch(OpenBookDone, { book, chapter });
        dispatch(SaveProgress, { book, chapter });
      }
    ];

    let OpenNextChapter = (state, indexDelta = 1) => [
      state,
      (dispatch) => {
        let chapterIndex = state.book.chapters.findIndex(c => c.id == state.chapter.id);
        let nextChapter = state.book.chapters[chapterIndex + indexDelta];
        if (nextChapter) {
          dispatch(OpenBook, { bookId: state.book.id, chapterId: nextChapter.id });
        }
      }
    ];

    let SaveProgressDone = (state, { book, progress }) => ({ ...state, progress: { ...state.progress, [book.id]: progress } });
    let SaveProgress = (state, { book, chapter }) => {
      return [
        state,
        async (dispatch) => {
          let progress = (await state.db.get('progress', book.id) || {});
          progress.chapterId = chapter.id;
          progress.chapterIndex = book.chapters.indexOf(chapter) + (book.chapters[0].id ? 1 : 0);
          progress.chapterCount = (book.chapters[0].id ? book.chapters.length : book.chapters.length - 1);
          progress.updatedAt = new Date().toISOString();
          await state.db.put('progress', progress, book.id);
          dispatch(SaveProgressDone, { book, progress });
        }
      ];
    };

    let InitDropzone = (state) => [
      state,
      (dispatch) => {
        addEventListener('dragenter', event => { event.preventDefault(); });
        addEventListener('dragover', event => { event.preventDefault(); });
        addEventListener('drop', event => {
          event.preventDefault();
          let files = [...event.dataTransfer.files].filter(file => file.type == 'text/plain');
          dispatch(StoreFiles, { files });
        });
      }
    ];

    let StoreFilesDone = (state, { files }) => [
      state,
      async (dispatch) => {
        //refresh recent books in state
        dispatch(LoadRecentBooks);

        //open if stored only one book
        if (files.length == 1) {
          let { file } = files[0];
          let book = Book(file);
          let chapterId = (await state.db.get('progress', book.id))?.chapterId;
          state.router.push({ book: book.id, chapterId });
          dispatch(OpenBook, { bookId: book.id, chapterId });
        } else {
          state.router.push({});
          dispatch(ShowRecentBooks);
        }
      }
    ];
    let StoreFiles = (state, { files: localFiles, fileContents }) => [
      state,
      async (dispatch) =>  {
        let readFile = (localFile) => new Promise(resolve => {
          let reader = new FileReader();
          reader.addEventListener('load', event => {
            let file = {
              name: localFile.name,
              size: localFile.size,
            };
            let fileContent = event.target.result;
            resolve({ file, fileContent });
          });
          reader.readAsText(localFile);
        });

        let files = [];
        for (let localFile of localFiles) {
          files.push(await readFile(localFile));
        }

        dispatch(StoreBooks, { files, onSuccess: [StoreFilesDone, { files }] });
        /**
        for (let i = 0; i < localFiles.length; i++) {
          let reader = new FileReader();
          reader.addEventListener('load', async event => {
            fileContents[i] = event.target.result;
            files[i] = {
              name: localFiles[i].name,
              size: localFiles[i].size,
            };

            let book = Book(files[i]);
            let existingFile = await state.db.get('files', book.id);
            if (existingFile?.size != files[i].size) {
              book = Book(files[i], fileContents[i]);
              dispatch(SaveProgress, { book, chapter: book.chapters[0] });
              updated[i] = true;
            }

            let tx = state.db.transaction(['files', 'fileContents'], 'readwrite');
            await Promise.all([
              tx.objectStore('files').put(files[i], book.id),
              tx.objectStore('fileContents').put(fileContents[i], book.id),
              tx.done,
            ]);

            dispatch(StoreBook, { bookId: book.id });
            storedCount++;

            if (storedCount == localFiles.length) {
              
            }
          });
          reader.readAsText(localFiles[i]);
        }
        /**/
      },
    ];

    let StoreBooks = (state, { files, onSuccess }) => [
      state,
      async (dispatch) => {
        let chapterKeys = await state.db.getAllKeys('chapters');

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          ...files.flatMap(({ file, fileContent }) => {
            let book = Book(file, fileContent);
            return [
              tx.objectStore('files').put(file, book.id),
              tx.objectStore('fileContents').put(fileContent, book.id),
              tx.objectStore('books').put(book.toJSON(), book.id),
              ...chapterKeys.filter(k => k.startsWith(book.id + '/')).map(k => tx.objectStore('chapters').delete(k)),
              ...book.chapters.map(c => tx.objectStore('chapters').put(c.toJSON(), book.id + '/' + c.id)),
            ];
          }),
          tx.done,
        ]);

        if (onSuccess) dispatch(...onSuccess);
      }
    ];

    let RefreshBook = (state, { bookId, onSuccess }) => [
      state,
      async (dispatch) => {
        if (!bookId) {
          console.info('Failed to load file:', { bookId, chapterId });
          return;
        }

        let [file, fileContent] = await Promise.all([
          state.db.get('files', bookId),
          state.db.get('fileContents', bookId),
        ]);
        if (!file || !fileContent) {
          console.info('File not found:', { bookId, file, fileContent });
          return;
        }
        
        if (!onSuccess) onSuccess = [OpenBook, { bookId }];

        dispatch(StoreBooks, {
          files: [{ file, fileContent }],
          onSuccess,
        });
      }
    ];

    let DeleteBookDone = (state, { bookId }) => ({ ...state, files: state.files.filter(file => Book(file).id != bookId) });
    let DeleteBook = (state, { bookId }) => [
      state,
      async (dispatch) => {
        let chapterKeys = (await state.db.getAllKeys('chapters')).filter(k => k.startsWith(bookId + '/'));

        let tx = state.db.transaction(['files', 'fileContents', 'books', 'chapters'], 'readwrite');
        await Promise.all([
          tx.objectStore('files').delete(bookId),
          tx.objectStore('fileContents').delete(bookId),
          tx.objectStore('books').delete(bookId),
          ...chapterKeys.map(k => tx.objectStore('chapters').delete(k)),
          tx.done,
        ]);

        dispatch(DeleteBookDone, { bookId });
      }
    ];

    let ShowRecentBooks = (state) => {
      if (!state.book) return state;
      return [
        { ...state, book: null, chapter: null },
        () => {
          state.router.push({});
          document.title = 'Text Reader';
          requestAnimationFrame(() => {
            scroll(0, 0);
          });
        }
      ];
    };

    let sizeFormatter = new Intl.NumberFormat(undefined, { notation: 'compact', style: 'unit', unit: 'byte', unitDisplay: 'narrow' });
    let formatSize = sizeFormatter.format.bind(sizeFormatter);

    let dateFormatter = new Intl.RelativeTimeFormat();
    let formatDate = (iso) => {
      if(!iso) return;
      let diff = (Date.now () - new Date(iso)) / 1000;
      for (let [unit, seconds] of Object.entries({
        months: 30 * 24 * 60 * 60,
        days: 24 * 60 * 60,
        hours: 60 * 60,
        minutes: 60,
        seconds: 0,
      })) {
        if (diff >= seconds) return dateFormatter.format(-Math.round(diff / (seconds || 1)), unit);
      }
    };

    app({
      init: [
        {
          router: new HashRouter(),
          db: null,
          files: [],
          book: null,
          chapter: null,
          progress: {},
          settings: {
            sort: {
              field: 'updatedAt',
              direction: 'desc'
            }
          },
        },
        (dispatch) => {
          dispatch(InitRouter);
          dispatch(InitTheme);
          dispatch(InitDb);
          dispatch(InitDropzone);
          dispatch(InitKeyboardNavigator);
        }
      ],
      dispatch: (dispatch) => {
        return (action, payload) => {
          if (typeof action == 'function') {
            let log = [action.name];
            if (payload !== undefined) log.push(payload);
            console.warn(...log);
          } else if (Array.isArray(action)) {
            //console.dir(action[0]);
          }

          dispatch(action, payload);
        };
      },
      node: document.body,
      view: ({ router, files, book, chapter, progress, settings }) => (
        h('body', {}, [
          !book && (
            h('div', { class: 'table' }, [
              h('a', {
                class: 'th text-left',
                'data-sort': settings.sort.field == 'name' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'name', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('File'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'size' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'size', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Size'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'chapterCount' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'chapterCount', direction = 'asc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Chapters'))),
              h('a', {
                class: 'th text-right',
                'data-sort': settings.sort.field == 'updatedAt' && settings.sort.direction,
                href: '#',
                onclick: (_, event) => {
                  event.preventDefault();
                  let field = 'updatedAt', direction = 'desc';
                  if ((settings.sort.field == field) && (settings.sort.direction == direction)) direction = ['asc', 'desc'].find(d => d != direction);
                  return [SaveSettings, { sort: { field, direction } }];
                }
              }, h('span', {}, text('Date'))),
              h('span', { class: 'th' }, h('span', {})),
              ...files.sort((a, z) => {
                let { field, direction } = settings.sort;
                let A = Book(a), Z = Book(z);
                let result;
                if (field == 'name') {
                  result = A.name.localeCompare(Z.name, 'vi-VN', { sensitivity: 'accent' });
                } else if (field == 'size') {
                  result = a[field] - z[field];
                } else if (field == 'updatedAt') {
                  a = new Date(progress[A.id]?.[field] || 0);
                  z = new Date(progress[Z.id]?.[field] || 0);
                  result = a - z;
                } else if (field == 'chapterCount') {
                  result = (progress[A.id]?.[field] || 1) - (progress[Z.id]?.[field] || 1);
                }
                if ((direction == 'desc') && (result != 0)) result = -result;
                return result;
              }).flatMap(file => {
                let book = Book(file);
                let { chapterId, chapterIndex, chapterCount, updatedAt } = (progress[book.id] || {});
                return [
                  h('div', { class: 'td' }, [
                    h('a', {
                      class: 'name',
                      href: router.route({ book: book.id, chapter: chapterId }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [OpenBook, { bookId: book.id, chapterId }];
                      }
                    }, [
                      text(book.name)
                    ]),
                    book.description && (
                      h('small', { class: 'desc' }, text(book.description))
                    )
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(formatSize(file.size)))
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(!chapterCount ? '-' : `${chapterIndex}/${chapterCount}`))
                  ]),
                  h('div', { class: 'td text-right' }, [
                    h('small', {}, text(formatDate(updatedAt) || '-'))
                  ]),
                  h('div', { class: 'td' }, [
                    h('a', { class: 'delete', onclick: [DeleteBook, { bookId: book.id }] }, [
                      h('small', {}, text('delete'))
                    ])
                  ])
                ]
              })
            ])
          ),
          (book?.chapters?.length > 0) && (
            h('nav', {}, [
              h('ol', { start: 0 }, [
                ...book.chapters.map(c => (
                  h('li', { class: { active: c.id == chapter.id } }, [
                    h('a', {
                      href: router.route({ book: book.id, chapter: c.id }),
                      onclick: (_, event) => {
                        event.preventDefault();
                        return [OpenBook, { bookId: book.id, chapterId: c.id }];
                      },
                      title: c.title,
                    }, [
                      text(c.title)
                    ])
                  ])
                ))
              ])
            ])
          ),
          chapter && (
            h('main', {}, [
              h('article', {}, [
                ...chapter.content.split(/\n|<\/?\w+>/gi).map(line => (
                    /^[-]+$/.test(line)
                      ? h('hr', {})
                      : h('p', {}, text(line))
                  )
                )
              ])
            ])
          ),
          h('aside', { class: 'settings' }, [
            chapter && (
              h('a', {
                class: 'close',
                href: router.route({}),
                onclick: (_, event) => {
                  event.preventDefault();
                  return [ShowRecentBooks];
                }
              })
            ),
            h('div', { class: 'colors' }, ['white', 'sepia', 'gray', 'night', 'rose-pine', 'rose-pine-moon', 'rose-pine-dawn'].map(color => (
              h('button', {
                class: [color, { checked: settings.color == color }],
                onclick: [SaveSettings, { color: color }],
                title: color,
              })
            ))),
            chapter && (
              h('button', { class: 'refresh', onclick: [RefreshBook, { bookId: book.id, chapterId: chapter.id }] })
            )
          ])
        ])
      )
    });

    function Book(file, fileContent, chapters) {
      let id, name, description;
      if (file?.name) {
        name = /(?<name>^[^(]*).*?\.txt/.exec(file.name.normalize()).groups.name.trim();
        description = /(?<description>\(.*)\.txt/.exec(file?.name.normalize())?.groups?.description?.trim();
        id = slug(name);
      }
      if (fileContent) {
        fileContent = normalizeFileContent(fileContent);
        // fileContent = titleizeHumanName(fileContent);
        chapters = extractChapters(name, fileContent, { name });
      }
      return {
        id,
        name,
        description,
        chapters,
        toJSON() {
          return {
            id,
            name,
            description,
            chapters: chapters.map(c => {
              c = c.toJSON();
              delete c.content;
              return c;
            }),
          }
        }
      };
    }

    function normalizeFileContent(text) {
      text = text.normalize();
      text = text.replace(/[^.]*(S·∫Øc Hi·ªán Vi·ªán|S·∫Øc Hi·ªáp Vi·ªán|Sachiepvien\.net)[^.]*\.?/g, '');
      text = text.replace(/[\r\n]+/g, '\n');
      text = text.replace(/(.+)/g, (s) => s.trim());
      text = text.replace(/^'([^']+)'$/gm, '"$1"');
      text = text.replace(/(\d)\s*(\.)\s*(\d)/gm, '$1$2$3');
      text = text.replace(/\s+([.,;:?!\]„Äë)])/gm, '$1');
      text = text.replace(/([([„Äê])\s+/gm, '$1');
      text = text.replace(/([:‚Äî]{2,})/gm, c => c.slice(0, 1));
      text = text.replace(/(:)[^\s\w]+\s*/gm, '$1 ');
      text = text.replace(/^\s*"\s+|\s+"\s*$/gm, '"');
      return text;
    }

    function Chapter(_, { chapters, filename, text }) {
      return {
        _,
        get title() {
          let title, titleBook, titleChap;
          if (_.bookNum) titleBook = 'B·ªô ' + _.bookNum;
          else if (_.bookText) titleBook = 'B·ªô ' + _.bookText;
          if (_.chapNum) titleChap = 'Ch∆∞∆°ng ' + _.chapNum;
          else if (_.chapText) titleChap = 'Ch∆∞∆°ng ' + _.chapText;
          title = [titleBook, titleChap].filter(Boolean).join(' ');
          title = [title, _.title].filter(Boolean).join(': ');
          if (!title) title = _.text;
          return title;
        },
        get i() {
          return chapters.indexOf(this);
        },
        get startIndex() {
          // return text.lastIndexOf('\n', _.index);
          return _.index;
        },
        get endIndex() {
          if (this.i == chapters.length-1) return text.length;
          return chapters[this.i + 1].startIndex;
        },
        get id() {
          return slug(this.title) + '-' + this.i;
        },
        get content() {
          return text.slice(this.startIndex, this.endIndex).trim();
        },
        get chapter() {
          let num = _.chapNum || _.chapText;
          if (num) return Number(num);
        },
        get length() {
          return this.endIndex - this.startIndex;
        },
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            content: this.content,
          }
        }
      };
    }

    function extractChapters(filename, text, { name }) {
      let NUMERIC = '(\\d{1,3}(\\.\d{1,2})*)';
      let NUMERIC_WORDS = '((m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n|(m∆∞·ªùi( m·ªôt)?|(hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n) m∆∞∆°i( m·ªët)?)( (hai|ba|b·ªën|lƒÉm|s√°u|b·∫£y|t√°m|ch√≠n))?))|(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p)';
      let patterns = [
        /*
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 t·ª± ch∆∞∆°ng
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 th·ª© 01 ch∆∞∆°ng
        Xanh Bi·∫øc l·ªØ du ti√™n b·ªô 2 th·ª© 09 ch∆∞∆°ng
        „Äêxanh bi·∫øc l·ªØ du ti√™n b·ªô 2„Äë th·ª© 10 ch∆∞∆°ng ƒê√¥ng h·∫£i ti√™n c√°c (1)
        Xanh Bi·∫øc l·ªØ du ti√™n b·ªô 2 th·ª© 13 ch∆∞∆°ng N·ªØ ƒê·∫ø d√¢m t√¢m
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë Ch∆∞∆°ng 8:
        „ÄêCh∆∞∆°ng 8: T√¥ng m√¥n d√¢m lo·∫°n (nh·∫•t)„Äë
        „Äêxanh bi·∫øc l·ªØ du ti√™n„Äë Ch∆∞∆°ng 6:
        „ÄêCh∆∞∆°ng 6: Ho√†ng th√†nh long ·∫£nh„Äë
        Th·ª© 02 ch∆∞∆°ng: Hong Kong
        Th·ª© 1 ch∆∞∆°ng ƒë·∫°i ngh·ªãch b·∫•t ƒë·∫°o √°i ƒë·ªì, nh∆∞ng l·∫°i hy v·ªçng ƒëem s∆∞ t√¥n d·∫°y d·ªó v√¨ song tu chuy√™n d·ª•ng ·∫•u th√™!
        Th·ª© 10 ch∆∞∆°ng, v√µ di·ªÖm h√≤a kh√¥ng r√µ th√¢n ph·∫≠n nam nh√¢n th√¥ng ƒë·ªìng c√πng v·ªõi tr·∫ßn san c√πng ca ca tr·∫ßn v·ª´a lo·∫°n lu√¢n ƒë·ªãt bi chuy·ªán x∆∞a
        „Äêm·∫π th√†nh gia b√™n trong b·∫£o m·∫´u con d√¢u„Äë(15) ho√†n
        Nh·ªã, thay ƒë·ªïi
        „Äêb·∫°n g√°i ƒë·ªá ƒë·ªá„Äë3
        "B·∫°n g√°i ƒë·ªá ƒë·ªá" 11
        Th∆∞·ª£ng (2)
        Ch√≠nh VƒÉn Ch∆∞∆°ng 07: Ch·ªânh qu√¢n
        Nh·∫•t, l·ªùi d·∫´n t∆∞·ªüng n√≥i ng·∫Øn g·ªçn, nh∆∞ng kh√¥ng bi·∫øt t·ª´ ƒë√¢u n√≥i l√™n.
        Th·ª© 34 ch∆∞∆°ng m·∫´u th∆∞·ª£ng c√¥ng l∆∞·ª£c (3.11) An N·∫∑c ti·∫øn b·ªánh vi·ªán
        ‚Äî Ch∆∞∆°ng 2: (d·ªãch n√≥ng th·ªÉ)‚Äî
        2020 nƒÉm th√°ng 1 6 ng√†y
        H·∫° b·ªô ‚Äî ch·ªã em y√™u nhau (l·ª•c hi h√≤a l·ª•c n·∫øu)
        „Äêm·∫π con„Äë(nh·ªã -- y√™u n√≥i h·∫øt)
        (nh·ªã -- y√™u n√≥i h·∫øt)
        ch. 1
        H·ªìi 1: Ng√¢y th∆° di·ªán m·∫°o Khuynh Th√†nh v·∫≠n giao mui xe th·ªã l√£o √îng ph·ªß ·∫•u t·ª≠ t·ª´ hu·ªá th·ª•c hi·ªÅn Hongkong
        Th·ª© 41-48 ch∆∞∆°ng
        */
        //Ch∆∞∆°ng 23:
        //Phi√™n ngo·∫°i Ch∆∞∆°ng 18:
        '^(Phi√™n Ngo·∫°i )?Ch∆∞∆°ng CHAP_NUM:$',
        //Ch∆∞∆°ng 1: T√¢n ni√™n ƒë·∫∑c bi·ªát thi√™n (th∆∞·ª£ng)
        //Phi√™n Ngo·∫°i Ch∆∞∆°ng 8: Treo ƒë·∫ßu d√™ b√°n th·ªãt ch√≥
        '^(Phi√™n Ngo·∫°i )?Ch∆∞∆°ng CHAP_NUM([: ]TITLE)?$',
        //Ng≈©
        //Hai m∆∞∆°i m·ªët
        '^CHAP_TEXT$',
        // (1)
        '^\\(CHAP_NUM\\)$',
        //8.1
        '^CHAP_NUM$',
        // (t·ª©)
        // (m∆∞·ªùi m·ªôt)
        '^\\(CHAP_TEXT\\)$',
        //„Äêb·∫°n g√°i ƒë·ªá ƒë·ªá„Äë9
        '^„Äê' + name + '„ÄëCHAP_NUM([: ]TITLE)?',
        //Th·ª© 7 ch∆∞∆°ng m·∫´u th∆∞·ª£ng c√¥ng l∆∞·ª£c (1.7) ti·ªÉu ma n·ªØ ph·ª•c v·ª•
        // '^Th·ª© BOOK_NUM ch∆∞∆°ng ' + name + ' \\(CHAP_NUM\\)([: ]TITLE)?',
        //Th·ª© 31 ch∆∞∆°ng
        '^Th·ª© CHAP_NUM ch∆∞∆°ng([: ]TITLE)?',
        //B·∫£y nƒÉm v·ª£ ch·ªìng g·∫ßn ba nƒÉm c√πng hai c√°i ƒë∆°n nam ƒë·ªá t·ª≠ chuy·ªán x∆∞a (5)
        '^' + name + ' \\(CHAP_NUM\\)',
        //2019-7-19 m∆∞·ªùi lƒÉm
        '^DATE CHAP_TEXT',
        //M∆∞·ªùi hai, n·ª≠a nƒÉm sau cu·ªôc s·ªëng v·∫´n ƒëang ti·∫øp t·ª•c. Ph·ªë x√° nh∆∞ tr∆∞·ªõc th√°i b√¨nh.
        '^CHAP_TEXT[,] TITLE$',
        //Quy·ªÉn th·ª© hai Ch∆∞∆°ng 11: M·ªπ m·∫´u c·∫ßu xin
        '^Quy·ªÉn( th·ª©)? (BOOK_NUM|BOOK_TEXT) Ch∆∞∆°ng CHAP_NUM: TITLE',
        //L·ªùi d·∫´n
        '^(ch∆∞∆°ng (cu·ªëi|k·∫øt)|t·ª± ch∆∞∆°ng|L·ªùi d·∫´n)$',
        //„Äêxanh bi·∫øc l·ªØ du ti√™n„Äë b·ªô 2 th·ª© 08 ch∆∞∆°ng
        '^„Äê' + name + '„Äë b·ªô BOOK_NUM th·ª© CHAP_NUM ch∆∞∆°ng',
        //Xanh bi·∫øc l·ªØ du ti√™n b·ªô 2 Ch∆∞∆°ng 8: S∆° ng·ªô b√≠ch du
        '^' + name + ' b·ªô BOOK_NUM Ch∆∞∆°ng CHAP_NUM: TITLE',
        //(Ch∆∞∆°ng 20: h√®n ch√≥ di·ªÖn ph∆∞·ª£ng (che gi·∫•u thi√™n 3)
        '^\\(Ch∆∞∆°ng CHAP_NUM: TITLE',
        //Phi√™n Ngo·∫°i hai m∆∞∆°i lƒÉm ch∆∞∆°ng
        '^(Phi√™n Ngo·∫°i )CHAP_TEXT ch∆∞∆°ng',
        //„Äêc√°c huynh ƒë·ªá lo·∫°n lu√¢n th·ªãnh y·∫øn„Äë(tam)
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(1)
        '^„Äê' + name + '„Äë\\((CHAP_TEXT|CHAP_NUM)\\)',
        //„Äêkh√¥ng ch·ªâ t√¨nh y√™u„Äë(phi√™n ngo·∫°i) c·∫£nh ph·ªâ m·∫π con k√≠ch t√¨nh th∆∞·ª£ng k√≠nh
        '^„Äê' + name + '„Äë(phi√™n ngo·∫°i) TITLE',
        //"√Çn, ta ƒë·ªÅu nghe ng∆∞∆°i!" (13)
        '(?<=\\W) \\(CHAP_NUM\\)$',
        //(14) nghi√™m h·∫°o t·∫°i sofa ph√≠a tr√™n th√≠ch kh√¥ng th·ªÉ t·ª± tho√°t ra ƒë∆∞·ª£c, nh·∫•t tinh m·∫∑c xong ƒë·ªì ng·ªß, sau ƒë√≥ ti·∫øp l·∫•y ƒëem nghi√™m h·∫°o √¥m ƒë·∫øn ch√¢n c·ªßa m√¨nh ph√≠a tr√™n, nh·∫π nh√†ng √¢u y·∫øm.
        '\\(CHAP_NUM\\)',
        //"2" h√†o m√¥n b√≠ m·∫≠t
        '^"\\s*CHAP_NUM\\s*"( TITLE)?',
        //"13 ch∆∞∆°ng k·∫øt"
        '^"CHAP_NUM TITLE"$',
        //Ng∆∞·ªùi nh√† qu·∫ßn √°o Ch∆∞∆°ng 1: M·∫π d·ªã th∆∞·ªùng
        '^' + name + ' Ch∆∞∆°ng CHAP_NUM: TITLE$',
        //T·∫≠p th·ª© hai th·ª© 36 ch∆∞∆°ng con tin uy hi·∫øp
        '^T·∫≠p th·ª© BOOK_TEXT th·ª© CHAP_NUM ch∆∞∆°ng TITLE$',
        //22)
        '^CHAP_NUM\\)$',
      ];
      let matches = [];
      for (let pattern of patterns) {
        let source = pattern
          .replace('DATE', '\\d+-\\d+-\\d+')
          .replace('SEP', '[ :]')
          .replace('TITLE', '(?<title>.+)')
          .replace('CHAP_NUM', `(?<chapNum>${NUMERIC})`)
          .replace('CHAP_TEXT', `(?<chapText>${NUMERIC_WORDS})`)
          .replace('BOOK_NUM', `(?<bookNum>${NUMERIC})`)
          .replace('BOOK_TEXT', `(?<bookText>${NUMERIC_WORDS})`);
        let regex = new RegExp(source, 'gimu');
        let result = [...text.matchAll(regex)];
        matches.push(...result.map(m => ({ pattern, regex, index: m.index, ...m.groups, text: m[0] })));
      }
      matches.forEach(m => {
        for (let f of ['chapText', 'bookText']) {
          if (m[f]) {
            let c = m[f].toLowerCase();
            let vn = {
              'm∆∞∆°i': '',
              'm∆∞∆°i$': 0,
              '(m∆∞·ªùi|th·∫≠p)(?=.+)|m[·ªô·ªë]t|nh·∫•t': 1,
              'hai|nh·ªã': 2,
              'ba|tam': 3,
              'b·ªën|t·ª©': 4,
              '[nl]ƒÉm|ng≈©': 5,
              's√°u|l·ª•c': 6,
              'b·∫£y|th·∫•t': 7,
              't√°m|b√°t': 8,
              'ch√≠n|c·ª≠u': 9,
              'm∆∞·ªùi|th·∫≠p': 10,
            };
            Object.entries(vn).forEach(([w, i]) => {
              w = new RegExp(w, 'gimu');
              c = c.replace(w, i);
            });
            c = c.replace(/\s/g, '');
            m[f] = Number.parseInt(c);
          }
        }
        for (let f of ['chapNum', 'bookNum']) {
          if (m[f]) {
            m[f] = m[f].split('.').map(Number).join('.');
          }
        }
      });
      matches.sort((a, z) => a.index - z.index);

      let chapters = [];
      matches.forEach(m => {
        chapters.push(Chapter(m, { chapters, filename, text }));
      });

      mergeShortChapters(chapters, 500);
      dedupeChapters(chapters);
      cleanupChapters(chapters);
      addPrologue(chapters, filename, text);

      return chapters;
    }

    function mergeBehind(chapters, i) {
      // chapters[i].endIndex = chapters[i+1].endIndex;
      chapters.splice(i, 1);
    }

    function dedupeChapters(chapters) {
      for (let i = chapters.length - 1; i > 0; i--) {
        let h = i-1;
        let ch = chapters[h];
        let ci = chapters[i];
        if (ch.chapter && ch.chapter == ci.chapter) {
          // console.log('dedupe', ch.title, ci.title);
          mergeBehind(chapters, i);
        }
      }
    }

    function cleanupChapters(chapters) {
      // debug({chapters})
      let i = 1;
      while (i < chapters.length - 1) {
        let [ch, ci, cj] = [chapters[i-1], chapters[i], chapters[i+1]];
        let shouldMerge = false;
        //ci is not continuity of ch
        if (ch.chapter && ci.chapter && (ch.chapter + 1 != ci.chapter)) {
          if (!cj) {
            //ci is the last chapter, can merge
            //TODO: check if ci is [phien ngoai]
            shouldMerge = true;
          } else {
            //find continuity of ch
            for (let j = i + 1; j <= i + 3 && j < chapters.length; j++) {
              cj = chapters[j];
              // console.log(ch.chapter, cj.chapter);
              if (cj.chapter && (ch.chapter + 1 == cj.chapter)) {
                shouldMerge = true;
                break;
              }
            }
          }
        }
        if (shouldMerge) {
          // console.debug('cleanupChapters', ch.chapter, '<-', ci.chapter, cj?.chapter);
          mergeBehind(chapters, i);
        } else {
          i++;
        }
      }
      // for(let i = 1; i < chapters.length; ) {
      //   let [h, j] = [i - 1, i + 1];
      //   //if ci is not continuity of ch
      //   if (ch.chapter && ci.chapter && (ch.chapter + 1) != ci.chapter) {
      //     // ci is the last chapter, can merge
      //     if (!cj) {
      //       console.debug('cleanupChapters', ch.chapter, '<-', ci.chapter);
      //       mergeBehind(chapters, i);
      //     } else {
      //       // cj is the continuity of ch
      //       if (cj.chapter && ch.chapter + 1 == cj.chapter) {
      //       }
      //     }
      //   }
      // }
    }
    
    function mergeShortChapters(chapters, minLength = 2_000) {
      for (let i = chapters.length - 1; i > 0; i--) {
        if (chapters[i].length < minLength) {
          mergeBehind(chapters, i);
        }
      }
    }

    function mergeShortChapters1(chapters, minLength = 2e3) {
      let isShort = chapter => ((chapter.endIndex - chapter.startIndex) <= minLength);
      let isLong = chapter => !isShort(chapter);
      //delete all first short chapters, they belongs to prologue
      let firstLongChapterIndex = chapters.findIndex(isLong);
      chapters.splice(0, firstLongChapterIndex);
      //merge short chapters to next long chapter
      let short;
      while((short = chapters.find(isShort))) {
        let shortIndex = chapters.indexOf(short);
        let long = chapters.find((chapter, index) => isLong(chapter) && index >= shortIndex);
        let longIndex = chapters.indexOf(long);
        if (long) {
          short.endIndex = long.endIndex;
          chapters.splice(shortIndex, longIndex - shortIndex);
        } else {
          //merge last short chapters to previous long chapter
          long = chapters[shortIndex - 1];
          if (long) {
            long.endIndex = text.length;
            chapters.length = shortIndex;
          }
          break;
        }
      }
    }

    function addPrologue(chapters, filename, text) {
      //extract prologue
      let prologue = text.slice(0, chapters[0]?.startIndex ?? -1).trim();
      if(prologue) {
        chapters.unshift(Chapter({
          title: filename,
          index: 0,
        }, { chapters, filename, text }));
      }
    }

    function extractChapters1(filename, text, { name }) {
      let debug = true;
      debug && console.log({ name });
      //let chapterPattern = /^\s*\[?\s*(?:chapter)?\s*:?\s*Th·ª©\s+\w+(\s*-\s*\d+)?\s+ch∆∞∆°ng\b.*|\bCh∆∞∆°ng\s+\d+\s*:?.*|^(?:\d+\s*\.?\s*)+$|^\s*\d+\s+Ch∆∞∆°ng\s*:?\s*|^„Äê.*?„Äë\([\d-]+\)$|^„Äê.*?„Äë\s*b·ªô(\s+\d+)+$|^\d+[.!].*|^\s*\d+(\s*-\s*\d+)?\s*$|^[-]+$/gimu;
      let certainPatterns = [
        /^ch∆∞∆°ng \d+$/,
        /^ch∆∞∆°ng \d+:/,
        /^‚Äî ?ch∆∞∆°ng \d+:.*? ?‚Äî/,
        /^ch∆∞∆°ng (cu·ªëi|k·∫øt)/,
        /^t·ª± ch∆∞∆°ng/,
        /^L·ªùi d·∫´n/,
        /^b·ªô \d+:? ch∆∞∆°ng \d+/, // b·ªô 01: ch∆∞∆°ng 05:
        /^th·ª© \d+ b·ªô th·ª© \d+ ch∆∞∆°ng/, // th·ª© 01 b·ªô th·ª© 02 ch∆∞∆°ng
        /^\d+([\.\s]+\d+)*$/,
        /th·ª© \d+ ch∆∞∆°ng/,
        /^\(\d+\)/,
        /^H·ªìi \d+/,
        new RegExp('^„Äê' + name + '„Äë\\d+$'),
        new RegExp('^"' + name + '" \\d+$'),
        /^ch\. \d+/,
        /^ ?\[? ?(?:chapter)? ?:? ?Th·ª© \w+( ?- ?\d+)? ch∆∞∆°ng/,
        /^ ?\d+ Ch∆∞∆°ng ?:? ?/,
        /^„Äê.*?„Äë\([\d-]+\)$/,
        /^„Äê.*?„Äë ?b·ªô( \d+)+$/,
        /^\d+[.!].*/,
        /^ ?\d+( ?- ?\d+)? ?$/,
        /quy·ªÉn (th·ª© )?(\d+|(m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n|(m∆∞·ªùi( m·ªôt)?|(hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n) m∆∞∆°i( m·ªët)?)( (hai|ba|b·ªën|lƒÉm|s√°u|b·∫£y|t√°m|ch√≠n))?)) ch∆∞∆°ng \d.*/,
        /(phi√™n ngo·∫°i|ch√≠nh vƒÉn) ch∆∞∆°ng \d+:/,
        /phi√™n ngo·∫°i .* ch∆∞∆°ng/,
        /^(th∆∞·ª£ng|trung|h·∫°) \(\d+\)$/,
        /^(th∆∞·ª£ng|trung|h·∫°) b·ªô/,
      ];
      let loosePatterns = [
        new RegExp('^„Äê' + name + '„Äë.*$'),
        new RegExp('^"' + name + '".*$'),
        new RegExp('^' + name + ' [\\(\\.:\\d]'),
        /^.*\((th∆∞·ª£ng|trung|h·∫°)\):?$/, // ph·∫£n k√≠ch (th∆∞·ª£ng)
        /^([(]?)(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p|(m∆∞·ªùi) (m·ªôt|hai|ba|b·ªën|nƒÉm|s√°u|b·∫£y|t√°m|ch√≠n|m∆∞∆°i))(?=[,:)])([^.]*)$/,
        /^(nh·∫•t|nh·ªã|tam|t·ª©|ng≈©|l·ª•c|th·∫•t|b√°t|c·ª≠u|th·∫≠p).*/,
        /^\[.*\]$/,
        /^[-‚Äî* ]+$/,
      ];
      let matches;
      for (let patterns of [certainPatterns, loosePatterns]) {
        let regex = new RegExp('(?:' + patterns.map(p => '(?:' + p.source + ')').join('|') + ').*', 'gimu');
        matches = [...regex[Symbol.matchAll](text)];
        debug && console.log({ regex, matches })
        if (matches.length > 0) break;
      }
      let chapters = matches.map((match, i) => {
        let startIndex = text.lastIndexOf('\n', match.index);
        if (startIndex == -1) startIndex = 0;
        let endIndex = text.length;
        if (matches[i+1]) endIndex = text.lastIndexOf('\n', matches[i+1].index);
        let title = match[0].trim();
        if (/^[-‚Äî]+$/.test(title)) title = `-Ch∆∞∆°ng ${i+1}-`;
        title = title.replace(new RegExp('^„Äê(' + name + ')„Äë\s*', 'i'), '');
        title = title.replace(new RegExp('^"(' + name + ')"\s*', 'i'), '');
        title = title.replace(new RegExp('^(' + name + ')\s*', 'i'), '');
        return {
          title,
          startIndex,
          endIndex,
        }
      });

      return mergeChapters(chapters, filename, text);
    }

    function slug(s) {
      s = latinize(s);
      s = s.replace(/\W+/g, '-');
      s = s.replace(/^-+|-+$/g, '');
      s = s.toLowerCase();
      return s;
    }

    function latinize(s) {
      s = s.replace(/[√ÅƒÇ·∫Æ·∫∂·∫∞·∫≤·∫¥«ç√Ç·∫§·∫¨·∫¶·∫®·∫™√Ñ«û»¶«†·∫†»Ä√Ä·∫¢»ÇƒÄƒÑ√Ö«∫·∏Ä»∫√É‚±Ø·¥Ä]/g, 'A');
      s = s.replace(/[Íú≤]/g, 'AA');
      s = s.replace(/[√Ü«º«¢·¥Å]/g, 'AE');
      s = s.replace(/[Íú¥]/g, 'AO');
      s = s.replace(/[Íú∂]/g, 'AU');
      s = s.replace(/[Íú∏Íú∫]/g, 'AV');
      s = s.replace(/[Íúº]/g, 'AY');
      s = s.replace(/[·∏Ç·∏Ñ∆Å·∏Ü…É∆Ç ô·¥É–ë]/g, 'B');
      s = s.replace(/[ƒÜƒå√á·∏àƒàƒä∆á»ªÍúæ·¥Ñ]/g, 'C');
      s = s.replace(/[ƒé·∏ê·∏í·∏ä·∏å∆ä·∏é«≤«Öƒê√ê∆ãÍùπ·¥Ö–î]/g, 'D');
      s = s.replace(/[«±«Ñ]/g, 'DZ');
      s = s.replace(/[√âƒîƒö»®·∏ú√ä·∫æ·ªÜ·ªÄ·ªÇ·ªÑ·∏ò√ãƒñ·∫∏»Ñ√à·∫∫»Üƒí·∏ñ·∏îƒò…Ü·∫º·∏ö∆ê∆é·¥á‚±ª–ï–≠]/g, 'E');
      s = s.replace(/[Íù™]/g, 'ET');
      s = s.replace(/[·∏û∆ëÍùªÍú∞–§]/g, 'F');
      s = s.replace(/[«¥ƒû«¶ƒ¢ƒúƒ†∆ì·∏†«§ÍùΩ…¢ õ–ì“ê]/g, 'G');
      s = s.replace(/[·∏™»û·∏®ƒ§‚±ß·∏¶·∏¢·∏§ƒ¶ ú–•]/g, 'H');
      s = s.replace(/[√çƒ¨«è√é√è·∏Æƒ∞·ªä»à√å·ªà»äƒ™ƒÆ∆óƒ®·∏¨–Ü…™–ô–´–ò]/g, 'I');
      s = s.replace(/[ÍûÇ≈î≈ò≈ñ·πò·πö·πú»ê»í·πû…å‚±§ Å Ä·¥ô·¥ö–†]/g, 'R');
      s = s.replace(/[ÍûÑ≈ö·π§≈†·π¶≈û≈ú»ò·π†·π¢·π®Íú±–°]/g, 'S');
      s = s.replace(/[ÍûÜ≈§≈¢·π∞»ö»æ·π™·π¨∆¨·πÆ∆Æ≈¶·¥õ–¢]/g, 'T');
      s = s.replace(/[Íù¨]/g, 'IS');
      s = s.replace(/[ƒ¥…à·¥ä]/g, 'J');
      s = s.replace(/[·∏∞«®ƒ∂‚±©ÍùÇ·∏≤∆ò·∏¥ÍùÄÍùÑ·¥ã–ö]/g, 'K');
      s = s.replace(/[ƒπ»ΩƒΩƒª·∏º·∏∂·∏∏‚±†Íùà·∏∫ƒø‚±¢«à≈ÅÍûÄ ü·¥å–õ]/g, 'L');
      s = s.replace(/[«á]/g, 'LJ');
      s = s.replace(/[·∏æ·πÄ·πÇ‚±Æ∆ú·¥ç–ú]/g, 'M');
      s = s.replace(/[≈É≈á≈Ö·πä·πÑ·πÜ«∏∆ù·πà»†«ã√ë…¥·¥é–ù]/g, 'N');
      s = s.replace(/[«ä]/g, 'NJ');
      s = s.replace(/[√ì≈é«ë√î·ªê·ªò·ªí·ªî·ªñ√ñ»™»Æ»∞·ªå≈ê»å√í·ªé∆†·ªö·ª¢·ªú·ªû·ª†»éÍùäÍùå≈å·πí·πê∆ü«™«¨√ò«æ√ï·πå·πé»¨∆Ü·¥è·¥ê–û]/g, 'O');
      s = s.replace(/[∆¢]/g, 'OI');
      s = s.replace(/[Íùé]/g, 'OO');
      s = s.replace(/[»¢·¥ï]/g, 'OU');
      s = s.replace(/[·πî·πñÍùí∆§Íùî‚±£Íùê·¥ò–ü]/g, 'P');
      s = s.replace(/[ÍùòÍùñ]/g, 'Q');
      s = s.replace(/[√ü]/g, 'ss');
      s = s.replace(/[…ÖÍùû·πæ∆≤·πº·¥†–í]/g, 'V');
      s = s.replace(/[Íú®]/g, 'TZ');
      s = s.replace(/[√ö≈¨«ì√õ·π∂√ú«ó«ô«õ«ï·π≤·ª§≈∞»î√ô·ª¶∆Ø·ª®·ª∞·ª™·ª¨·ªÆ»ñ≈™·π∫≈≤≈Æ≈®·π∏·π¥·¥ú–£]/g, 'U');
      s = s.replace(/[Íù†]/g, 'VY');
      s = s.replace(/[·∫Ç≈¥·∫Ñ·∫Ü·∫à·∫Ä‚±≤·¥°]/g, 'W');
      s = s.replace(/[·∫å·∫ä]/g, 'X');
      s = s.replace(/[√ù≈∂≈∏·∫é·ª¥·ª≤∆≥·ª∂·ªæ»≤…é·ª∏ è]/g, 'Y');
      s = s.replace(/[–á]/g, 'YI');
      s = s.replace(/[≈π≈Ω·∫ê‚±´≈ª·∫í»§·∫î∆µ·¥¢–ó]/g, 'Z');
      s = s.replace(/[√û]/g, 'TH');
      s = s.replace(/[ƒ≤]/g, 'IJ');
      s = s.replace(/[≈í…∂]/g, 'OE');
      s = s.replace(/[√°ƒÉ·∫Ø·∫∑·∫±·∫≥·∫µ«é√¢·∫•·∫≠·∫ß·∫©·∫´√§«ü»ß«°·∫°»Å√†·∫£»ÉƒÅƒÖ·∂è·∫ö√•«ª·∏Å‚±•√£…ê‚Çê–ê–∞]/g, 'a');
      s = s.replace(/[Íú≥]/g, 'aa');
      s = s.replace(/[√¶«Ω«£·¥Ç]/g, 'ae');
      s = s.replace(/[Íúµ]/g, 'ao');
      s = s.replace(/[Íú∑]/g, 'au');
      s = s.replace(/[ÍúπÍúª]/g, 'av');
      s = s.replace(/[ÍúΩ]/g, 'ay');
      s = s.replace(/[·∏É·∏Ö…ì·∏á·µ¨·∂Ä∆Ä∆É–±]/g, 'b');
      s = s.replace(/[…µ√≥≈è«í√¥·ªë·ªô·ªì·ªï·ªó√∂»´»Ø»±·ªç≈ë»ç√≤·ªè∆°·ªõ·ª£·ªù·ªü·ª°»èÍùãÍùç‚±∫≈ç·πì·πë«´«≠√∏«ø√µ·πç·πè»≠…î·∂ó·¥ë·¥ì‚Çí–æ]/g, 'o');
      s = s.replace(/[ƒáƒç√ß·∏âƒâ…ïƒã∆à»º‚ÜÑÍúø]/g, 'c');
      s = s.replace(/[ƒè·∏ë·∏ì»°·∏ã·∏ç…ó·∂ë·∏è·µ≠·∂Åƒë…ñ∆å√∞Íù∫–¥]/g, 'd');
      s = s.replace(/[ƒ±√≠ƒ≠«ê√Æ√Ø·∏Ø·ªã»â√¨·ªâ»ãƒ´ƒØ·∂ñ…®ƒ©·∏≠—ñ·¥â·µ¢–π—ã–∏]/g, 'i');
      s = s.replace(/[»∑…ü Ñ«∞ƒµ ù…â‚±º]/g, 'j');
      s = s.replace(/[«≥«Ü]/g, 'dz');
      s = s.replace(/[√©ƒïƒõ»©·∏ù√™·∫ø·ªá·ªÅ·ªÉ·ªÖ·∏ô√´ƒó·∫π»Ö√®·∫ª»áƒì·∏ó·∏ï‚±∏ƒô·∂í…á·∫Ω·∏õ…õ·∂ì…ò«ù‚Çë–µ—ç]/g, 'e');
      s = s.replace(/[Íù´]/g, 'et');
      s = s.replace(/[·∏ü∆í·µÆ·∂ÇÍùº—Ñ]/g, 'f');
      s = s.replace(/[«µƒü«ßƒ£ƒùƒ°…†·∏°·∂É«•·µπ…°·µ∑–≥“ë]/g, 'g');
      s = s.replace(/[·∏´»ü·∏©ƒ•‚±®·∏ß·∏£·∏•…¶·∫ñƒß…• Æ Ø—Ö]/g, 'h');
      s = s.replace(/[∆ï]/g, 'hv');
      s = s.replace(/[ÍûÉ≈ï≈ô≈ó·πô·πõ·πù»ë…æ·µ≥»ì·πü…º·µ≤·∂â…ç…Ω…ø…π…ª…∫‚±π·µ£—Ä]/g, 'r');
      s = s.replace(/[ÍûÖ≈ø·∫ú·∫õ·∫ù≈õ·π•≈°·πß≈ü≈ù»ô·π°·π£·π© Ç·µ¥·∂ä»ø—Å]/g, 's');
      s = s.replace(/[Íûá≈•≈£·π±»õ»∂·∫ó‚±¶·π´·π≠∆≠·πØ·µµ∆´ à≈ß á—Ç]/g, 't');
      s = s.replace(/[Íù≠]/g, 'is');
      s = s.replace(/[·∏±«©ƒ∑‚±™ÍùÉ·∏≥∆ô·∏µ·∂ÑÍùÅÍùÖ û–∫]/g, 'k');
      s = s.replace(/[ƒ∫∆ö…¨ƒæƒº·∏Ω»¥·∏∑·∏π‚±°Íùâ·∏ª≈Ä…´·∂Ö…≠≈ÇÍûÅ–ª]/g, 'l');
      s = s.replace(/[«â]/g, 'lj');
      s = s.replace(/[·∏ø·πÅ·πÉ…±·µØ·∂Ü…Ø…∞–º]/g, 'm');
      s = s.replace(/[≈Ñ≈à≈Ü·πã»µ·πÖ·πá«π…≤·πâ∆û·µ∞·∂á…≥√±–Ω]/g, 'n');
      s = s.replace(/[«å]/g, 'nj');
      s = s.replace(/[∆£]/g, 'oi');
      s = s.replace(/[Íùè]/g, 'oo');
      s = s.replace(/[»£]/g, 'ou');
      s = s.replace(/[·πï·πóÍùì∆•·µ±·∂àÍùï·µΩÍùë–ø]/g, 'p');
      s = s.replace(/[Íùô †…ãÍùó]/g, 'q');
      s = s.replace(/[·¥ù√∫≈≠«î√ª·π∑√º«ò«ö«ú«ñ·π≥·ª•≈±»ï√π·ªß∆∞·ª©·ª±·ª´·ª≠·ªØ»ó≈´·πª≈≥·∂ô≈Ø≈©·ππ·πµ·µ§—É]/g, 'u');
      s = s.replace(/[·µ∫√æ]/g, 'th');
      s = s.replace(/[·¥î≈ì]/g, 'oe');
      s = s.replace(/[ å‚±¥Íùü·πø ã·∂å‚±±·πΩ·µ•–≤]/g, 'v');
      s = s.replace(/[ ç·∫É≈µ·∫Ö·∫á·∫â·∫Å‚±≥·∫ò]/g, 'w');
      s = s.replace(/[ é√Ω≈∑√ø·∫è·ªµ·ª≥∆¥·ª∑·ªø»≥·∫ô…è·ªπ]/g, 'y');
      s = s.replace(/[Íú©]/g, 'tz');
      s = s.replace(/[·µ´]/g, 'ue');
      s = s.replace(/[Íù∏]/g, 'um');
      s = s.replace(/[Íù°]/g, 'vy');
      s = s.replace(/[·∫ç·∫ã·∂ç‚Çì]/g, 'x');
      s = s.replace(/[—ó]/g, 'yi');
      s = s.replace(/[≈∫≈æ·∫ë ë‚±¨≈º·∫ì»•·∫ï·µ∂·∂é ê∆∂…Ä–∑]/g, 'z');
      s = s.replace(/[Ô¨Ä]/g, 'ff');
      s = s.replace(/[Ô¨É]/g, 'ffi');
      s = s.replace(/[Ô¨Ñ]/g, 'ffl');
      s = s.replace(/[Ô¨Å]/g, 'fi');
      s = s.replace(/[Ô¨Ç]/g, 'fl');
      s = s.replace(/[ƒ≥]/g, 'ij');
      s = s.replace(/[Ô¨Ü]/g, 'st');
      s = s.replace(/[–Å]/g, 'YO');
      s = s.replace(/[–¶]/g, 'TS');
      s = s.replace(/[–®]/g, 'SH');
      s = s.replace(/[–©]/g, 'SCH');
      s = s.replace(/[–™—ä–¨—å]/g, '\'');
      s = s.replace(/[—ë]/g, 'yo');
      s = s.replace(/[—Ü]/g, 'ts');
      s = s.replace(/[—à]/g, 'sh');
      s = s.replace(/[—â]/g, 'sch');
      s = s.replace(/[–ñ]/g, 'ZH');
      s = s.replace(/[–∂]/g, 'zh');
      s = s.replace(/[–Ø]/g, 'Ya');
      s = s.replace(/[–ß]/g, 'CH');
      s = s.replace(/[–Æ]/g, 'YU');
      s = s.replace(/[—è]/g, 'ya');
      s = s.replace(/[—á]/g, 'ch');
      s = s.replace(/[—é]/g, 'yu');
      return s;
    }

    function titleizeHumanName(s, minOccurence = 10, occurenceThreshold = 0.8) {
      let debug = false;
      debug && console.time('titleizeHumanName');
      let pattern = /(?:(?<pre>\p{Ll}+)[ ]+)?(?<name>[\p{Lu}A-Z]\p{Ll}+(?:[ ]+\p{Lu}\p{Ll}+)?)(?:[ ]+(?<post>\p{Ll}+))?/gu;
      let counts = {};
      let match;
      let titleize = s => s.replace(/(?<=^|[^\p{L}])\p{L}/gu, s => s.toUpperCase());
      let c = 0;
      while ((match = pattern.exec(s))) {
        if (++c < 10) debug && console.log({ match });
        let { pre, name, post } = match.groups;
        if (!counts[name]) counts[name] = { total: 0, pre: {}, post: {} };
        counts[name].total += 1;
        if (pre) {
          if (!counts[name].pre[pre]) counts[name].pre[pre] = 0;
          counts[name].pre[pre] += 1;
        }
        if (post) {
          if (!counts[name].post[post]) counts[name].post[post] = 0;
          counts[name].post[post] += 1;
        }
      }
      debug && console.dir(counts);
      analyze: for (let [name, { total, pre, post }] of Object.entries(counts)) {
        if (total < minOccurence) {
          debug && console.debug(name, 'is too few .. IGNORE', { total });
          continue analyze;
        }
        for (let [prefix, prefixCount] of Object.entries(pre)) {
          if (prefixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(prefix), name, { total, prefixCount });
            s = s.replace(new RegExp(prefix + '\\s+' + name, 'gu'), titleize);
            continue analyze;
          }
        }
        for (let [postfix, postfixCount] of Object.entries(post)) {
          if (postfixCount / total >= occurenceThreshold) {
            debug && console.warn(name, '->', titleize(postfix), name, { total, postfixCount });
            s = s.replace(new RegExp(name + '\\s+' + postfix, 'gu'), titleize);
            continue analyze;
          }
        }
      }
      debug && console.timeEnd('titleizeHumanName');
      return s;
    }

    function debug(...args) {
      if (args.length == 1) {
        console.table(Object.values(args[0])[0]);
      } else {
        console.info(...args);
      }
    }
  </script>
</body>
</html>


